---
phase: 04-onboarding-automation
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - scripts/new-plugin.sh
autonomous: true
verification_level: sanity

must_haves:
  truths:
    - "new-plugin.sh accepts a plugin name argument and creates a complete plugin directory under plugins/"
    - "Generated plugin passes validate-plugin.sh (exit 0)"
    - "Generated plugin scores >= 40 on score-plugin.sh (>= 90 expected from maximalist template)"
    - "new-plugin.sh rejects invalid names (uppercase, spaces, special chars) with clear error messages"
    - "new-plugin.sh exits with usage message when called with no arguments"
    - "new-plugin.sh uses jq for JSON generation (not sed on JSON)"
    - "new-plugin.sh uses sed without -i flag for text substitution (BSD/GNU portable)"
    - "new-plugin.sh does not use Bash 4+ features (no associative arrays, no mapfile)"
    - "Generated plugin does not already exist — script exits with error if plugins/<name>/ exists"
  artifacts:
    - path: "scripts/new-plugin.sh"
      provides: "Plugin scaffolding script"
      min_lines: 80
  key_links:
    - from: "scripts/new-plugin.sh"
      to: "templates/plugin-template/"
      via: "template file reading for text substitution"
      pattern: "TEMPLATE_DIR"
    - from: "scripts/new-plugin.sh"
      to: "plugins/"
      via: "output directory creation"
      pattern: "DEST.*plugins/"
    - from: "scripts/new-plugin.sh"
      to: "scripts/validate-plugin.sh"
      via: "post-scaffold validation"
      pattern: "validate-plugin\\.sh"
---

<objective>
Create the `new-plugin.sh` scaffolding script that generates a complete plugin from the template.

Purpose: This is the primary developer-facing tool for plugin onboarding. A contributor runs `./scripts/new-plugin.sh my-plugin` and gets a fully valid, high-scoring plugin directory ready for customization. The script handles input validation, JSON generation via jq, and text placeholder substitution — all portable across macOS Bash 3.2 and Linux Bash 5.x.

Output: `scripts/new-plugin.sh` executable script.
</objective>

<execution_context>
@${CLAUDE_PLUGIN_ROOT}/references/execute-plan.md
@${CLAUDE_PLUGIN_ROOT}/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-onboarding-automation/04-RESEARCH.md

# Template directory (created by Plan 01)
@.planning/phases/04-onboarding-automation/04-01-SUMMARY.md

# Existing scripts for convention reference
@scripts/validate-plugin.sh
@scripts/score-plugin.sh

# Schema for name validation pattern
@schemas/plugin.schema.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create new-plugin.sh scaffolding script</name>
  <files>scripts/new-plugin.sh</files>
  <action>
    Create `scripts/new-plugin.sh` — the plugin scaffolding script.

    Follow existing script conventions exactly (from validate-plugin.sh, score-plugin.sh):
    - Shebang: `#!/usr/bin/env bash`
    - `set -euo pipefail`
    - `SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"`
    - `REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"`

    **Usage function:**
    ```
    Usage: new-plugin.sh <plugin-name> [--description "..."] [--author "..."]
    ```
    - `--help` / `-h`: Print usage and exit 0
    - No args: Print usage and exit 2

    **Argument parsing:**
    - First positional arg = plugin name (required)
    - `--description "..."`: Optional description (default: "A Claude Code plugin")
    - `--author "..."`: Optional author name (default: output of `git config user.name` or "Your Name")
    - Parse with a `while` loop and `case` statement (Bash 3.x compatible, no `getopts` for long options)

    **Input validation** (validate_plugin_name function):
    - Empty name: error + exit 2
    - Regex check: must match `^[a-z][a-z0-9-]*$` (from plugin.schema.json). Use `echo "$name" | grep -qE '^[a-z][a-z0-9-]*$'`
    - Length check: must be <= 64 characters
    - Collision check: if `$REPO_ROOT/plugins/$name` exists, error "Plugin '$name' already exists" + exit 1

    **Directory creation:**
    - `DEST="$REPO_ROOT/plugins/$name"`
    - `TEMPLATE_DIR="$REPO_ROOT/templates/plugin-template"`
    - Verify template directory exists; exit 1 with error if not
    - Create directory structure:
      ```
      mkdir -p "$DEST/.claude-plugin"
      mkdir -p "$DEST/agents"
      mkdir -p "$DEST/commands"
      ```

    **JSON generation via jq** (NOT sed on template plugin.json):
    Generate `$DEST/.claude-plugin/plugin.json` using `jq -n`:
    ```bash
    jq -n \
      --arg name "$PLUGIN_NAME" \
      --arg desc "$DESCRIPTION" \
      --arg author "$AUTHOR" \
      '{
        name: $name,
        version: "1.0.0",
        description: $desc,
        author: { name: $author },
        homepage: ("https://github.com/YOUR-USERNAME/" + $name),
        repository: ("https://github.com/YOUR-USERNAME/" + $name),
        license: "MIT",
        keywords: ["claude-code", "plugin"],
        commands: ["./commands/example.md"],
        agents: [("./agents/" + $name + "-example-agent.md")]
      }' > "$DEST/.claude-plugin/plugin.json"
    ```

    **Text file substitution** (sed without -i, BSD-portable):
    For each template text file, substitute placeholders and write to destination:
    ```bash
    sed -e "s/{{PLUGIN_NAME}}/$PLUGIN_NAME/g" \
        -e "s/{{PLUGIN_DESCRIPTION}}/$DESCRIPTION/g" \
        "$TEMPLATE_DIR/README.md" > "$DEST/README.md"
    ```
    Apply the same pattern for: CLAUDE.md, CHANGELOG.md.

    **Agent file:** Copy template agent but rename with plugin-name prefix:
    ```bash
    sed -e "s/example-plugin/$PLUGIN_NAME/g" \
        -e "s/{{PLUGIN_NAME}}/$PLUGIN_NAME/g" \
        "$TEMPLATE_DIR/agents/example-plugin-example-agent.md" > "$DEST/agents/${PLUGIN_NAME}-example-agent.md"
    ```

    **Static files:** Copy without substitution:
    ```bash
    cp "$TEMPLATE_DIR/commands/example.md" "$DEST/commands/example.md"
    cp "$TEMPLATE_DIR/VERSION" "$DEST/VERSION"
    ```

    **Post-scaffold validation:**
    After all files are created, run validation to confirm the scaffold is valid:
    ```bash
    echo ""
    echo "Validating scaffold..."
    if "$SCRIPT_DIR/validate-plugin.sh" "$DEST"; then
      echo "PASS: Plugin '$PLUGIN_NAME' scaffolded successfully at $DEST"
    else
      echo "FAIL: Scaffold has validation errors — this is a bug, please report it." >&2
      exit 1
    fi
    ```

    **Final output:** Print a summary:
    ```
    Next steps:
      1. Edit plugins/<name>/.claude-plugin/plugin.json with your details
      2. Add your commands in plugins/<name>/commands/
      3. Add your agents in plugins/<name>/agents/
      4. Run: ./scripts/validate-local.sh plugins/<name>
      5. Submit a PR using the plugin submission template
    ```

    Make the script executable: `chmod +x scripts/new-plugin.sh`.

    CRITICAL PORTABILITY RULES:
    - No `sed -i` anywhere
    - No `declare -A` (associative arrays)
    - No `mapfile` / `readarray`
    - No `${var^^}` or `${var,,}` (case conversion)
    - No `|&` (pipe stderr)
    - All `sed` expressions use basic patterns only
  </action>
  <verify>
    Test happy path:
    ```bash
    ./scripts/new-plugin.sh test-scaffold-plugin
    # Must create plugins/test-scaffold-plugin/ with valid structure
    ./scripts/validate-plugin.sh plugins/test-scaffold-plugin  # exit 0
    ./scripts/score-plugin.sh plugins/test-scaffold-plugin --json | jq .total  # >= 40
    rm -rf plugins/test-scaffold-plugin  # cleanup
    ```
    (Level 1: Sanity)

    Test with custom args:
    ```bash
    ./scripts/new-plugin.sh test-custom --description "My custom plugin" --author "Test Author"
    jq .description plugins/test-custom/.claude-plugin/plugin.json  # "My custom plugin"
    jq .author.name plugins/test-custom/.claude-plugin/plugin.json  # "Test Author"
    rm -rf plugins/test-custom  # cleanup
    ```
    (Level 1: Sanity)

    Test invalid names:
    ```bash
    ./scripts/new-plugin.sh "INVALID" 2>&1; echo "exit: $?"  # Must show error, exit 2
    ./scripts/new-plugin.sh "has spaces" 2>&1; echo "exit: $?"  # Must show error, exit 2
    ./scripts/new-plugin.sh "123start" 2>&1; echo "exit: $?"  # Must show error, exit 2
    ./scripts/new-plugin.sh "" 2>&1; echo "exit: $?"  # Must show error, exit 2
    ```
    (Level 1: Sanity)

    Test collision detection:
    ```bash
    ./scripts/new-plugin.sh test-collision
    ./scripts/new-plugin.sh test-collision 2>&1; echo "exit: $?"  # Must show "already exists", exit 1
    rm -rf plugins/test-collision  # cleanup
    ```
    (Level 1: Sanity)

    Test no args:
    ```bash
    ./scripts/new-plugin.sh 2>&1; echo "exit: $?"  # Must print usage, exit 2
    ```
    (Level 1: Sanity)

    Verify no regression: `./scripts/run-fixture-tests.sh` still passes. (Level 1: Sanity)
  </verify>
  <done>new-plugin.sh exists, is executable, generates valid plugins that pass validation and score >= 90, rejects invalid names with clear errors, detects collisions, and uses jq for JSON + portable sed for text. No Bash 4+ features used.</done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- `./scripts/new-plugin.sh test-plugin` creates a valid plugin directory
- Generated plugin passes `validate-plugin.sh` (exit 0)
- Generated plugin scores >= 40 (target >= 90) on `score-plugin.sh`
- Invalid names are rejected with clear error messages
- No-args invocation prints usage and exits 2
- Collision with existing plugin name is detected
- `run-fixture-tests.sh` still passes

Level 2 (Proxy):
- Generated `plugin.json` parses cleanly with `jq .`
- Agent file is correctly named with plugin-name prefix
- `--description` and `--author` flags populate the manifest correctly
- Script runs on Bash 3.2 (macOS) without errors
</verification>

<success_criteria>
- scripts/new-plugin.sh scaffolds a complete plugin from template in < 2 seconds
- Generated plugin passes validation and scores >= 90
- Input validation catches all invalid name patterns
- Script is portable across macOS Bash 3.2 and Linux Bash 5.x
- No existing tests or plugins are affected
</success_criteria>

<output>
After completion, create `.planning/phases/04-onboarding-automation/04-03-SUMMARY.md`
</output>
