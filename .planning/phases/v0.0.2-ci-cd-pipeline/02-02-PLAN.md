---
phase: 02-ci-cd-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - .github/workflows/validate-plugins.yml
  - .github/workflows/publish-marketplace.yml
autonomous: true
verification_level: proxy

must_haves:
  truths:
    - "validate-plugins.yml triggers on pull_request to main when plugins/**, schemas/**, scripts/**, tests/**, package.json, or package-lock.json change"
    - "validate-plugins.yml uses dorny/paths-filter@v3 to detect which specific plugins changed (not tj-actions)"
    - "validate-plugins.yml runs validate-plugin.sh only for changed plugins via matrix strategy"
    - "validate-plugins.yml runs run-fixture-tests.sh as a parallel job to catch validation script regressions"
    - "validate-plugins.yml uses pull_request trigger (not pull_request_target) for fork security"
    - "publish-marketplace.yml triggers on push to main when plugins/**/plugin.json changes"
    - "publish-marketplace.yml runs run-fixture-tests.sh as safety gate before generation"
    - "publish-marketplace.yml runs generate-marketplace.sh then validates output against marketplace.schema.json"
    - "publish-marketplace.yml auto-commits marketplace.json using stefanzweifel/git-auto-commit-action@v7 with GITHUB_TOKEN (not PAT)"
    - "publish-marketplace.yml uses concurrency group to prevent race conditions on rapid merges"
    - "publish-marketplace.yml commit message includes [skip ci] as defense-in-depth"
    - "Both workflows use actions/setup-node@v4 with cache: 'npm' and npm ci"
    - "Both workflows pin Node.js version to 20"
  artifacts:
    - path: ".github/workflows/validate-plugins.yml"
      provides: "PR validation workflow for changed plugins"
      min_lines: 40
    - path: ".github/workflows/publish-marketplace.yml"
      provides: "Auto-publish workflow for marketplace.json on merge"
      min_lines: 30
  key_links:
    - from: ".github/workflows/validate-plugins.yml"
      to: "scripts/validate-plugin.sh"
      via: "shell step execution"
      pattern: "validate-plugin.sh"
    - from: ".github/workflows/validate-plugins.yml"
      to: "scripts/run-fixture-tests.sh"
      via: "shell step execution"
      pattern: "run-fixture-tests.sh"
    - from: ".github/workflows/publish-marketplace.yml"
      to: "scripts/generate-marketplace.sh"
      via: "shell step execution"
      pattern: "generate-marketplace.sh"
    - from: ".github/workflows/publish-marketplace.yml"
      to: "scripts/run-fixture-tests.sh"
      via: "safety gate before generation"
      pattern: "run-fixture-tests.sh"
    - from: ".github/workflows/publish-marketplace.yml"
      to: ".claude-plugin/marketplace.json"
      via: "auto-commit after generation"
      pattern: "git-auto-commit-action"
---

<objective>
Create both GitHub Actions workflows: PR validation (validate-plugins.yml) and push-to-main auto-publish (publish-marketplace.yml).

Purpose: These two workflows are the CI/CD backbone of the marketplace. The validation workflow ensures every plugin PR is checked against the schema and structural rules before merge. The publish workflow ensures marketplace.json is always regenerated from source-of-truth plugin.json files after merge, eliminating manual drift.

Output: Two workflow YAML files in `.github/workflows/`
Research basis: Architecture Pattern 1 (two-workflow architecture), Pattern 2 (changed-plugin detection with matrix), Pattern 3 (auto-commit with loop prevention) from 02-RESEARCH.md
</objective>

<execution_context>
@${CLAUDE_PLUGIN_ROOT}/workflows/execute-plan.md
@${CLAUDE_PLUGIN_ROOT}/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-ci-cd-pipeline/02-RESEARCH.md
@.planning/phases/02-ci-cd-pipeline/02-01-SUMMARY.md

# Phase 1 scripts these workflows invoke:
@scripts/validate-plugin.sh
@scripts/run-fixture-tests.sh

# Phase 2 Plan 01 script this workflow invokes:
@scripts/generate-marketplace.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validate-plugins.yml PR validation workflow</name>
  <files>.github/workflows/validate-plugins.yml</files>
  <action>
    Create `.github/workflows/validate-plugins.yml` — the PR validation workflow.

    **Directory setup:** Create `.github/workflows/` directory (does not yet exist).

    **Workflow structure:**

    ```yaml
    name: Validate Plugins

    on:
      pull_request:
        branches: [main]
        paths:
          - 'plugins/**'
          - 'schemas/**'
          - 'scripts/**'
          - 'tests/**'
          - 'package.json'
          - 'package-lock.json'

    permissions:
      contents: read
      pull-requests: read
    ```

    **Three jobs:**

    1. **detect-changes** — Uses `dorny/paths-filter@v3` to identify which plugins changed.
       - Output `plugins` (JSON array of changed filter names) and `plugins_changed` (boolean)
       - Static filter entries for current 2 plugins:
         ```yaml
         filters: |
           multi-cli-harness:
             - 'plugins/multi-cli-harness/**'
           GRD:
             - 'plugins/GRD/**'
         ```
       - NOTE: Use actual directory names in filter names (not lowercase plugin.json names). The filter name IS the directory name under `plugins/`. This avoids the name-mismatch pitfall from research.
       - Add a YAML comment: `# Add new plugin filters here when onboarding — see Phase 4 for automation`

    2. **validate-plugins** — Matrix job that validates only changed plugins.
       - `needs: detect-changes`
       - `if: needs.detect-changes.outputs.plugins_changed == 'true'`
       - `strategy.fail-fast: false` (validate all changed plugins even if one fails)
       - `matrix.plugin: ${{ fromJSON(needs.detect-changes.outputs.plugins) }}`
       - Steps: checkout, setup-node (v4, node 20, cache npm), npm ci, run validate-plugin.sh
       - The validate step runs: `./scripts/validate-plugin.sh "plugins/${{ matrix.plugin }}"`
       - Since filter names match directory names exactly (multi-cli-harness, GRD), NO case mapping is needed. The `matrix.plugin` value IS the directory name.

    3. **test-fixtures** — Runs `run-fixture-tests.sh` to catch validation script regressions.
       - Runs in parallel with validate-plugins (no `needs:` dependency on detect-changes for this job, it always runs)
       - Steps: checkout, setup-node (v4, node 20, cache npm), npm ci, run `./scripts/run-fixture-tests.sh`

    Security considerations (from Research Pitfall 7):
    - Use `pull_request` trigger (NOT `pull_request_target`) — runs in fork context with read-only access
    - Set explicit `permissions: { contents: read, pull-requests: read }`
    - No secrets are referenced in any step
  </action>
  <verify>
    Validate YAML syntax:
    ```bash
    # Check YAML is valid (python-based check, or just parse with yq/python)
    python3 -c "import yaml; yaml.safe_load(open('.github/workflows/validate-plugins.yml'))" && echo "Valid YAML"
    # Check key strings are present:
    grep 'dorny/paths-filter@v3' .github/workflows/validate-plugins.yml
    grep 'validate-plugin.sh' .github/workflows/validate-plugins.yml
    grep 'run-fixture-tests.sh' .github/workflows/validate-plugins.yml
    grep 'pull_request:' .github/workflows/validate-plugins.yml
    grep "cache: 'npm'" .github/workflows/validate-plugins.yml
    grep 'npm ci' .github/workflows/validate-plugins.yml
    ```
    (Level 1: Sanity — YAML syntax valid, key actions referenced)

    Level 2 (Proxy) — requires actual PR to test: Open a test PR modifying plugins/GRD/ and verify the workflow triggers, runs validate-plugin.sh for GRD only, and the fixture test job passes.
  </verify>
  <done>
    validate-plugins.yml exists with: pull_request trigger on main, dorny/paths-filter@v3 for changed-plugin detection, matrix strategy for per-plugin validation, parallel fixture test job, Node.js 20 with npm cache, explicit read-only permissions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create publish-marketplace.yml auto-publish workflow</name>
  <files>.github/workflows/publish-marketplace.yml</files>
  <action>
    Create `.github/workflows/publish-marketplace.yml` — the push-to-main auto-publish workflow.

    **Workflow structure:**

    ```yaml
    name: Publish Marketplace

    on:
      push:
        branches: [main]
        paths:
          - 'plugins/**/plugin.json'

    permissions:
      contents: write

    concurrency:
      group: publish-marketplace
      cancel-in-progress: true
    ```

    **Single job: publish**

    Steps (in order):
    1. `actions/checkout@v4` — full checkout (default fetch-depth is fine for push events since we regenerate from all plugins, not diffing)
    2. `actions/setup-node@v4` — node-version: '20', cache: 'npm'
    3. `npm ci` — install dependencies (ajv-cli)
    4. **Run fixture tests as safety gate:** `./scripts/run-fixture-tests.sh` — if this fails, DO NOT proceed to generation (per Research Open Question 5 recommendation). Name this step "Run fixture tests (safety gate)".
    5. **Generate marketplace.json:** `./scripts/generate-marketplace.sh` — Name this step "Generate marketplace.json".
    6. **Validate generated output:** Run ajv validation as a separate step for clear error reporting:
       ```bash
       npx ajv validate \
         -s schemas/marketplace.schema.json \
         -d .claude-plugin/marketplace.json \
         --spec=draft7 \
         --all-errors \
         --errors=text
       ```
       Name this step "Validate generated marketplace.json".
    7. **Auto-commit:** Use `stefanzweifel/git-auto-commit-action@v7`:
       ```yaml
       - uses: stefanzweifel/git-auto-commit-action@v7
         with:
           commit_message: 'chore: regenerate marketplace.json [skip ci]'
           file_pattern: '.claude-plugin/marketplace.json'
       ```

    Key design decisions (from research):
    - `permissions: contents: write` — required for auto-commit (Research: Production Considerations, GITHUB_TOKEN permission)
    - `concurrency: { group: publish-marketplace, cancel-in-progress: true }` — handles rapid merges by canceling stale runs (Research Recommendation 5). The newest run always sees the latest state.
    - `GITHUB_TOKEN` is used implicitly (not PAT) — prevents infinite loop (Research Recommendation 1). The auto-commit push will NOT trigger another workflow run.
    - `[skip ci]` in commit message is defense-in-depth (Research Pitfall 1)
    - `file_pattern: '.claude-plugin/marketplace.json'` restricts commit to only the generated file (no accidental commits)
    - paths filter `plugins/**/plugin.json` only triggers when plugin.json files change, not for README edits etc.

    Avoid:
    - Using a PAT token (creates infinite loops)
    - Using `pull_request_target` (security risk for forks)
    - Omitting the concurrency group (race condition on rapid merges)
    - Omitting fixture tests (could publish with broken validation scripts)
  </action>
  <verify>
    Validate YAML syntax:
    ```bash
    python3 -c "import yaml; yaml.safe_load(open('.github/workflows/publish-marketplace.yml'))" && echo "Valid YAML"
    # Check key strings:
    grep 'stefanzweifel/git-auto-commit-action@v7' .github/workflows/publish-marketplace.yml
    grep 'generate-marketplace.sh' .github/workflows/publish-marketplace.yml
    grep 'run-fixture-tests.sh' .github/workflows/publish-marketplace.yml
    grep 'cancel-in-progress: true' .github/workflows/publish-marketplace.yml
    grep '\[skip ci\]' .github/workflows/publish-marketplace.yml
    grep 'contents: write' .github/workflows/publish-marketplace.yml
    grep "push:" .github/workflows/publish-marketplace.yml
    grep "cache: 'npm'" .github/workflows/publish-marketplace.yml
    ```
    (Level 1: Sanity — YAML syntax valid, key patterns present)

    Level 2 (Proxy) — requires actual merge to test: Merge a test PR that modifies a plugin.json and verify marketplace.json is regenerated and auto-committed with the expected commit message.
  </verify>
  <done>
    publish-marketplace.yml exists with: push trigger on main for plugin.json changes, fixture test safety gate, generate-marketplace.sh execution, ajv validation of output, auto-commit via git-auto-commit-action@v7 with GITHUB_TOKEN, concurrency group with cancel-in-progress, [skip ci] in commit message, Node.js 20 with npm cache.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- Both workflow YAML files are syntactically valid (parseable by Python yaml)
- validate-plugins.yml references dorny/paths-filter@v3, validate-plugin.sh, run-fixture-tests.sh
- publish-marketplace.yml references generate-marketplace.sh, git-auto-commit-action@v7, concurrency group
- Both workflows use Node.js 20 with npm cache
- Neither workflow uses pull_request_target (security)
- Neither workflow references repository secrets (no secrets needed)

Level 2 (Proxy — requires GitHub):
- Open test PR modifying plugins/GRD/ → validate-plugins workflow triggers, validates GRD only
- Open test PR with invalid plugin.json → validation fails with descriptive error
- Open test PR modifying only README → validation workflow skipped (paths filter)
- Merge valid plugin PR → publish workflow triggers, marketplace.json regenerated and auto-committed
- Auto-commit does NOT trigger another workflow run (GITHUB_TOKEN loop prevention)
- CI runs complete within 3 minutes (target from ROADMAP.md)

Level 3 (Deferred — Phase 5):
- Concurrent merge race condition test
- CI performance with 10+ plugins
- Dynamic plugin filter replacement (Phase 4)
</verification>

<success_criteria>
- Both workflow files exist in `.github/workflows/` with valid YAML syntax
- validate-plugins.yml detects changed plugins with dorny/paths-filter and validates them individually
- publish-marketplace.yml regenerates marketplace.json on merge with auto-commit and loop prevention
- All security best practices applied (pull_request trigger, read-only permissions for validation, no secrets in PR workflow)
- CI architecture matches Research two-workflow pattern with all recommended safeguards
</success_criteria>

<output>
After completion, create `.planning/phases/02-ci-cd-pipeline/02-02-SUMMARY.md`
</output>
