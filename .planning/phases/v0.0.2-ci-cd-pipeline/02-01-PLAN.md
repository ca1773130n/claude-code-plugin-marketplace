---
phase: 02-ci-cd-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/generate-marketplace.sh
  - CODEOWNERS
  - package-lock.json
autonomous: true
verification_level: sanity

must_haves:
  truths:
    - "generate-marketplace.sh discovers all plugin.json files dynamically (no hardcoded paths)"
    - "generate-marketplace.sh produces valid marketplace.json matching marketplace.schema.json"
    - "generate-marketplace.sh includes enrichment fields (commands, agents, hooks count) for each plugin"
    - "generate-marketplace.sh exits 1 with descriptive error if no plugins found"
    - "generate-marketplace.sh is portable (no macOS `realpath --relative-to` which does not exist on macOS)"
    - "CODEOWNERS assigns @ca1773130n as owner for all paths"
    - "package-lock.json is committed to git (required for npm ci in CI)"
  artifacts:
    - path: "scripts/generate-marketplace.sh"
      provides: "Marketplace JSON generation from all plugin.json files"
      min_lines: 40
    - path: "CODEOWNERS"
      provides: "GitHub code ownership rules"
      min_lines: 5
  key_links:
    - from: "scripts/generate-marketplace.sh"
      to: "plugins/*/.claude-plugin/plugin.json"
      via: "dynamic discovery with find"
      pattern: "find.*plugin.json"
    - from: "scripts/generate-marketplace.sh"
      to: ".claude-plugin/marketplace.json"
      via: "jq assembly and file write"
      pattern: "jq.*marketplace"
    - from: "scripts/generate-marketplace.sh"
      to: "schemas/marketplace.schema.json"
      via: "ajv validation of generated output"
      pattern: "ajv validate.*marketplace"
---

<objective>
Create the marketplace generation script and repository infrastructure files that the CI workflows will depend on.

Purpose: Establish the foundational scripts and config that both GitHub Actions workflows (Plan 02) will consume. The generation script is the core artifact — it dynamically discovers all plugins and assembles marketplace.json with enrichment metadata. CODEOWNERS and package-lock.json are prerequisites for a functional CI pipeline.

Output: Executable `generate-marketplace.sh`, `CODEOWNERS` file, committed `package-lock.json`
</objective>

<execution_context>
@${CLAUDE_PLUGIN_ROOT}/workflows/execute-plan.md
@${CLAUDE_PLUGIN_ROOT}/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-ci-cd-pipeline/02-RESEARCH.md

# Phase 1 artifacts this plan builds on:
@schemas/marketplace.schema.json
@.claude-plugin/marketplace.json
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create generate-marketplace.sh with dynamic plugin discovery and enrichment</name>
  <files>scripts/generate-marketplace.sh</files>
  <action>
    Create `scripts/generate-marketplace.sh` that builds `.claude-plugin/marketplace.json` from all `plugin.json` files.

    Requirements:
    - Use `#!/usr/bin/env bash` with `set -euo pipefail`
    - Compute REPO_ROOT portably: `SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"` then `REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"`
    - Discover plugins dynamically: `find "$REPO_ROOT/plugins" -path '*/.claude-plugin/plugin.json' -type f | sort`
    - Exit 1 with descriptive error if no plugin.json files found (see Research Pitfall 8)
    - For each plugin.json, extract: name, source (relative path), description, version, author, homepage, repository, license, keywords
    - Compute enrichment fields per plugin:
      - `commands`: count array length from plugin.json commands field (`jq '.commands | if type == "array" then length else 0 end'`)
      - `agents`: count `.md` files in the plugin's `agents/` directory (`find "$plugin_dir/agents" -name "*.md" -type f 2>/dev/null | wc -l`)
      - `hooks`: count hook entries — for object-type hooks, count keys in the hooks object (`jq '.hooks | if type == "object" then keys | length else 0 end'`)
    - Compute `source` as relative path WITHOUT using `realpath --relative-to` (not available on macOS). Instead use: `source="./$(python3 -c "import os.path; print(os.path.relpath('$plugin_dir', '$REPO_ROOT'))")"` OR more simply, since all plugins are under `plugins/`, extract the directory name relative to REPO_ROOT by stripping the REPO_ROOT prefix: `source="./${plugin_dir#$REPO_ROOT/}"`
    - Assemble final JSON using jq: `{ name: "claude-plugin-marketplace", owner: { name: "edward-seo" }, plugins: [...] }`
    - Write output to `$REPO_ROOT/.claude-plugin/marketplace.json`
    - Filter out null values from plugin entries (use `with_entries(select(.value != null))`)
    - After generation, self-validate using ajv: `npx ajv validate -s "$REPO_ROOT/schemas/marketplace.schema.json" -d "$REPO_ROOT/.claude-plugin/marketplace.json" --spec=draft7 --all-errors --errors=text`
    - Print summary: "Generated marketplace.json with N plugins" on success
    - Make the script executable: `chmod +x scripts/generate-marketplace.sh`
    - Add `--help` flag consistent with validate-plugin.sh style

    Portability concerns from research:
    - Do NOT use `realpath --relative-to` (macOS does not have GNU realpath)
    - Do NOT use bash 4+ features (associative arrays) — macOS ships bash 3.2
    - jq IS available on both macOS (brew) and GitHub runners (pre-installed)

    Test with current 2 plugins: GRD (34 commands, 18 agents, 0 hooks as object but 0 SessionStart counted differently) and multi-cli-harness (0 commands array, 0 agents dir count is what matters, 1 hooks key "SessionStart").

    Avoid:
    - Hardcoding plugin paths (use find for dynamic discovery)
    - String concatenation for JSON assembly (use jq --slurp or iterative jq)
    - Using `echo` to build JSON (breaks on special characters)
  </action>
  <verify>
    Run the script and verify output:
    ```bash
    ./scripts/generate-marketplace.sh
    # Check exit code is 0
    # Check .claude-plugin/marketplace.json exists
    # Validate against schema:
    npx ajv validate -s schemas/marketplace.schema.json -d .claude-plugin/marketplace.json --spec=draft7 --all-errors --errors=text
    # Check enrichment fields present:
    jq '.plugins[] | {name, commands, agents, hooks}' .claude-plugin/marketplace.json
    # Verify both plugins are present:
    jq '.plugins | length' .claude-plugin/marketplace.json  # should be 2
    ```
    (Level 1: Sanity)
  </verify>
  <done>
    generate-marketplace.sh exits 0, produces marketplace.json that validates against marketplace.schema.json, contains 2 plugin entries with enrichment fields (commands, agents, hooks counts), and uses dynamic plugin discovery (no hardcoded paths).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CODEOWNERS and commit package-lock.json</name>
  <files>CODEOWNERS, package-lock.json</files>
  <action>
    **CODEOWNERS file:**
    Create `CODEOWNERS` at repository root with the following ownership rules (per Research Example 4):

    ```
    # Default owners for the marketplace infrastructure
    * @ca1773130n

    # Plugin-specific ownership
    /plugins/multi-cli-harness/ @ca1773130n
    /plugins/GRD/ @ca1773130n

    # Marketplace infrastructure (schemas, scripts, workflows)
    /schemas/ @ca1773130n
    /scripts/ @ca1773130n
    /.github/ @ca1773130n
    ```

    Use `@ca1773130n` as the GitHub handle (this is the repo owner per PROJECT.md: "GitHub repo: ca1773130n/claude-plugin-marketplace").

    **package-lock.json:**
    The file exists on disk but is NOT tracked by git. It MUST be committed for `npm ci` to work in CI (see Research Pitfall 4). Simply stage and include it — no file modification needed.

    Verify `package-lock.json` exists on disk before staging. If it does not exist, run `npm install` to generate it.
  </action>
  <verify>
    ```bash
    # CODEOWNERS exists and has valid content
    cat CODEOWNERS
    # Verify @ca1773130n appears
    grep '@ca1773130n' CODEOWNERS

    # package-lock.json is tracked
    git ls-files package-lock.json  # should output "package-lock.json"
    # OR after staging: git diff --cached --name-only | grep package-lock.json
    ```
    (Level 1: Sanity)
  </verify>
  <done>
    CODEOWNERS file exists at repo root with correct ownership rules for all paths. package-lock.json is tracked by git, enabling `npm ci` in CI workflows.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- `./scripts/generate-marketplace.sh` exits 0 and produces valid JSON
- Generated `marketplace.json` validates against `schemas/marketplace.schema.json`
- Generated `marketplace.json` contains entries for both plugins (GRD and multi-cli-harness)
- Enrichment fields (commands, agents, hooks) are present and non-negative integers
- CODEOWNERS contains valid GitHub ownership syntax
- `package-lock.json` is git-tracked

Level 2 (Proxy): Deferred to Plan 02 — workflow integration tests
Level 3 (Deferred): Marketplace generation with 10+ plugins — deferred to Phase 5
</verification>

<success_criteria>
- `scripts/generate-marketplace.sh` dynamically discovers both plugins and generates valid marketplace.json with enrichment metadata
- `CODEOWNERS` assigns correct GitHub owner to all path patterns
- `package-lock.json` is committed to git for CI compatibility
- All files are executable (script) or properly formatted (CODEOWNERS)
</success_criteria>

<output>
After completion, create `.planning/phases/02-ci-cd-pipeline/02-01-SUMMARY.md`
</output>
