---
phase: 01-schema-validation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - scripts/validate-plugin.sh
autonomous: true
verification_level: sanity

must_haves:
  truths:
    - "validate-plugin.sh exits 0 when given plugins/GRD as argument"
    - "validate-plugin.sh exits 0 when given plugins/multi-cli-harness as argument"
    - "validate-plugin.sh performs Layer 1 schema validation via ajv-cli and Layer 2 structural validation via bash+jq"
    - "validate-plugin.sh reports all errors (error accumulation), not just the first"
    - "validate-plugin.sh checks file existence for all paths declared in commands, agents, skills arrays"
    - "validate-plugin.sh checks hook script existence and resolves ${CLAUDE_PLUGIN_ROOT} paths"
    - "validate-plugin.sh warns (not errors) on agent naming convention violations"
  artifacts:
    - path: "scripts/validate-plugin.sh"
      provides: "Two-layer plugin validation (schema + structural)"
      min_lines: 80
  key_links:
    - from: "scripts/validate-plugin.sh"
      to: "schemas/plugin.schema.json"
      via: "ajv validate -s schemas/plugin.schema.json"
      pattern: "ajv.*validate.*plugin\\.schema"
    - from: "scripts/validate-plugin.sh"
      to: "schemas/marketplace.schema.json"
      via: "optional marketplace validation when --marketplace flag used"
---

<objective>
Create the two-layer validation script that combines ajv-cli schema validation with bash+jq structural validation.

Purpose: This script is the single entry point for validating any plugin. It will be used by CI (Phase 2), by contributors locally (Phase 4), and by integration tests (Phase 5). It must handle both existing plugins cleanly and produce descriptive error messages for invalid plugins.

Output: An executable bash script at scripts/validate-plugin.sh.
</objective>

<context>
@.planning/ROADMAP.md
@.planning/phases/01-schema-validation/01-RESEARCH.md
@.planning/phases/01-schema-validation/01-01-SUMMARY.md
@schemas/plugin.schema.json
@schemas/marketplace.schema.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validate-plugin.sh with two-layer validation</name>
  <files>scripts/validate-plugin.sh</files>
  <action>
    Create `scripts/` directory and write `scripts/validate-plugin.sh`.

    The script must:

    **Interface:**
    - Accept a single argument: path to the plugin directory (e.g., `plugins/GRD`)
    - Optional `--marketplace` flag to also validate marketplace.json
    - `--help` flag for usage information
    - Exit 0 on success, 1 on validation failure, 2 on usage/dependency error

    **Dependency checks (at script start):**
    - Check `command -v npx` exists. If not, print: "Error: npx not found. Install Node.js to use this validator." and exit 2.
    - Check `command -v jq` exists. If not, print: "Error: jq not found. Install jq (brew install jq) to use this validator." and exit 2.
    - Check that `schemas/plugin.schema.json` exists relative to the script's location. Use `SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"` and `REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"` to find schemas.

    **Layer 1: Schema Validation (ajv-cli)**
    - Run: `npx ajv validate -s "$REPO_ROOT/schemas/plugin.schema.json" -d "$PLUGIN_DIR/.claude-plugin/plugin.json" --spec=draft7 --all-errors --errors=text`
    - Handle exit codes: 0=pass, 1=schema errors (collect and continue to report), 2=schema itself broken (fatal error, exit 2)
    - If schema validation fails, still report errors but skip Layer 2 (structural checks depend on valid JSON structure)

    **Layer 2: Structural Validation (bash+jq)**
    Use error accumulation pattern (array of error strings, report all at end).

    Checks to implement:
    1. **File existence for commands:** If `.commands` exists and is an array, iterate each path. Resolve `./path` against plugin directory. Check file or directory exists. If `.commands` is a string, check the single path.
    2. **File existence for agents:** Same pattern as commands if `.agents` is present.
    3. **File existence for skills:** Same pattern as commands if `.skills` is present.
    4. **Hook script existence:** If `.hooks` is an object (not string/array), extract all `.command` values recursively using `jq -r '.. | .command? // empty'`. For commands containing `${CLAUDE_PLUGIN_ROOT}`, extract the relative path portion after `${CLAUDE_PLUGIN_ROOT}/`, resolve against plugin directory, check file exists.
    5. **Hook script permissions:** For `.sh` scripts found in hooks, check they are executable (`-x`). If not, add as error.
    6. **Agent naming convention (WARNING only):** If `agents/` directory exists in plugin, check each `.md` file follows `<plugin-name>-*.md` naming. Print warnings to stderr, do NOT add to errors array.
    7. **Plugin directory structure:** Check `.claude-plugin/plugin.json` exists (should already exist if we got this far, but defensive check).

    **Output format:**
    - On success: `"PASS: <plugin-name> validated successfully (schema + structural)"`
    - On failure: `"FAIL: <plugin-name> validation failed (<N> errors):"` followed by each error indented with `"  - "`
    - Warnings (agent naming) go to stderr with `"WARN: "` prefix

    **Bash compatibility (from research Pitfall 4):**
    - Target bash 3.2+ for macOS compatibility
    - Use indexed arrays only (no associative arrays)
    - Use `tr '[:upper:]' '[:lower:]'` instead of `${var,,}`
    - Use `[[ ]]` for conditionals
    - Shebang: `#!/usr/bin/env bash`
    - Include `set -euo pipefail` but handle ajv exit codes explicitly with `|| true` to prevent premature exit

    **String/array union handling (from research Common Implementation Traps):**
    For each field that can be string or array (commands, agents, skills), check the JSON type first:
    ```bash
    field_type=$(jq -r '.commands | type' "$MANIFEST" 2>/dev/null)
    if [[ "$field_type" == "array" ]]; then
      # iterate .commands[]
    elif [[ "$field_type" == "string" ]]; then
      # handle single string
    fi
    ```

    Make the script executable: `chmod +x scripts/validate-plugin.sh`
  </action>
  <verify>
    1. Script is executable: `test -x scripts/validate-plugin.sh`
    2. Script shows help: `scripts/validate-plugin.sh --help` exits 0 and shows usage
    3. Script validates GRD: `scripts/validate-plugin.sh plugins/GRD` exits 0
    4. Script validates multi-cli-harness: `scripts/validate-plugin.sh plugins/multi-cli-harness` exits 0
    5. Both runs print "PASS" in output
    (Level 1: Sanity)
  </verify>
  <done>
    scripts/validate-plugin.sh exists, is executable, accepts a plugin directory argument, runs Layer 1 (ajv schema) and Layer 2 (structural) validation, and exits 0 for both GRD and multi-cli-harness plugins with "PASS" output.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify error reporting with intentionally broken input</name>
  <files>scripts/validate-plugin.sh</files>
  <action>
    Run quick smoke tests to verify the script catches errors correctly. Do NOT create persistent fixtures (that is Plan 03's job). Instead, use temporary directories.

    1. **Test missing plugin.json:**
       ```bash
       tmpdir=$(mktemp -d)
       mkdir -p "$tmpdir/.claude-plugin"
       echo '{}' > "$tmpdir/.claude-plugin/plugin.json"
       scripts/validate-plugin.sh "$tmpdir"
       # Should exit 1 -- missing required "name" field
       rm -rf "$tmpdir"
       ```

    2. **Test missing referenced file:**
       ```bash
       tmpdir=$(mktemp -d)
       mkdir -p "$tmpdir/.claude-plugin"
       echo '{"name":"test","commands":["./nonexistent.md"]}' > "$tmpdir/.claude-plugin/plugin.json"
       scripts/validate-plugin.sh "$tmpdir"
       # Should exit 1 -- file not found
       rm -rf "$tmpdir"
       ```

    3. **Test error accumulation:** Create a plugin with multiple errors (bad version + missing file). Verify all errors are reported, not just the first.

    4. If any test reveals a bug in the script, fix the script.

    5. Run the script once more against both real plugins to confirm fixes did not break anything:
       ```bash
       scripts/validate-plugin.sh plugins/GRD && echo "GRD still passes"
       scripts/validate-plugin.sh plugins/multi-cli-harness && echo "multi-cli-harness still passes"
       ```
  </action>
  <verify>
    - Script exits 1 for a plugin.json with `{}` (no name field)
    - Script exits 1 for a plugin with commands pointing to nonexistent files
    - Script reports multiple errors when multiple problems exist
    - Script still exits 0 for both real plugins after any fixes
    (Level 1: Sanity)
  </verify>
  <done>
    validate-plugin.sh correctly catches schema violations (exit 1), structural violations (exit 1), accumulates multiple errors, and still passes both real plugins. Error messages are descriptive and point to the specific problem.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- `scripts/validate-plugin.sh plugins/GRD` exits 0
- `scripts/validate-plugin.sh plugins/multi-cli-harness` exits 0
- `scripts/validate-plugin.sh --help` exits 0 with usage text
- Script exits 1 for plugin missing `name` field
- Script exits 1 for plugin referencing nonexistent files
- Script exits 2 when jq is not available (can test by temporarily aliasing)

Level 2 (Proxy):
- Error messages contain the specific field name or file path that caused the failure
- Multiple errors in the same plugin are all reported (not just the first)
- Agent naming warnings appear on stderr with WARN prefix
</verification>

<success_criteria>
- scripts/validate-plugin.sh exists and is executable
- Exits 0 for both real plugins (GRD and multi-cli-harness)
- Exits 1 for schema violations with descriptive errors
- Exits 1 for structural violations (missing files) with descriptive errors
- Exits 2 for dependency/usage errors with helpful messages
- Uses error accumulation pattern (reports all errors, not just first)
- Compatible with macOS bash 3.2+
</success_criteria>

<output>
After completion, create `.planning/phases/01-schema-validation/01-02-SUMMARY.md`
</output>
