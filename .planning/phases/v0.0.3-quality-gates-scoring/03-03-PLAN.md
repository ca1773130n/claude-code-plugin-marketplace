---
phase: 03-quality-gates-scoring
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - .github/workflows/validate-plugins.yml
autonomous: true
verification_level: proxy

must_haves:
  truths:
    - "validate-plugins.yml includes a scoring step that runs score-plugin.sh for each changed plugin"
    - "validate-plugins.yml posts a PR comment with quality score using thollander/actions-comment-pull-request@v3"
    - "PR comment uses comment-tag for upsert behavior (one comment per plugin, updated on push)"
    - "Workflow permissions escalated to pull-requests: write for PR commenting"
    - "Scoring step failure does not block the validation check (scoring is informational)"
    - "Human-readable score output appears in CI job log"
  artifacts:
    - path: ".github/workflows/validate-plugins.yml"
      provides: "CI workflow with scoring integration and PR comments"
      contains: "score-plugin"
  key_links:
    - from: ".github/workflows/validate-plugins.yml"
      to: "scripts/score-plugin.sh"
      via: "step execution with --json flag"
      pattern: "score-plugin\\.sh"
    - from: ".github/workflows/validate-plugins.yml"
      to: "thollander/actions-comment-pull-request"
      via: "GitHub Action for PR comment posting"
      pattern: "thollander/actions-comment-pull-request"
---

<objective>
Integrate quality scoring into the validate-plugins.yml CI workflow. Add a scoring step after validation that runs score-plugin.sh and posts results as a PR comment using thollander/actions-comment-pull-request@v3.

Purpose: Make quality scores visible in every PR that modifies plugins, giving authors immediate feedback on quality impact.
Output: Updated validate-plugins.yml with scoring step and PR comment.
Research basis: PR comment via thollander/actions-comment-pull-request@v3 with comment-tag upsert (Research Recommendation 3). Permission escalation from read to write per Research Pitfall 5.
</objective>

<execution_context>
@${CLAUDE_PLUGIN_ROOT}/workflows/execute-plan.md
@${CLAUDE_PLUGIN_ROOT}/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-quality-gates-scoring/03-RESEARCH.md
@.planning/phases/03-quality-gates-scoring/03-01-SUMMARY.md
@.github/workflows/validate-plugins.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add scoring step and PR comment to validate-plugins.yml</name>
  <files>.github/workflows/validate-plugins.yml</files>
  <action>
    Modify .github/workflows/validate-plugins.yml to add quality scoring after validation.

    **1. Update permissions block:**
    Change `pull-requests: read` to `pull-requests: write` to allow PR commenting.
    Per Research Pitfall 5, this is a necessary permission escalation.

    **2. Add scoring steps to the validate-plugins job:**

    After the existing "Validate ${{ matrix.plugin }}" step, add two new steps:

    **Step: Score plugin**
    ```yaml
    - name: Score ${{ matrix.plugin }}
      id: score
      if: always()
      env:
        PLUGIN_NAME: ${{ matrix.plugin }}
      run: |
        # Run human-readable output for CI log
        ./scripts/score-plugin.sh "plugins/$PLUGIN_NAME" || true

        # Capture JSON output for PR comment
        SCORE_JSON=$(./scripts/score-plugin.sh "plugins/$PLUGIN_NAME" --json 2>/dev/null || echo '{"plugin":"unknown","total":0}')
        TOTAL=$(echo "$SCORE_JSON" | jq -r '.total // 0')
        echo "total=$TOTAL" >> "$GITHUB_OUTPUT"

        # Build markdown table for PR comment
        # Extract each category score and deductions
        COMMENT="## Quality Score: $PLUGIN_NAME -- ${TOTAL}/100\n\n"
        COMMENT+="| Category | Score | Details |\n"
        COMMENT+="|----------|-------|---------|\n"

        for cat in manifest_completeness documentation structure_integrity naming_conventions version_hygiene; do
          SCORE=$(echo "$SCORE_JSON" | jq -r ".categories.$cat.score // 0")
          MAX=$(echo "$SCORE_JSON" | jq -r ".categories.$cat.max // 20")
          DEDS=$(echo "$SCORE_JSON" | jq -r ".categories.$cat.deductions | if length > 0 then join(\", \") else \"--\" end")
          PRETTY_NAME=$(echo "$cat" | sed 's/_/ /g' | sed 's/\b\(.\)/\u\1/g' 2>/dev/null || echo "$cat")
          COMMENT+="| $PRETTY_NAME | $SCORE/$MAX | $DEDS |\n"
        done

        echo "comment<<SCORE_EOF" >> "$GITHUB_OUTPUT"
        echo -e "$COMMENT" >> "$GITHUB_OUTPUT"
        echo "SCORE_EOF" >> "$GITHUB_OUTPUT"
    ```

    IMPORTANT: The scoring step uses `if: always()` so it runs even if validation fails.
    The `|| true` on the human-readable run ensures the step doesn't fail if scoring has issues.
    Scoring is INFORMATIONAL, not a gate.

    **Step: Comment PR with quality score**
    ```yaml
    - name: Comment PR with quality score
      if: always() && github.event_name == 'pull_request'
      uses: thollander/actions-comment-pull-request@v3
      with:
        message: ${{ steps.score.outputs.comment }}
        comment-tag: quality-${{ matrix.plugin }}
    ```

    The `comment-tag` ensures one comment per plugin per PR (upsert behavior).
    Per Research Anti-Pattern: Never create multiple comments -- always use comment-tag.

    **3. Handle the sed portability issue:**
    The `sed 's/\b\(.\)/\u\1/g'` for title-casing category names may not work on all sed
    versions. Use an alternative approach:
    - Use a case statement or associative mapping in bash instead:
    ```bash
    case "$cat" in
      manifest_completeness) PRETTY_NAME="Manifest Completeness" ;;
      documentation) PRETTY_NAME="Documentation" ;;
      structure_integrity) PRETTY_NAME="Structure Integrity" ;;
      naming_conventions) PRETTY_NAME="Naming Conventions" ;;
      version_hygiene) PRETTY_NAME="Version Hygiene" ;;
    esac
    ```
    This is more portable and explicit than sed title-casing.

    **4. Do NOT modify the existing validation step or test-fixtures job.**
    Scoring is additive, not a replacement for validation.

    Per Research Production Consideration: Use `jq -c` for compact JSON in step outputs
    to avoid newline issues. Use `jq .` only for final display.
  </action>
  <verify>
    # Workflow YAML is valid
    python3 -c "import yaml; yaml.safe_load(open('.github/workflows/validate-plugins.yml'))"

    # Verify permissions block has write
    grep -q "pull-requests: write" .github/workflows/validate-plugins.yml

    # Verify score-plugin.sh is referenced
    grep -q "score-plugin.sh" .github/workflows/validate-plugins.yml

    # Verify thollander action is used
    grep -q "thollander/actions-comment-pull-request" .github/workflows/validate-plugins.yml

    # Verify comment-tag is used for upsert
    grep -q "comment-tag:" .github/workflows/validate-plugins.yml

    # Verify existing validation step is preserved
    grep -q "validate-plugin.sh" .github/workflows/validate-plugins.yml

    # Verify test-fixtures job is unchanged
    grep -q "run-fixture-tests.sh" .github/workflows/validate-plugins.yml

    (Level 2: Proxy -- actual PR comment posting requires a real GitHub Actions run)
  </verify>
  <done>
    validate-plugins.yml updated with:
    - pull-requests: write permission
    - Scoring step that runs score-plugin.sh (human-readable for log, JSON for PR comment)
    - PR comment step using thollander/actions-comment-pull-request@v3 with comment-tag upsert
    - Scoring is informational (if: always(), does not block validation)
    - Existing validation and test-fixtures jobs preserved unchanged
    - YAML is syntactically valid
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify end-to-end workflow structure and document deferred CI validations</name>
  <files>.github/workflows/validate-plugins.yml</files>
  <action>
    Perform a thorough review of the complete validate-plugins.yml to ensure:

    1. **Job dependency chain is correct:**
       - detect-changes (no deps)
       - validate-plugins (needs detect-changes)
       - test-fixtures (no deps)
       All three jobs should be present with correct dependency structure.

    2. **Scoring steps are in the right position:**
       - AFTER the validate step (so validation runs first)
       - BEFORE any job-level reporting

    3. **Permissions are minimal:**
       - contents: read (unchanged)
       - pull-requests: write (escalated for PR comment)
       Verify no other permissions were accidentally added.

    4. **No regressions:**
       - npm ci still runs
       - Node.js 20 still configured
       - npm cache still enabled
       - matrix strategy still has fail-fast: false
       - PLUGIN_NAME env var pattern preserved

    5. **Workflow structure validation:**
       - Run `python3 -c "import yaml; yaml.safe_load(open('.github/workflows/validate-plugins.yml'))"` to verify YAML syntax
       - Count total steps in validate-plugins job (should be: checkout, setup-node, npm ci, validate, score, comment = 6)
       - Verify `if: always()` conditions are correctly placed

    6. **Note deferred validations** (cannot test without actual GitHub Actions):
       - PR comment actually appears on a PR
       - comment-tag upsert works (second push updates, not duplicates)
       - Scoring step output formatting renders correctly as markdown
       - Permission escalation works without additional token configuration
       - CI time remains < 3 minutes with scoring added

    If any structural issues are found, fix them in this task.
  </action>
  <verify>
    # YAML valid
    python3 -c "import yaml; yaml.safe_load(open('.github/workflows/validate-plugins.yml'))"

    # All three jobs present
    python3 -c "
    import yaml
    with open('.github/workflows/validate-plugins.yml') as f:
      wf = yaml.safe_load(f)
    jobs = list(wf['jobs'].keys())
    assert 'detect-changes' in jobs, 'Missing detect-changes job'
    assert 'validate-plugins' in jobs, 'Missing validate-plugins job'
    assert 'test-fixtures' in jobs, 'Missing test-fixtures job'
    print(f'Jobs found: {jobs}')
    print('All expected jobs present')
    "

    # Permissions correct
    grep -q "contents: read" .github/workflows/validate-plugins.yml
    grep -q "pull-requests: write" .github/workflows/validate-plugins.yml

    (Level 2: Proxy)
  </verify>
  <done>
    validate-plugins.yml is structurally complete and correct:
    - Three jobs (detect-changes, validate-plugins, test-fixtures) with correct dependencies
    - Scoring and PR comment steps properly positioned after validation
    - Permissions minimal (contents: read, pull-requests: write)
    - No regressions to existing functionality
    - YAML syntax valid
    - Deferred CI validations documented for post-push verification
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- validate-plugins.yml is valid YAML
- All three jobs present (detect-changes, validate-plugins, test-fixtures)
- score-plugin.sh referenced in workflow
- thollander/actions-comment-pull-request@v3 used with comment-tag

Level 2 (Proxy):
- Workflow structure matches expected job count and step count
- Permissions are exactly contents: read + pull-requests: write
- No regressions to existing validation or test-fixtures functionality
- Scoring step uses if: always() (informational, not blocking)

Level 3 (Deferred):
- PR comment actually appears in GitHub PR (requires push to GitHub)
- comment-tag upsert works correctly (requires multiple pushes to same PR)
- CI time < 3 minutes with scoring added (requires actual CI run)
- Markdown rendering of score table is correct (requires PR comment visual check)
</verification>

<success_criteria>
- validate-plugins.yml includes scoring step running score-plugin.sh
- PR comment posted via thollander/actions-comment-pull-request@v3 with comment-tag upsert
- Permissions escalated to pull-requests: write
- Scoring is informational (if: always(), does not block merge)
- Existing validation and test-fixtures jobs unchanged
- YAML syntax valid, all jobs present with correct dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/03-quality-gates-scoring/03-03-SUMMARY.md`
</output>
