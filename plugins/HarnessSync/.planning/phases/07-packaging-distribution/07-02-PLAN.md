---
phase: 07-packaging-distribution
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [install.sh, shell-integration.sh]
autonomous: true
verification_level: proxy

must_haves:
  truths:
    - "install.sh creates target directories (~/.codex/, ~/.gemini/, ~/.config/opencode/) and detects shell (bash/zsh) for shell integration"
    - "install.sh supports --dry-run flag that prints what would be done without making changes"
    - "install.sh detects platform (macOS/Linux/Windows/WSL) and reports symlink capability"
    - "install.sh uses HarnessSync branding (not cc2all legacy) and references correct paths"
    - "install.sh is idempotent (safe to run multiple times without duplicate entries)"
    - "shell-integration.sh uses HarnessSync branding and references plugin Python entry points (not cc2all-sync.py)"
    - "install.sh is executable (chmod +x)"
  artifacts:
    - path: "install.sh"
      provides: "Cross-platform installation script with --dry-run"
      contains: "HarnessSync"
    - path: "shell-integration.sh"
      provides: "Shell wrappers for codex/gemini/opencode with auto-sync"
      contains: "HarnessSync"
  key_links:
    - from: "install.sh"
      to: "shell-integration.sh"
      via: "source line in shell RC"
      pattern: "shell-integration.sh"
    - from: "shell-integration.sh"
      to: "src/orchestrator.py"
      via: "Python sync invocation"
      pattern: "python3"
---

<objective>
Overhaul install.sh and shell-integration.sh from legacy cc2all branding to HarnessSync, add --dry-run support, platform detection, and proper cross-platform directory creation.

Purpose: install.sh is the primary entry point for non-marketplace users (GitHub clone installation). It must create target directories, detect shell type, configure shell integration, and work across macOS/Linux/Windows. The current version uses legacy cc2all naming and paths that no longer exist.

Output: Rewritten install.sh with HarnessSync branding, --dry-run flag, platform detection. Updated shell-integration.sh with HarnessSync references.
</objective>

<execution_context>
@${CLAUDE_PLUGIN_ROOT}/references/execute-plan.md
@${CLAUDE_PLUGIN_ROOT}/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-packaging-distribution/07-RESEARCH.md
@install.sh
@shell-integration.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite install.sh with HarnessSync branding and --dry-run</name>
  <files>install.sh</files>
  <action>
    Rewrite install.sh completely. The current version is legacy cc2all code that references cc2all-sync.py (which no longer exists) and creates ~/.cc2all/ directory. Replace with HarnessSync-branded installer.

    The rewritten install.sh MUST:

    1. **Header and branding:** Replace all cc2all references with HarnessSync. Update the ASCII box header.

    2. **--dry-run flag:** Parse `--dry-run` argument. When set, prefix all mutating operations with `[DRY RUN]` and skip actual execution (mkdir, file writes, shell RC modification). This is critical for CI testing.

    3. **Platform detection (step 1/4):** Detect OS using `$OSTYPE` and `uname -s`:
       - `darwin*` → macOS (native symlinks)
       - `linux-gnu*` → Linux (native symlinks)
       - `msys` or `win32` → Windows native (junction fallback)
       - Check `command -v wslpath` → WSL2 (native symlinks within Linux FS)
       - Unknown → warn and continue

    4. **Target directory creation (step 2/4):** Create directories for all three targets:
       - `${CODEX_HOME:-$HOME/.codex}/skills`
       - `$HOME/.gemini`
       - `$HOME/.config/opencode/skills`
       - `$HOME/.config/opencode/agents`
       - `$HOME/.config/opencode/commands`
       Use `mkdir -p` (idempotent). In dry-run mode, print what would be created.

    5. **Shell detection and integration (step 3/4):** Detect shell via `$ZSH_VERSION`/`$BASH_VERSION` and `$SHELL`:
       - zsh → `$HOME/.zshrc`
       - bash → `$HOME/.bashrc`
       - unknown → warn with manual instruction
       Add `source` line for shell-integration.sh ONLY if not already present (check with `grep -q "HarnessSync" "$SHELL_RC"`). The source line should reference `$PLUGIN_ROOT/shell-integration.sh` where `PLUGIN_ROOT` is computed from `BASH_SOURCE[0]`.
       In dry-run mode, print what would be added.

    6. **Platform info (step 4/4):** Print platform-specific notes:
       - macOS/Linux: "Native symlinks supported"
       - Windows native: "Junction points for directories, copy for files (no admin required)"
       - WSL: "Native symlinks supported in Linux filesystem"

    7. **Python version check:** Optionally check `python3 --version` and warn if < 3.10.

    8. **Completion message:** Print success summary with next steps (restart shell, run `/sync-status`).

    What to REMOVE from current install.sh:
    - All cc2all references ($CC2ALL_HOME, cc2all-sync.py)
    - Step that copies files to ~/.cc2all/
    - Claude Code hook setup (step 4) — hooks are now in hooks/hooks.json, plugin system handles registration
    - Initial sync step (step 6) — plugin handles this
    - CLI check step (step 2) — nice-to-have but not critical; if kept, update tool names

    What to keep/adapt:
    - ANSI color codes (BOLD, GREEN, BLUE, YELLOW, RED, NC)
    - Shell detection logic (zsh/bash)
    - Target directory creation (mkdir -p)
    - Idempotent grep check before appending to shell RC

    Make install.sh executable: ensure shebang is `#!/usr/bin/env bash` and file has `set -euo pipefail`.
  </action>
  <verify>
    # Verify install.sh is executable
    test -x install.sh && echo "Executable: OK" || echo "FAIL: not executable" (Level 1: Sanity)

    # Verify no cc2all references remain
    ! grep -q "cc2all" install.sh && echo "No cc2all refs: OK" || echo "FAIL: cc2all references found" (Level 1: Sanity)

    # Verify --dry-run support exists
    grep -q "dry.run\|DRY_RUN\|dry_run" install.sh && echo "Dry-run support: OK" || echo "FAIL: no dry-run support" (Level 1: Sanity)

    # Verify HarnessSync branding
    grep -q "HarnessSync" install.sh && echo "HarnessSync branding: OK" || echo "FAIL: no HarnessSync branding" (Level 1: Sanity)

    # Test dry-run mode completes without errors
    bash install.sh --dry-run && echo "Dry-run execution: OK" (Level 2: Proxy)
  </verify>
  <done>
    install.sh rewritten with HarnessSync branding, 4-step installation flow (platform detect, dir creation, shell integration, platform info), --dry-run flag, platform detection (macOS/Linux/Windows/WSL), idempotent shell RC modification, no cc2all references. Dry-run completes without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update shell-integration.sh with HarnessSync branding</name>
  <files>shell-integration.sh</files>
  <action>
    Rewrite shell-integration.sh to replace all cc2all references with HarnessSync. The shell-integration.sh is sourced from the user's shell RC file and provides:
    1. Shell function wrappers around codex, gemini, opencode that auto-sync before launch
    2. A cooldown mechanism to avoid frequent syncs
    3. A manual `harnesssync` command for status and manual sync

    Changes required:

    1. **Rename all cc2all variables:**
       - `CC2ALL_HOME` → `HARNESSSYNC_HOME` (default: directory containing shell-integration.sh, NOT a fixed path)
       - `CC2ALL_SYNC` → reference the Python orchestrator: `python3 "$HARNESSSYNC_HOME/src/orchestrator.py"` or use the `/sync` command mechanism. Since shell-integration wraps CLI launches, it should invoke the sync directly via Python.
       - `CC2ALL_COOLDOWN` → `HARNESSSYNC_COOLDOWN` (keep default 300s)
       - `CC2ALL_STAMP` → `HARNESSSYNC_STAMP` (use `$HOME/.harnesssync/.last-sync`)
       - `CC2ALL_VERBOSE` → `HARNESSSYNC_VERBOSE`
       - `CC2ALL_QUIET` → `HARNESSSYNC_QUIET`

    2. **Update function names:**
       - `_cc2all_should_sync` → `_harnesssync_should_sync`
       - `_cc2all_auto_sync` → `_harnesssync_auto_sync`
       - `_cc2all_original_codex` etc. → `_harnesssync_original_codex` etc.
       - `_cc2all_check_target` → `_harnesssync_check_target`
       - `_cc2all_register_hook` → remove entirely (hooks handled by plugin system)
       - `cc2all()` → `harnesssync()`

    3. **Update sync invocation:** The auto-sync function should call:
       ```bash
       python3 "$HARNESSSYNC_HOME/src/commands/sync_cmd.py" --scope "$scope"
       ```
       Or if the src/commands/sync_cmd.py doesn't exist as a standalone script, use a simpler approach:
       ```bash
       python3 -c "
       import sys; sys.path.insert(0, '$HARNESSSYNC_HOME')
       from src.orchestrator import SyncOrchestrator
       o = SyncOrchestrator()
       o.sync_all()
       " 2>&1
       ```
       Check what entry point exists. The simplest reliable approach is to add a small shim script `src/cli.py` that invokes the orchestrator, OR use the existing orchestrator directly.

       Actually, the safest approach for shell-integration is to keep it simple: call `python3 "$HARNESSSYNC_HOME/src/orchestrator.py"` with appropriate args. Check if orchestrator.py has a `__main__` block. If not, use a one-liner Python command that imports and runs sync.

    4. **Update header comments:** Replace cc2all references with HarnessSync branding.

    5. **Update manual command:** Rename `cc2all()` function to `harnesssync()` with subcommands: sync, status, force, help.

    6. **Remove hook registration:** The `_cc2all_register_hook` function and its call are no longer needed (plugin system manages hooks).

    7. **Keep the wrapper pattern:** The codex/gemini/opencode wrapper functions are the core value of shell-integration. Keep the pattern of saving original command path and wrapping with auto-sync.
  </action>
  <verify>
    # Verify no cc2all references remain
    ! grep -q "cc2all" shell-integration.sh && echo "No cc2all refs: OK" || echo "FAIL: cc2all references found" (Level 1: Sanity)

    # Verify HarnessSync branding
    grep -q "HarnessSync\|HARNESSSYNC\|harnesssync" shell-integration.sh && echo "HarnessSync branding: OK" (Level 1: Sanity)

    # Verify wrapper functions exist
    grep -q "codex()" shell-integration.sh && grep -q "gemini()" shell-integration.sh && grep -q "opencode()" shell-integration.sh && echo "Wrappers present: OK" (Level 1: Sanity)

    # Verify shell-integration.sh sources without error (syntax check)
    bash -n shell-integration.sh && echo "Syntax valid: OK" (Level 2: Proxy)
  </verify>
  <done>
    shell-integration.sh rewritten with HarnessSync branding, all cc2all references replaced, wrapper functions for codex/gemini/opencode preserved, manual `harnesssync` command with sync/status/force/help subcommands, hook registration removed (handled by plugin system), syntax validates without errors.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
1. install.sh is executable and has correct shebang
2. No cc2all references in either install.sh or shell-integration.sh
3. HarnessSync branding present in both files
4. --dry-run flag support in install.sh
5. shell-integration.sh has valid bash syntax (bash -n)

Level 2 (Proxy):
1. `bash install.sh --dry-run` completes without errors on development machine
2. shell-integration.sh wrapper functions (codex, gemini, opencode) are defined
3. install.sh creates expected directories when run (not dry-run)
4. Shell RC modification is idempotent (run install.sh twice, only one entry)

Level 3 (Deferred):
1. install.sh works on Linux (GitHub Actions ubuntu-latest)
2. install.sh works on Windows WSL2
3. install.sh works on Windows native with Git Bash
4. Shell wrappers actually trigger sync before CLI launch
</verification>

<success_criteria>
- install.sh rewritten with HarnessSync branding, --dry-run support, platform detection
- shell-integration.sh updated with HarnessSync references, no cc2all legacy
- Both files have valid bash syntax
- install.sh dry-run completes without errors
- No cc2all references in either file
- Shell RC modification is idempotent
</success_criteria>

<output>
After completion, create `.planning/phases/07-packaging-distribution/07-02-SUMMARY.md`
</output>
