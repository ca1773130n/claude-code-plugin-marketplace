---
phase: 03-gemini-opencode-adapters
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/adapters/gemini.py
  - src/utils/paths.py
autonomous: true
verification_level: proxy

eval_metrics:
  primary: "truths_verified: 8/8"
  baseline: "0/8 before implementation"
  target: "8/8 with 0 test failures"

must_haves:
  truths:
    - "GeminiAdapter registered via @AdapterRegistry.register('gemini') and all 6 sync methods implemented"
    - "sync_rules writes rules to GEMINI.md with HarnessSync markers preserving user content outside markers"
    - "sync_skills strips YAML frontmatter from each skill and inlines content into GEMINI.md with section headers (no symlinks)"
    - "sync_agents strips frontmatter and inlines agent role content into GEMINI.md agent section"
    - "sync_commands summarizes commands as brief descriptions in GEMINI.md command section"
    - "sync_mcp translates MCP servers to settings.json mcpServers format (command+args for stdio, url for SSE/HTTP)"
    - "sync_settings maps permissions conservatively (deny list -> blockedTools, allow list -> allowedTools, never auto-enable yolo mode)"
    - "write_json_atomic utility added to paths.py using tempfile + os.replace pattern"
  artifacts:
    - path: "src/adapters/gemini.py"
      provides: "GeminiAdapter implementation with all 6 sync methods"
      min_lines: 250
    - path: "src/utils/paths.py"
      provides: "write_json_atomic utility for safe JSON config writes"
      exports: ["write_json_atomic"]
  key_links:
    - from: "src/adapters/gemini.py"
      to: "src/adapters/base.py"
      via: "class inheritance"
      pattern: "class GeminiAdapter\\(AdapterBase\\)"
    - from: "src/adapters/gemini.py"
      to: "src/adapters/registry.py"
      via: "decorator registration"
      pattern: "@AdapterRegistry\\.register\\(\"gemini\"\\)"
    - from: "src/adapters/gemini.py"
      to: "src/utils/paths.py"
      via: "import utility functions"
      pattern: "from src\\.utils\\.paths import.*write_json_atomic"
---

<objective>
Implement the Gemini CLI adapter with all 6 sync methods: rules, skills, agents, commands, MCP servers, and settings. Gemini CLI uses GEMINI.md as its primary context file and cannot use symlinks for skills, requiring inline content transformation with YAML frontmatter stripping.

Purpose: Prove adapter pattern extensibility with a fundamentally different target architecture (monolithic context file vs Codex's directory-based approach). Deliver requirements GMN-01 through GMN-06.

Output: `src/adapters/gemini.py` (complete GeminiAdapter), updated `src/utils/paths.py` (write_json_atomic utility).
</objective>

<execution_context>
@.planning/phases/03-gemini-opencode-adapters/03-RESEARCH.md
</execution_context>

<context>
@src/adapters/base.py
@src/adapters/registry.py
@src/adapters/result.py
@src/adapters/codex.py
@src/utils/paths.py
@src/utils/toml_writer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add write_json_atomic utility and implement GeminiAdapter with rules, skills, agents, and commands sync</name>
  <files>src/utils/paths.py, src/adapters/gemini.py</files>
  <action>
    **Step 1: Add write_json_atomic to src/utils/paths.py**

    Add a `write_json_atomic(path: Path, data: dict) -> None` function to `src/utils/paths.py` following the exact same tempfile + os.replace pattern from `write_toml_atomic` in `src/utils/toml_writer.py`. This utility will be used by both Gemini and OpenCode adapters for safe JSON config writes.

    Implementation:
    - Import `json`, `tempfile`, `os` (json and os already imported; tempfile needs adding)
    - `ensure_dir(path.parent)` to create parent directories
    - Create `NamedTemporaryFile(mode='w', dir=path.parent, suffix='.tmp', delete=False, encoding='utf-8')`
    - `json.dump(data, temp_fd, indent=2, ensure_ascii=False)` then `temp_fd.write('\n')` for trailing newline
    - `temp_fd.flush()`, `os.fsync(temp_fd.fileno())`, `temp_fd.close()`
    - `os.replace(str(temp_path), str(path))`
    - In except block: close fd if open, unlink temp if exists, re-raise

    **Step 2: Create src/adapters/gemini.py with GeminiAdapter**

    Create the file with these constants:
    - `HARNESSSYNC_MARKER = "<!-- Managed by HarnessSync -->"`
    - `HARNESSSYNC_MARKER_END = "<!-- End HarnessSync managed content -->"`
    - `GEMINI_MD = "GEMINI.md"`
    - `SETTINGS_JSON = "settings.json"`

    Register with: `@AdapterRegistry.register("gemini")`

    Inherit from `AdapterBase`. Import `SyncResult` from `.result`, `ensure_dir`, `read_json_safe`, `write_json_atomic` from `src.utils.paths`.

    **sync_rules(self, rules: list[dict]) -> SyncResult:** (GMN-01)
    - If no rules, return SyncResult(skipped=1)
    - Concatenate rule contents with `\n\n---\n\n` separator
    - Build managed section with markers (same pattern as CodexAdapter._replace_managed_section):
      ```
      <!-- Managed by HarnessSync -->
      # Rules synced from Claude Code

      {concatenated rules}

      ---
      *Last synced by HarnessSync: {UTC timestamp}*
      <!-- End HarnessSync managed content -->
      ```
    - Read existing GEMINI.md, replace managed section or append if no markers exist
    - Preserve any user content outside HarnessSync markers
    - Write GEMINI.md
    - Return SyncResult(synced=1, adapted=len(rules))

    **sync_skills(self, skills: dict[str, Path]) -> SyncResult:** (GMN-02)
    - If no skills, return SyncResult()
    - For each skill (name, skill_dir):
      - Read skill_dir / "SKILL.md"
      - Call `self._parse_frontmatter(content)` to get (frontmatter_dict, body)
      - Build section: `## Skill: {frontmatter.get('name', name)}\n\n**Purpose:** {description}\n\n{body}`
      - Strip leading/trailing whitespace from body
    - Combine all skill sections with `\n\n---\n\n` separator
    - Write into GEMINI.md under a skills managed subsection using markers:
      ```
      <!-- HarnessSync:Skills -->
      {combined skill sections}
      <!-- End HarnessSync:Skills -->
      ```
    - Use a helper `_write_gemini_section(section_name, content)` to handle section replacement within the main managed block
    - Return SyncResult(synced=len(skills), adapted=len(skills))

    **sync_agents(self, agents: dict[str, Path]) -> SyncResult:** (GMN-03)
    - Similar to skills but reads agent .md files directly (not SKILL.md in subdirs)
    - Parse frontmatter, extract role section using `_extract_role_section(body)` (same regex as Codex: `<role>(.*?)</role>`)
    - Build section: `## Agent: {name}\n\n**Description:** {description}\n\n{role_instructions}`
    - Write into GEMINI.md under agents subsection with markers:
      ```
      <!-- HarnessSync:Agents -->
      {combined agent sections}
      <!-- End HarnessSync:Agents -->
      ```
    - Return SyncResult(synced=count, adapted=count)

    **sync_commands(self, commands: dict[str, Path]) -> SyncResult:** (GMN-04)
    - Parse each command .md file's frontmatter
    - Build brief description: `- **/{name}**: {description}` (one line per command, NOT full content)
    - Write into GEMINI.md under commands subsection:
      ```
      <!-- HarnessSync:Commands -->
      ## Available Commands

      {bullet list of commands}
      <!-- End HarnessSync:Commands -->
      ```
    - Return SyncResult(synced=len(commands), adapted=len(commands))

    **Helper methods to implement:**
    - `_parse_frontmatter(content)` — Reuse exact same regex pattern from CodexAdapter (copy, do not import cross-adapter)
    - `_extract_role_section(body)` — Same regex as Codex: `re.search(r'<role>(.*?)</role>', body, re.DOTALL | re.IGNORECASE)`
    - `_read_gemini_md()` — Read GEMINI.md or return ""
    - `_write_gemini_md(content)` — Write GEMINI.md with ensure_dir
    - `_replace_managed_section(existing, managed)` — Same logic as Codex (find markers, replace between, or append)
    - `_build_managed_content(sections: dict[str, str])` — Build complete managed block from section dict (rules, skills, agents, commands)
    - Store sections as instance state (`self._sections`) during sync_all flow, OR use subsection markers within the main managed block

    **Architecture decision — subsection markers approach:**
    Use subsection markers within the main HarnessSync managed block. Each call to sync_skills/agents/commands reads the current GEMINI.md, finds its subsection markers, replaces that subsection, and writes back. This allows incremental syncing (skills only, agents only, etc.) without losing other sections.

    **Important:** Do NOT use symlinks for Gemini. All content must be inlined into GEMINI.md. Gemini CLI cannot follow symlinks (confirmed in research).
  </action>
  <verify>
    Create a verification script that:
    1. Instantiates GeminiAdapter with a temp directory
    2. Calls sync_rules with 2 mock rules -> verify GEMINI.md contains rules with markers
    3. Creates mock skill dir with SKILL.md containing frontmatter -> calls sync_skills -> verify GEMINI.md has skill section without YAML frontmatter
    4. Creates mock agent .md with frontmatter + role tags -> calls sync_agents -> verify GEMINI.md has agent section
    5. Creates mock command .md with frontmatter -> calls sync_commands -> verify GEMINI.md has command summary
    6. Verify write_json_atomic creates valid JSON file atomically
    7. Verify `from src.utils.paths import write_json_atomic` succeeds and write_json_atomic is callable
    8. Verify idempotency: re-sync rules -> markers replaced, not duplicated
    9. Verify user content preservation: add content outside markers, re-sync, verify user content still present

    (Level 2: Proxy)
  </verify>
  <done>
    GeminiAdapter implements sync_rules (GMN-01), sync_skills (GMN-02), sync_agents (GMN-03), sync_commands (GMN-04) with YAML frontmatter stripping, inline content in GEMINI.md with subsection markers, user content preservation, and write_json_atomic utility added to paths.py.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement GeminiAdapter MCP translation and permission mapping</name>
  <files>src/adapters/gemini.py</files>
  <action>
    **sync_mcp(self, mcp_servers: dict[str, dict]) -> SyncResult:** (GMN-05)

    Translate Claude Code MCP server configs to Gemini settings.json format.

    Target format (from research):
    ```json
    {
      "mcpServers": {
        "server-name": {
          "command": "npx",
          "args": ["-y", "server-package"],
          "env": { "API_KEY": "$MY_API_KEY" },
          "timeout": 30000
        },
        "url-server": {
          "url": "https://api.example.com/sse"
        }
      }
    }
    ```

    Implementation:
    - Config path: `self.project_dir / ".gemini" / SETTINGS_JSON`
    - Read existing settings.json using `read_json_safe(config_path)`
    - Initialize `existing.setdefault("mcpServers", {})`
    - For each MCP server:
      - **Stdio transport** (has "command" key):
        - Map directly: `{"command": config["command"], "args": config.get("args", [])}`
        - Include "env" dict if present (preserve `${VAR}` references as-is)
        - Include "timeout" if "timeout" in config
      - **URL transport** (has "url" key):
        - Use direct URL config (NOT npx mcp-remote wrapper, per research Open Question 1 recommendation: "Start with direct URL config"):
          - If url ends with `/sse` or contains `sse`: `{"url": config["url"]}`
          - If url is plain HTTP/HTTPS: `{"httpUrl": config["url"]}`
          - Include "headers" dict if present
      - **Skip** servers with neither "command" nor "url" (log warning)
    - Merge into existing mcpServers (new servers override existing with same name)
    - Write atomically using `write_json_atomic`
    - Return SyncResult(synced=count)

    **sync_settings(self, settings: dict) -> SyncResult:** (GMN-06)

    Map Claude Code permission settings to Gemini configuration.

    Gemini permission model (from research):
    - `yolo` mode: auto-approves all tools (DANGEROUS - never auto-enable)
    - `tools.allowedTools`: list of tool names to allow
    - `tools.blockedTools`: list of tool names to block

    Implementation:
    - Config path: `self.project_dir / ".gemini" / SETTINGS_JSON`
    - Read existing settings.json
    - Extract permissions from settings: `allow_list = settings.get('permissions', {}).get('allow', [])` and `deny_list = settings.get('permissions', {}).get('deny', [])`
    - Conservative mapping rules:
      1. **NEVER set yolo mode to true** — if user has auto-approval in Claude Code, still use standard mode in Gemini (warn in SyncResult)
      2. If deny_list is non-empty: add `"tools": {"blockedTools": deny_list}` to settings
      3. If allow_list is non-empty AND deny_list is empty: add `"tools": {"allowedTools": allow_list}` to settings
      4. If both empty: don't add tools section (use Gemini defaults)
    - Merge with existing settings (preserve mcpServers and other keys)
    - Write atomically using `write_json_atomic`
    - Return SyncResult(synced=1, adapted=1)
    - If deny_list causes tool blocking, add warning to skipped_files: "{tool}: blocked (Claude Code deny list)"

    **Important security constraint:** Log a warning if Claude Code has `approval_mode: "auto"` — note that Gemini yolo mode is NOT enabled (conservative default). Add to SyncResult.skipped_files: "yolo mode: not enabled (conservative default, Claude Code had auto-approval)"
  </action>
  <verify>
    Create a verification script that:
    1. sync_mcp with stdio server (command+args+env) -> verify settings.json has correct mcpServers structure
    2. sync_mcp with URL server -> verify url or httpUrl field in settings.json
    3. sync_mcp with mixed servers -> verify both types present
    4. sync_mcp preserves existing settings.json content (merge, not overwrite)
    5. sync_mcp preserves env var references (${VAR} literal strings)
    6. sync_settings with deny list -> verify blockedTools in settings.json
    7. sync_settings with allow list -> verify allowedTools in settings.json
    8. sync_settings with auto-approval -> verify yolo NOT enabled, warning in result
    9. sync_settings + sync_mcp coexistence -> both in same settings.json

    (Level 2: Proxy)
  </verify>
  <done>
    GeminiAdapter.sync_mcp translates MCP servers to settings.json mcpServers format (GMN-05) with stdio/URL transport handling and env var preservation. GeminiAdapter.sync_settings maps permissions conservatively to Gemini tools config (GMN-06) with yolo mode never auto-enabled. All 6 Gemini sync methods complete and verified.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- GEMINI.md exists after sync and contains expected section headers (not raw YAML frontmatter)
- settings.json is valid JSON with expected mcpServers structure
- write_json_atomic creates file atomically (temp + rename)

Level 2 (Proxy):
- Each sync method returns SyncResult with correct synced/adapted counts
- Frontmatter successfully stripped from inlined skills/agents
- MCP servers have correct transport detection (stdio vs URL)
- Permission mapping is conservative (no yolo mode auto-enabled)
- Markers replaced correctly on re-sync (no duplication)
- User content outside markers preserved

Level 3 (Deferred):
- Real Gemini CLI loads GEMINI.md and activates inlined skills
- Real Gemini CLI connects to MCP servers via settings.json
- Manual verification of permission restrictions
</verification>

<success_criteria>
1. GeminiAdapter registered and all 6 sync methods implemented
2. GEMINI.md contains rules, inlined skills (no frontmatter), agent descriptions, and command summaries in managed sections
3. settings.json contains correctly translated MCP server configs
4. Permission mapping never auto-enables yolo mode
5. write_json_atomic utility available for all adapters
6. All verification tests pass with 0 failures
</success_criteria>

<output>
After completion, create `.planning/phases/03-gemini-opencode-adapters/03-01-SUMMARY.md`
</output>
