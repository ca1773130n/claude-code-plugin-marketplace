---
phase: 03-gemini-opencode-adapters
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/adapters/opencode.py
  - src/adapters/__init__.py
autonomous: true
verification_level: proxy

eval_metrics:
  primary: "integration_test_failures: 0"
  baseline: "1/3 adapters working"
  target: "3/3 adapters with 0 failures"

must_haves:
  truths:
    - "OpenCodeAdapter registered via @AdapterRegistry.register('opencode') and all 6 sync methods implemented"
    - "sync_rules writes rules to AGENTS.md with HarnessSync markers (same pattern as Codex, different file location)"
    - "sync_skills creates symlinks from .claude/skills/{name} to .opencode/skills/{name} with stale symlink cleanup"
    - "sync_agents creates symlinks from .claude/agents/{name}.md to .opencode/agents/{name}.md with stale cleanup"
    - "sync_commands creates symlinks from .claude/commands/{name}.md to .opencode/commands/{name}.md with stale cleanup"
    - "sync_mcp translates MCP servers to opencode.json with type: 'local' for stdio and type: 'remote' for URL servers"
    - "sync_settings maps permissions conservatively to OpenCode permission mode (deny -> restricted, never auto-allow)"
    - "Stale symlinks removed from all .opencode/ subdirectories after sync"
    - "All three adapters (Codex, Gemini, OpenCode) can be instantiated and synced via AdapterRegistry"
  artifacts:
    - path: "src/adapters/opencode.py"
      provides: "OpenCodeAdapter implementation with all 6 sync methods"
      min_lines: 250
    - path: "src/adapters/__init__.py"
      provides: "Updated imports to auto-register gemini and opencode adapters"
  key_links:
    - from: "src/adapters/opencode.py"
      to: "src/adapters/base.py"
      via: "class inheritance"
      pattern: "class OpenCodeAdapter\\(AdapterBase\\)"
    - from: "src/adapters/opencode.py"
      to: "src/adapters/registry.py"
      via: "decorator registration"
      pattern: "@AdapterRegistry\\.register\\(\"opencode\"\\)"
    - from: "src/adapters/opencode.py"
      to: "src/utils/paths.py"
      via: "import utility functions"
      pattern: "from src\\.utils\\.paths import.*create_symlink_with_fallback.*cleanup_stale_symlinks"
    - from: "src/adapters/__init__.py"
      to: "src/adapters/gemini.py"
      via: "import for registration side effect"
      pattern: "from . import gemini"
    - from: "src/adapters/__init__.py"
      to: "src/adapters/opencode.py"
      via: "import for registration side effect"
      pattern: "from . import opencode"
---

<objective>
Implement the OpenCode adapter with native symlink support and type-discriminated MCP config, then verify all three adapters (Codex, Gemini, OpenCode) work together via the AdapterRegistry. Update `__init__.py` to auto-register all adapters on import.

Purpose: Complete Phase 3 by delivering the final adapter and proving the adapter pattern scales to three distinct target architectures. Deliver requirements OC-01 through OC-06 and validate Phase 3 success criteria (all three adapters sync a test project).

Output: `src/adapters/opencode.py` (complete OpenCodeAdapter), updated `src/adapters/__init__.py`, integration verification across all 3 adapters.
</objective>

<execution_context>
@.planning/phases/03-gemini-opencode-adapters/03-RESEARCH.md
@.planning/phases/03-gemini-opencode-adapters/03-01-SUMMARY.md
</execution_context>

<context>
@src/adapters/base.py
@src/adapters/registry.py
@src/adapters/result.py
@src/adapters/codex.py
@src/adapters/gemini.py
@src/adapters/__init__.py
@src/utils/paths.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement OpenCodeAdapter with all 6 sync methods</name>
  <files>src/adapters/opencode.py</files>
  <action>
    Create `src/adapters/opencode.py` with these constants:
    - `HARNESSSYNC_MARKER = "<!-- Managed by HarnessSync -->"`
    - `HARNESSSYNC_MARKER_END = "<!-- End HarnessSync managed content -->"`
    - `AGENTS_MD = "AGENTS.md"`
    - `OPENCODE_DIR = ".opencode"`
    - `OPENCODE_JSON = "opencode.json"`

    Register with: `@AdapterRegistry.register("opencode")`

    Inherit from `AdapterBase`. Import:
    - `SyncResult` from `.result`
    - `create_symlink_with_fallback`, `cleanup_stale_symlinks`, `ensure_dir`, `read_json_safe`, `write_json_atomic` from `src.utils.paths`
    - `re`, `datetime` from stdlib

    **sync_rules(self, rules: list[dict]) -> SyncResult:** (OC-01)
    - Same pattern as CodexAdapter.sync_rules but writes to project root AGENTS.md
    - Concatenate rules, build managed section with markers, replace or append in AGENTS.md
    - Use self.project_dir / AGENTS_MD as target path
    - Return SyncResult(synced=1, adapted=len(rules))

    **sync_skills(self, skills: dict[str, Path]) -> SyncResult:** (OC-02)
    - Target dir: `self.project_dir / OPENCODE_DIR / "skills"`
    - `ensure_dir(target_dir)`
    - For each skill (name, source_path):
      - Use `create_symlink_with_fallback(source_path, target_dir / name)` to create symlink
      - Track synced/skipped/failed in SyncResult
    - After creating all symlinks, call `cleanup_stale_symlinks(target_dir)` to remove broken symlinks
    - Add cleaned count to result (note: SyncResult doesn't have 'cleaned' field, track in skipped_files as "cleaned: N stale symlinks")
    - Return result

    **sync_agents(self, agents: dict[str, Path]) -> SyncResult:** (OC-03)
    - Target dir: `self.project_dir / OPENCODE_DIR / "agents"`
    - `ensure_dir(target_dir)`
    - For each agent (name, agent_path):
      - Source is the .md file path directly
      - Create symlink: `create_symlink_with_fallback(agent_path, target_dir / f"{name}.md")`
      - Track results
    - Call `cleanup_stale_symlinks(target_dir)` after all symlinks created
    - Return result

    **sync_commands(self, commands: dict[str, Path]) -> SyncResult:** (OC-04)
    - Target dir: `self.project_dir / OPENCODE_DIR / "commands"`
    - `ensure_dir(target_dir)`
    - For each command (name, cmd_path):
      - Create symlink: `create_symlink_with_fallback(cmd_path, target_dir / f"{name}.md")`
      - Track results
    - Call `cleanup_stale_symlinks(target_dir)` after all symlinks created
    - Return result

    **sync_mcp(self, mcp_servers: dict[str, dict]) -> SyncResult:** (OC-05)
    - Config path: `self.project_dir / OPENCODE_JSON`
    - Read existing opencode.json using `read_json_safe(config_path)`
    - Translate each MCP server using type-discriminated format (from research):
      - **Stdio transport** (has "command" key) -> type: "local":
        ```json
        {
          "type": "local",
          "command": ["command", "arg1", "arg2"],
          "environment": {"KEY": "${VAR}"},
          "enabled": true
        }
        ```
        - Note: OpenCode wants `command` as array `[config["command"]] + config.get("args", [])`
        - Note: OpenCode uses `environment` not `env`
      - **URL transport** (has "url" key) -> type: "remote":
        ```json
        {
          "type": "remote",
          "url": "https://mcp.example.com",
          "headers": {"Authorization": "Bearer ${TOKEN}"},
          "enabled": true
        }
        ```
    - Merge into existing config: `existing.setdefault("mcp", {})`, then `existing["mcp"].update(translated_servers)`
    - Add `"$schema": "https://opencode.ai/config.json"` if not present
    - Write atomically using `write_json_atomic`
    - Return SyncResult(synced=count)

    **sync_settings(self, settings: dict) -> SyncResult:** (OC-06)
    - Config path: `self.project_dir / OPENCODE_JSON`
    - Read existing opencode.json
    - Extract permissions: allow_list and deny_list from settings
    - Conservative mapping:
      1. If deny_list is non-empty: set `"permissions": {"mode": "restricted"}` and add denied tools to `"permissions": {"denied": deny_list}`
      2. If allow_list is non-empty AND deny_list is empty: set `"permissions": {"mode": "default"}` with `"permissions": {"allowed": allow_list}`
      3. If both empty: set `"permissions": {"mode": "default"}`
      4. **NEVER** set permissions mode to "yolo" or equivalent unrestricted mode
    - If Claude Code has `approval_mode: "auto"`, still use default mode in OpenCode (warn in result)
    - Merge with existing config (preserve mcp and other keys)
    - Write atomically using `write_json_atomic`
    - Return SyncResult(synced=1, adapted=1)

    **Helper methods:**
    - `_read_agents_md()` — Read AGENTS.md or return ""
    - `_write_agents_md(content)` — Write AGENTS.md with ensure_dir
    - `_replace_managed_section(existing, managed)` — Same marker replacement logic as Codex/Gemini
  </action>
  <verify>
    Create a verification script that:
    1. Instantiate OpenCodeAdapter with temp directory
    2. sync_rules with 2 mock rules -> verify AGENTS.md has markers and rule content
    3. Create mock skill dir -> sync_skills -> verify .opencode/skills/{name} symlink exists and points to source
    4. Create mock agent .md -> sync_agents -> verify .opencode/agents/{name}.md symlink
    5. Create mock command .md -> sync_commands -> verify .opencode/commands/{name}.md symlink
    6. Create a stale symlink in .opencode/skills/, sync_skills -> verify stale symlink removed
    7. sync_mcp with stdio server -> verify opencode.json has type: "local" with command array
    8. sync_mcp with URL server -> verify opencode.json has type: "remote" with url string
    9. sync_mcp preserves env var references (${VAR})
    10. sync_settings with deny list -> verify restricted mode in opencode.json
    11. sync_settings + sync_mcp coexistence in same opencode.json

    (Level 2: Proxy)
  </verify>
  <done>
    OpenCodeAdapter implements all 6 sync methods: rules to AGENTS.md (OC-01), skills via symlinks (OC-02), agents via symlinks (OC-03), commands via symlinks (OC-04), MCP to opencode.json with type discrimination (OC-05), settings with conservative permission mapping (OC-06). Stale symlink cleanup works for all .opencode/ subdirectories.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update adapter imports and run 3-adapter integration verification</name>
  <files>src/adapters/__init__.py</files>
  <action>
    **Step 1: Update src/adapters/__init__.py**

    Add imports for gemini and opencode modules so they self-register on package import:

    After the existing imports (`from .base import AdapterBase`, etc.), add:
    ```python
    # Import adapter modules to trigger @AdapterRegistry.register() decorators
    from . import codex  # noqa: F401
    from . import gemini  # noqa: F401
    from . import opencode  # noqa: F401
    ```

    This ensures that when anyone does `from src.adapters import AdapterRegistry`, all three adapters are registered and available via `AdapterRegistry.get_adapter()`.

    Verify `__all__` list still includes `AdapterBase`, `AdapterRegistry`, `SyncResult`.

    **Step 2: Run 3-adapter integration verification**

    Create a comprehensive integration test that syncs the same test project to all three adapters. The test project should contain:
    - 2 rule files (CLAUDE.md content strings)
    - 3 skills (directories with SKILL.md containing frontmatter)
    - 2 agents (.md files with frontmatter + role tags)
    - 1 command (.md file with frontmatter)
    - 2 MCP servers (1 stdio with command+args+env, 1 URL)
    - Permission settings (1 denied tool, 1 allowed tool)

    For each adapter (codex, gemini, opencode):
    1. Instantiate via `AdapterRegistry.get_adapter(target_name, temp_dir)`
    2. Call `sync_all(source_data)` with the test project data
    3. Verify SyncResult for each config type:
       - rules: synced >= 1, failed == 0
       - skills: synced == 3, failed == 0
       - agents: synced == 2, failed == 0
       - commands: synced == 1, failed == 0
       - mcp: synced == 2, failed == 0
       - settings: synced == 1, failed == 0
    4. Verify target-specific artifacts:
       - **Codex:** AGENTS.md exists, .agents/skills/ has symlinks, .codex/codex.toml has MCP servers
       - **Gemini:** GEMINI.md exists with inlined skills (no YAML frontmatter), .gemini/settings.json has mcpServers
       - **OpenCode:** AGENTS.md exists, .opencode/skills/ has symlinks, .opencode/agents/ has symlinks, opencode.json has mcp config

    Print summary table:
    ```
    Target   | Rules | Skills | Agents | Cmds | MCP | Settings | Status
    ---------|-------|--------|--------|------|-----|----------|-------
    codex    | 1/0   | 3/0    | 2/0    | 1/0  | 2/0 | 1/0      | PASS
    gemini   | 1/0   | 3/0    | 2/0    | 1/0  | 2/0 | 1/0      | PASS
    opencode | 1/0   | 3/0    | 2/0    | 1/0  | 2/0 | 1/0      | PASS
    ```
    Format: synced/failed for each column.

    **Step 3: Verify adapter discovery**

    Confirm `AdapterRegistry.list_targets()` returns `['codex', 'gemini', 'opencode']` (sorted alphabetically).

    Confirm `AdapterRegistry.has_target('gemini')` and `AdapterRegistry.has_target('opencode')` both return True.
  </action>
  <verify>
    Run the 3-adapter integration verification script.

    Pre-flight check:
    - Confirm __init__.py contains `from . import codex`, `from . import gemini`, `from . import opencode`
    - Confirm AdapterRegistry.list_targets() returns exactly 3 targets before running integration test

    Expected results:
    - AdapterRegistry.list_targets() == ['codex', 'gemini', 'opencode']
    - All 3 adapters sync 7 items (rules=1, skills=3, agents=2, commands=1) + 2 MCP + 1 settings = total 10 operations per adapter
    - 0 failures across all adapters
    - Target-specific artifacts verified (GEMINI.md has no YAML frontmatter, .opencode/ has valid symlinks, .codex/ has valid TOML)

    Phase 3 success criteria check:
    1. Gemini adapter inlines skills into GEMINI.md (strips frontmatter, adds section headers) - VERIFIED
    2. Gemini adapter translates MCP to settings.json mcpServers - VERIFIED
    3. OpenCode adapter creates symlinks to .opencode/ with stale cleanup - VERIFIED
    4. OpenCode adapter translates MCP to opencode.json with type discrimination - VERIFIED
    5. All 3 adapters sync test project successfully - VERIFIED
    6. Conservative permission mapping for all adapters - VERIFIED

    (Level 2: Proxy)
  </verify>
  <done>
    All three adapters (Codex, Gemini, OpenCode) registered in AdapterRegistry and verified via 3-adapter integration test. adapter __init__.py auto-registers all adapters on import. Phase 3 requirements GMN-01 through GMN-06 and OC-01 through OC-06 fully delivered and verified.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- src/adapters/opencode.py exists and defines OpenCodeAdapter class
- src/adapters/__init__.py imports codex, gemini, opencode modules
- AdapterRegistry.list_targets() returns 3 targets
- .opencode/ directories created with correct structure

Level 2 (Proxy):
- All 6 sync methods on OpenCodeAdapter return correct SyncResult counts
- Symlinks in .opencode/{skills,agents,commands} point to correct sources
- Stale symlinks removed after sync
- opencode.json has type-discriminated MCP server configs
- 3-adapter integration test passes with 0 failures across all adapters
- Permission mapping conservative for all 3 targets

Level 3 (Deferred):
- Real OpenCode CLI loads skills/agents/commands from .opencode/ via symlinks
- Real OpenCode CLI connects to MCP servers via opencode.json
- Real Gemini + OpenCode + Codex CLIs all work with synced configs simultaneously
- Manual verification of permission restrictions across all 3 CLIs
</verification>

<success_criteria>
1. OpenCodeAdapter registered and all 6 sync methods implemented with symlinks + stale cleanup
2. AdapterRegistry lists all 3 targets: codex, gemini, opencode
3. 3-adapter integration test syncs rules(2), skills(3), agents(2), commands(1), MCP(2), settings with 0 failures
4. Permission mapping conservative across all 3 adapters (no yolo, no danger modes auto-enabled)
5. Phase 3 delivers all 12 requirements (GMN-01-06, OC-01-06)
</success_criteria>

<output>
After completion, create `.planning/phases/03-gemini-opencode-adapters/03-02-SUMMARY.md`
</output>
