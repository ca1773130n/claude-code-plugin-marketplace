---
phase: 10-scope-aware-target-sync-environment-translation
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/adapters/base.py
  - src/adapters/codex.py
  - src/adapters/gemini.py
  - src/adapters/opencode.py
  - src/orchestrator.py
autonomous: true
verification_level: proxy

must_haves:
  truths:
    - "Codex adapter writes user-scope MCPs to ~/.codex/config.toml and project-scope MCPs to .codex/config.toml"
    - "Gemini adapter writes user-scope MCPs to ~/.gemini/settings.json and project-scope MCPs to .gemini/settings.json"
    - "Plugin MCPs (metadata.source == 'plugin') always route to user-scope target config regardless of other scope metadata"
    - "Local-scope MCPs (metadata.scope == 'local') route to user-scope target config (same as user)"
    - "Codex adapter calls translate_env_vars_for_codex() on each server config before writing TOML"
    - "Gemini adapter preserves ${VAR} syntax as-is (no env var translation)"
    - "SSE transport MCPs skipped with warning on Codex and OpenCode, written normally on Gemini"
    - "Orchestrator passes mcp_servers_scoped (with metadata) to adapters instead of flat mcp dict"
    - "sync_all() in base.py passes scoped MCP data via new sync_mcp_scoped() or updated sync_mcp() signature"
  artifacts:
    - path: "src/adapters/base.py"
      provides: "Updated adapter interface with scope-aware MCP sync"
    - path: "src/adapters/codex.py"
      provides: "Codex adapter with scope routing, env var translation, transport validation"
    - path: "src/adapters/gemini.py"
      provides: "Gemini adapter with scope routing, env var preservation, transport validation"
    - path: "src/adapters/opencode.py"
      provides: "OpenCode adapter with scope routing and transport validation"
    - path: "src/orchestrator.py"
      provides: "Orchestrator passing scoped MCP data to adapters"
  key_links:
    - from: "src/adapters/codex.py"
      to: "src/utils/env_translator.py"
      via: "import and call translate_env_vars_for_codex"
      pattern: "from src.utils.env_translator import"
    - from: "src/adapters/codex.py"
      to: "src/utils/env_translator.py"
      via: "import and call check_transport_support"
      pattern: "check_transport_support"
    - from: "src/orchestrator.py"
      to: "src/source_reader.py"
      via: "mcp_servers_scoped passed to adapters"
      pattern: "mcp_servers_scoped"
---

<objective>
Update all adapters and the orchestrator to implement scope-aware MCP syncing with environment variable translation and transport validation.

Purpose: v1.0 wrote all MCPs to a single project-level config file. v2.0 must route user-scope MCPs to user config paths (`~/.codex/`, `~/.gemini/`) and project-scope MCPs to project config paths (`.codex/`, `.gemini/`). Codex requires env var expansion, Gemini preserves syntax, and unsupported transports must warn.

Output: Updated adapter files with scope routing, env translation calls, transport checks, and updated orchestrator passing scoped data.
</objective>

<execution_context>
@${CLAUDE_PLUGIN_ROOT}/references/execute-plan.md
@${CLAUDE_PLUGIN_ROOT}/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-scope-aware-target-sync-environment-translation/10-RESEARCH.md
@.planning/phases/10-scope-aware-target-sync-environment-translation/10-01-SUMMARY.md

# Source files to modify
@src/adapters/base.py
@src/adapters/codex.py
@src/adapters/gemini.py
@src/adapters/opencode.py
@src/orchestrator.py
@src/source_reader.py
@src/utils/env_translator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update adapter interface and orchestrator for scoped MCP data</name>
  <files>src/adapters/base.py, src/orchestrator.py</files>
  <action>
    **src/adapters/base.py changes:**

    1. Add a NEW method `sync_mcp_scoped(self, mcp_servers_scoped: dict[str, dict]) -> SyncResult`:
       - Abstract method that receives the Phase 9 scoped format: `{server_name: {"config": {...}, "metadata": {"scope": "user|project|local", "source": "file|plugin", ...}}}`
       - Default implementation (NOT abstract -- provide a concrete default) that falls back to calling `sync_mcp()` with flat config for backward compatibility:
         ```python
         def sync_mcp_scoped(self, mcp_servers_scoped: dict[str, dict]) -> SyncResult:
             flat = {name: entry.get("config", entry) for name, entry in mcp_servers_scoped.items()}
             return self.sync_mcp(flat)
         ```
       - This allows adapters that haven't been updated to still work via fallback

    2. Update `sync_all()`:
       - Change the MCP sync call from `self.sync_mcp(source_data.get('mcp', {}))` to `self.sync_mcp_scoped(source_data.get('mcp_scoped', source_data.get('mcp', {})))`
       - This looks for 'mcp_scoped' first, falls back to 'mcp' for backward compatibility

    **src/orchestrator.py changes:**

    1. In `sync_all()`, after constructing `adapter_data`:
       - Add `adapter_data['mcp_scoped'] = source_data.get('mcp_servers_scoped', {})` alongside the existing `adapter_data['mcp']` key
       - Keep the existing flat `mcp` key for backward compatibility with other consumers
       - The scoped data flows: `SourceReader.discover_all()['mcp_servers_scoped']` -> `adapter_data['mcp_scoped']` -> `adapter.sync_all()` -> `adapter.sync_mcp_scoped()`

    AVOID:
    - Removing the existing `sync_mcp()` abstract method (keep for backward compatibility)
    - Breaking the existing adapter_data['mcp'] key (other parts of orchestrator may use it)
    - Changing the sync_all() return type or other signatures
  </action>
  <verify>
    python -c "from src.adapters.base import AdapterBase; print('base imports OK')"
    python -c "from src.orchestrator import SyncOrchestrator; print('orchestrator imports OK')"
    (Level 1: Sanity - modules import without errors)
  </verify>
  <done>
    AdapterBase has sync_mcp_scoped() with default fallback to sync_mcp().
    sync_all() calls sync_mcp_scoped() with scoped data when available.
    Orchestrator passes mcp_scoped key in adapter_data.
    All existing imports and signatures preserved.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement scope-aware sync in Codex, Gemini, and OpenCode adapters</name>
  <files>src/adapters/codex.py, src/adapters/gemini.py, src/adapters/opencode.py</files>
  <action>
    **src/adapters/codex.py changes:**

    1. Add imports: `from src.utils.env_translator import translate_env_vars_for_codex, check_transport_support`

    2. Override `sync_mcp_scoped(self, mcp_servers_scoped: dict[str, dict]) -> SyncResult`:
       - Group servers by effective scope:
         - If `metadata.source == "plugin"` or `metadata.scope == "local"`: route to user scope (Decision #34)
         - If `metadata.scope == "user"`: route to user scope
         - If `metadata.scope == "project"`: route to project scope
       - For each server, BEFORE grouping:
         - Call `check_transport_support(server_name, config, "codex")` -- if not supported, increment result.skipped, append warning to result.skipped_files, skip server
         - Call `translate_env_vars_for_codex(config)` -- get (translated_config, warnings), append warnings to result.skipped_files
       - Write user-scope servers using new helper `_write_mcp_to_path(servers, config_path)`:
         - config_path = `Path.home() / ".codex" / CONFIG_TOML`
         - Reuse existing config merge logic (read existing, merge, build TOML, write atomic)
       - Write project-scope servers using same helper:
         - config_path = `self.project_dir / ".codex" / CONFIG_TOML`
       - Accumulate synced/skipped/failed counts for both scopes

    3. Add helper `_write_mcp_to_path(self, mcp_servers: dict[str, dict], config_path: Path) -> SyncResult`:
       - Extract the existing sync_mcp logic into this helper:
         - Read existing config from config_path using `read_toml_safe(config_path)`
         - Merge MCP servers
         - Build settings + MCP sections
         - Write atomically
       - The existing `sync_mcp()` method should call `_write_mcp_to_path(self, mcp_servers, self.project_dir / ".codex" / CONFIG_TOML)` for backward compatibility

    4. Update `_read_existing_config()` to accept optional path parameter (default to project path for backward compat)

    **src/adapters/gemini.py changes:**

    1. Add imports: `from src.utils.env_translator import check_transport_support`

    2. Override `sync_mcp_scoped(self, mcp_servers_scoped: dict[str, dict]) -> SyncResult`:
       - Same scope grouping logic as Codex (plugin/local -> user, project -> project)
       - For each server:
         - Call `check_transport_support(server_name, config, "gemini")` -- if not supported, skip with warning
         - Do NOT call env var translator (Gemini supports ${VAR} natively per ENV-03)
       - Write user-scope servers:
         - settings_path = `Path.home() / ".gemini" / SETTINGS_JSON`
         - Reuse existing settings.json merge logic (read existing, merge mcpServers, write atomic)
       - Write project-scope servers:
         - settings_path = `self.project_dir / ".gemini" / SETTINGS_JSON` (existing self.settings_path)

    3. Add helper `_write_mcp_to_settings(self, mcp_servers: dict[str, dict], settings_path: Path) -> SyncResult`:
       - Extract the existing sync_mcp MCP translation + write logic into this helper
       - The existing `sync_mcp()` calls this helper with self.settings_path for backward compat

    **src/adapters/opencode.py changes:**

    1. Add imports: `from src.utils.env_translator import check_transport_support`

    2. Override `sync_mcp_scoped(self, mcp_servers_scoped: dict[str, dict]) -> SyncResult`:
       - OpenCode only has project-level config (opencode.json in project root)
       - All servers go to self.opencode_json_path regardless of scope
       - For each server:
         - Call `check_transport_support(server_name, config, "opencode")` -- if not supported, skip with warning
       - Call existing sync_mcp() with the flat server configs
       - This is simpler than Codex/Gemini because OpenCode doesn't have separate user/project paths

    AVOID:
    - Removing or breaking the existing sync_mcp() method signatures (keep for backward compat)
    - Writing plugin MCPs to project-scope configs (always user scope per Decision #34)
    - Translating env vars for Gemini (preserve ${VAR} as-is)
    - Silently skipping unsupported transports (always log via result.skipped_files)
    - Mutating the config dicts from Phase 9 (always copy before translation)
  </action>
  <verify>
    Proxy verification script (create and run a temporary test):

    ```python
    import os, sys, tempfile, json
    from pathlib import Path

    # Setup: mock environment
    os.environ["TEST_API_KEY"] = "sk-test-12345"
    os.environ.pop("MISSING_PORT", None)

    # Test scoped data format (mimics Phase 9 output)
    scoped_mcps = {
        "user-server": {
            "config": {"command": "npx", "args": ["-y", "@test/mcp", "--key", "${TEST_API_KEY}"]},
            "metadata": {"scope": "user", "source": "file"}
        },
        "project-server": {
            "config": {"command": "python", "args": ["server.py", "--port", "${MISSING_PORT:-3000}"]},
            "metadata": {"scope": "project", "source": "file"}
        },
        "plugin-server": {
            "config": {"command": "node", "args": ["plugin-server.js"]},
            "metadata": {"scope": "user", "source": "plugin", "plugin_name": "test-plugin", "plugin_version": "1.0.0"}
        },
        "sse-server": {
            "config": {"url": "https://example.com/mcp/sse"},
            "metadata": {"scope": "user", "source": "file"}
        }
    }

    # Test 1: Codex adapter scope routing
    with tempfile.TemporaryDirectory() as tmpdir:
        project_dir = Path(tmpdir) / "project"
        project_dir.mkdir()

        # Temporarily override home for test
        from src.adapters.codex import CodexAdapter
        adapter = CodexAdapter(project_dir)
        result = adapter.sync_mcp_scoped(scoped_mcps)

        # Verify: user-scope file exists at ~/.codex/ (can't test home dir, check project works)
        project_codex = project_dir / ".codex" / "codex.toml"
        assert project_codex.exists(), "Project-scope config.toml should exist"
        content = project_codex.read_text()
        assert "project-server" in content, "Project server should be in project config"
        assert "user-server" not in content, "User server should NOT be in project config"

        # Verify: SSE server skipped with warning
        assert result.skipped >= 1, "SSE server should be skipped"
        assert any("SSE" in s for s in result.skipped_files), "SSE warning should be in skipped_files"

        print("PASS: Codex scope routing")

    # Test 2: Gemini adapter scope routing
    with tempfile.TemporaryDirectory() as tmpdir:
        project_dir = Path(tmpdir) / "project"
        project_dir.mkdir()

        from src.adapters.gemini import GeminiAdapter
        adapter = GeminiAdapter(project_dir)
        result = adapter.sync_mcp_scoped(scoped_mcps)

        # Verify: project settings.json has project server
        project_settings = project_dir / ".gemini" / "settings.json"
        assert project_settings.exists(), "Project settings.json should exist"
        data = json.loads(project_settings.read_text())
        assert "project-server" in data.get("mcpServers", {}), "Project server in project config"

        # Verify: SSE server NOT skipped on Gemini (Gemini supports SSE)
        print("PASS: Gemini scope routing")

    print("ALL PROXY TESTS PASSED")
    ```

    Run: `python verify_10_02.py` (Level 2: Proxy)
  </verify>
  <done>
    All 3 adapters override sync_mcp_scoped() with scope routing.
    Codex: user servers -> ~/.codex/config.toml, project servers -> .codex/config.toml, env vars translated.
    Gemini: user servers -> ~/.gemini/settings.json, project servers -> .gemini/settings.json, env vars preserved.
    OpenCode: all servers -> opencode.json (project-level only), transport validated.
    Plugin MCPs always routed to user-scope. SSE transport skipped on Codex with warning.
    Orchestrator passes mcp_scoped data to adapters.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- All adapter modules import without error
- Orchestrator imports without error

Level 2 (Proxy):
- Codex adapter writes user-scope MCPs to separate path from project-scope MCPs
- Codex adapter translates ${VAR} to resolved values with env map
- Gemini adapter preserves ${VAR} syntax in output JSON
- SSE transport MCPs skipped on Codex with warning message containing server name
- Plugin MCPs routed to user-scope config on all adapters
- Proxy verification script passes all assertions
</verification>

<success_criteria>
- All 3 adapters implement sync_mcp_scoped() with correct scope routing
- Codex splits output: user MCPs -> ~/.codex/config.toml, project MCPs -> .codex/config.toml
- Gemini splits output: user MCPs -> ~/.gemini/settings.json, project MCPs -> .gemini/settings.json
- Plugin MCPs always go to user-scope configs
- Env vars translated for Codex, preserved for Gemini
- Transport validation active on all adapters with per-target support matrix
- Proxy test script verifies scope routing and transport filtering
</success_criteria>

<output>
After completion, create `.planning/phases/10-scope-aware-target-sync-environment-translation/10-02-SUMMARY.md`
</output>
