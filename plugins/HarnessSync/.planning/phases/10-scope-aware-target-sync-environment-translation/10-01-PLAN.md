---
phase: 10-scope-aware-target-sync-environment-translation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/utils/env_translator.py
autonomous: true
verification_level: sanity

must_haves:
  truths:
    - "translate_env_vars_for_codex() extracts ${VAR} from config strings and resolves to Codex env map with values from os.environ"
    - "translate_env_vars_for_codex() handles ${VAR:-default} by using default when VAR is unset, and logs warning"
    - "translate_env_vars_for_codex() preserves existing env dict entries and merges extracted vars (existing wins on conflict)"
    - "detect_transport_type() returns 'stdio' for command-based, 'sse' for SSE URLs, 'http' for other URLs, 'unknown' for invalid"
    - "check_transport_support() returns (False, warning_message) for unsupported transport/target combos (SSE on codex)"
    - "preserve_env_vars_for_gemini() passes config through without modification (Gemini supports ${VAR} natively)"
  artifacts:
    - path: "src/utils/env_translator.py"
      provides: "Environment variable translation and transport detection utilities"
      min_lines: 80
  key_links:
    - from: "src/utils/env_translator.py"
      to: "os.environ"
      via: "os.environ.get() for runtime env var resolution"
      pattern: "os\\.environ\\.get"
---

<objective>
Create the environment variable translation and transport detection utility module that Phase 10 adapters will consume.

Purpose: Codex does not support `${VAR}` interpolation in config.toml -- variables must be expanded to literal values in an `env` map at sync time. Gemini supports `${VAR}` natively and needs no translation. This module provides the translation pipeline and transport compatibility checking shared by all adapters.

Output: `src/utils/env_translator.py` with functions for Codex env var translation, Gemini passthrough, and transport type detection/validation.
</objective>

<execution_context>
@${CLAUDE_PLUGIN_ROOT}/references/execute-plan.md
@${CLAUDE_PLUGIN_ROOT}/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-scope-aware-target-sync-environment-translation/10-RESEARCH.md

# Source files
@src/utils/toml_writer.py
@src/utils/paths.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement environment variable translator for Codex</name>
  <files>src/utils/env_translator.py</files>
  <action>
    Create `src/utils/env_translator.py` with the following functions:

    1. **`translate_env_vars_for_codex(config: dict) -> tuple[dict, list[str]]`**
       - Takes a Claude Code MCP server config dict
       - Returns (translated_config, warnings) tuple
       - Uses regex `r'\$\{([A-Z_][A-Z0-9_]*)(:-([^}]+))?\}'` to find env var references
       - Scans all string values in: `command`, `url`, `args` (list items), and `env` dict values
       - For each `${VAR}` found:
         - Read value from `os.environ.get(var_name)`
         - If found: add to extracted env_map, replace in string with resolved value
         - If not found and no default: append warning "ENV var ${VAR} not set and no default provided", replace with empty string
       - For each `${VAR:-default}` found:
         - Read value from `os.environ.get(var_name)`
         - If found: add to env_map, replace in string
         - If not found: append warning "ENV var ${VAR} not set, using default: {default}", use default value
       - After processing: merge extracted env_map INTO config's `env` dict (existing env entries win on key conflicts)
       - MUST deep-copy config before modification (do not mutate original)
       - Pattern constant: `VAR_PATTERN = re.compile(r'\$\{([A-Z_][A-Z0-9_]*)(:-([^}]+))?\}')`

    2. **`preserve_env_vars_for_gemini(config: dict) -> tuple[dict, list[str]]`**
       - Takes a Claude Code MCP server config dict
       - Returns (config, []) unchanged -- Gemini supports `${VAR}` natively (ENV-03)
       - This is an explicit passthrough for symmetry with the Codex function
       - Returns a shallow copy of config (not the same object reference)

    Module-level docstring should reference: ENV-01, ENV-02, ENV-03 requirements, Decision #13 update (was preserve, now translate for Codex).

    AVOID:
    - Lowercase env var names (use `[A-Z_][A-Z0-9_]*` pattern only per research recommendation)
    - Mutating the input config dict (always .copy() or copy.deepcopy())
    - Swallowing warnings silently (return them as list for adapter to log)
  </action>
  <verify>
    Create a quick inline test at module bottom (under `if __name__ == "__main__":`) that:
    1. Sets os.environ["TEST_KEY"] = "resolved_value"
    2. Calls translate_env_vars_for_codex({"command": "server", "args": ["--key", "${TEST_KEY}"], "env": {"EXISTING": "kept"}})
    3. Asserts result config has args[1] == "resolved_value"
    4. Asserts result config has env["TEST_KEY"] == "resolved_value" AND env["EXISTING"] == "kept"
    5. Tests ${MISSING_VAR:-fallback} -> args value is "fallback", warnings list is non-empty
    6. Tests ${UNDEFINED_VAR} with no default -> warnings list has "not set" message
    7. Tests preserve_env_vars_for_gemini returns config unchanged with empty warnings

    Run: `python src/utils/env_translator.py` exits 0 with no assertion errors (Level 1: Sanity)
  </verify>
  <done>
    env_translator.py exists with translate_env_vars_for_codex() and preserve_env_vars_for_gemini().
    All inline assertions pass. ${VAR} resolves from os.environ. ${VAR:-default} uses default when unset.
    Warnings collected and returned for undefined vars.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement transport type detection and validation</name>
  <files>src/utils/env_translator.py</files>
  <action>
    Add transport detection functions to the same `src/utils/env_translator.py` module:

    1. **`detect_transport_type(config: dict) -> str`**
       - If `command` key present: return `"stdio"`
       - If `url` key present:
         - If URL ends with `/sse` or contains `sse` (case-insensitive): return `"sse"`
         - Otherwise: return `"http"`
       - If neither: return `"unknown"`

    2. **`check_transport_support(server_name: str, config: dict, target: str) -> tuple[bool, str]`**
       - Calls detect_transport_type(config) internally
       - Uses support matrix dict:
         ```
         TRANSPORT_SUPPORT = {
             "codex": {"stdio", "http"},
             "gemini": {"stdio", "http", "sse"},
             "opencode": {"stdio", "http"},
         }
         ```
       - If transport in supported set: return (True, "")
       - If transport == "unknown": return (False, f"MCP server '{server_name}': unknown transport (no command or url field)")
       - If transport not supported: return (False, f"MCP server '{server_name}': {transport.upper()} transport not supported by {target}. Supported: {', '.join(sorted(supported))}")
       - Module-level constant for TRANSPORT_SUPPORT dict

    AVOID:
    - Raising exceptions (return tuple, let caller decide)
    - Over-matching SSE (only check URL field, not command field)
  </action>
  <verify>
    Add to the existing `if __name__ == "__main__":` block:
    1. assert detect_transport_type({"command": "npx", "args": ["-y", "server"]}) == "stdio"
    2. assert detect_transport_type({"url": "https://example.com/mcp/sse"}) == "sse"
    3. assert detect_transport_type({"url": "https://api.example.com/mcp"}) == "http"
    4. assert detect_transport_type({}) == "unknown"
    5. ok, _ = check_transport_support("test", {"command": "x"}, "codex"); assert ok
    6. ok, msg = check_transport_support("sse-server", {"url": "https://x/sse"}, "codex"); assert not ok; assert "SSE" in msg
    7. ok, _ = check_transport_support("sse-server", {"url": "https://x/sse"}, "gemini"); assert ok

    Run: `python src/utils/env_translator.py` exits 0 (Level 1: Sanity)
  </verify>
  <done>
    detect_transport_type() and check_transport_support() added to env_translator.py.
    Transport support matrix covers codex (stdio+http), gemini (stdio+http+sse), opencode (stdio+http).
    SSE on Codex returns (False, warning_with_server_name). All inline assertions pass.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- `python src/utils/env_translator.py` runs inline assertions (env var translation + transport detection)
- Module imports cleanly: `python -c "from src.utils.env_translator import translate_env_vars_for_codex, detect_transport_type"`
</verification>

<success_criteria>
- src/utils/env_translator.py exists with 4 public functions
- translate_env_vars_for_codex handles ${VAR} and ${VAR:-default} patterns
- preserve_env_vars_for_gemini passes config through unchanged
- detect_transport_type correctly identifies stdio/sse/http/unknown
- check_transport_support validates against per-target matrix
- All inline tests pass on `python src/utils/env_translator.py`
</success_criteria>

<output>
After completion, create `.planning/phases/10-scope-aware-target-sync-environment-translation/10-01-SUMMARY.md`
</output>
