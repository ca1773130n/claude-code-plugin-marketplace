---
phase: 11-state-enhancements-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/state_manager.py, src/orchestrator.py]
autonomous: true
verification_level: proxy

must_haves:
  truths:
    - "StateManager has record_plugin_sync() that persists plugin metadata to state.json plugins section"
    - "StateManager has detect_plugin_drift() returning dict of plugin_name -> drift reason (version_changed, mcp_count_changed, added, removed)"
    - "record_plugin_sync() replaces entire plugins section (no stale accumulation from removed plugins)"
    - "Orchestrator extracts plugin metadata from mcp_scoped data after successful sync and calls record_plugin_sync()"
    - "Plugin metadata includes version, mcp_count, mcp_servers list, and last_sync timestamp per plugin"
  artifacts:
    - path: "src/state_manager.py"
      provides: "Plugin tracking methods (record_plugin_sync, detect_plugin_drift, get_plugin_status)"
    - path: "src/orchestrator.py"
      provides: "Plugin metadata extraction and state recording after sync"
  key_links:
    - from: "src/orchestrator.py"
      to: "src/state_manager.py"
      via: "record_plugin_sync() call in _update_state()"
      pattern: "record_plugin_sync"
    - from: "src/state_manager.py"
      to: "src/source_reader.py"
      via: "detect_plugin_drift() uses SourceReader to get current plugin state"
      pattern: "SourceReader|get_mcp_servers_with_scope"
---

<objective>
Extend StateManager with plugin version tracking and drift detection, and integrate plugin metadata persistence into the sync orchestrator.

Purpose: Enable HarnessSync to detect when installed Claude Code plugins have been updated (version changes, MCP count changes) so users can be warned about plugin drift and re-sync when needed. This satisfies requirements STATE-01 (plugin tracking schema) and STATE-03 (plugin drift detection).

Output: StateManager with record_plugin_sync(), detect_plugin_drift(), and get_plugin_status() methods; orchestrator that automatically persists plugin metadata after each successful sync.
</objective>

<execution_context>
@${CLAUDE_PLUGIN_ROOT}/references/execute-plan.md
@${CLAUDE_PLUGIN_ROOT}/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-state-enhancements-integration/11-RESEARCH.md

# Source files being modified
@src/state_manager.py
@src/orchestrator.py

# Phase 9 output format (provides mcp_servers_scoped metadata)
@.planning/phases/09-plugin-discovery-scope-aware-source-reading/09-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add plugin tracking methods to StateManager</name>
  <files>src/state_manager.py</files>
  <action>
    Add three new methods to StateManager class:

    1. **record_plugin_sync(self, plugins_metadata: dict, account: str = None)**
       - Accepts dict from plugin metadata extraction: {plugin_name: {version, mcp_count, mcp_servers: [list], last_sync}}
       - If account is not None: store under self._state["accounts"][account]["plugins"]
       - If account is None: store under self._state["plugins"] (flat, v1 compat)
       - REPLACE entire plugins section on each call (do NOT merge) to avoid stale entries from uninstalled plugins (per research Pitfall 2)
       - Call self._save() after updating

    2. **detect_plugin_drift(self, current_plugins: dict, account: str = None) -> dict**
       - Accept current_plugins dict (same format as record_plugin_sync input)
       - Load stored plugins from appropriate location (account-scoped or flat)
       - Compare stored vs current for each plugin:
         - Plugin in stored but not current: drift[name] = "removed"
         - Plugin in current but not stored: drift[name] = "added"
         - Version changed: drift[name] = "version_changed: {old} -> {new}"
         - MCP count changed: drift[name] = "mcp_count_changed: {old} -> {new}"
         - Both version AND mcp_count changed: report version_changed (version is higher priority)
       - Return dict mapping plugin_name -> drift reason string (empty dict = no drift)
       - NOTE: This method does NOT call SourceReader - the caller passes current_plugins to avoid coupling

    3. **get_plugin_status(self, account: str = None) -> dict**
       - Return stored plugins dict from appropriate location (account-scoped or flat)
       - Return empty dict if no plugins tracked yet

    Implementation notes:
    - Follow existing atomic write pattern (self._save() already handles this)
    - Follow existing account-scoped nesting pattern (see record_sync for reference)
    - Use .get() with defaults throughout (metadata.get("source") pattern from research)
    - Do NOT import SourceReader in state_manager.py - keep it decoupled
  </action>
  <verify>
    python -c "
import tempfile, json
from pathlib import Path
from src.state_manager import StateManager

# Test 1: record_plugin_sync (flat)
td = tempfile.mkdtemp()
sm = StateManager(state_dir=Path(td))
plugins = {
    'context7': {'version': '1.2.0', 'mcp_count': 2, 'mcp_servers': ['browse', 'query'], 'last_sync': '2024-01-01'},
    'grd': {'version': '0.3.1', 'mcp_count': 1, 'mcp_servers': ['research'], 'last_sync': '2024-01-01'}
}
sm.record_plugin_sync(plugins)
state = json.loads(Path(td, 'state.json').read_text())
assert 'plugins' in state
assert state['plugins']['context7']['version'] == '1.2.0'
assert state['plugins']['context7']['mcp_count'] == 2
assert state['plugins']['grd']['mcp_count'] == 1
print('PASS: record_plugin_sync (flat)')

# Test 2: record_plugin_sync (account-scoped)
sm2 = StateManager(state_dir=Path(td))
sm2.record_plugin_sync(plugins, account='work')
state2 = json.loads(Path(td, 'state.json').read_text())
assert state2['accounts']['work']['plugins']['context7']['version'] == '1.2.0'
print('PASS: record_plugin_sync (account-scoped)')

# Test 3: detect_plugin_drift - version change
sm3 = StateManager(state_dir=Path(td))
sm3.record_plugin_sync(plugins)
updated = {'context7': {'version': '1.3.0', 'mcp_count': 2, 'mcp_servers': ['browse', 'query'], 'last_sync': '2024-01-02'},
           'grd': {'version': '0.3.1', 'mcp_count': 1, 'mcp_servers': ['research'], 'last_sync': '2024-01-02'}}
drift = sm3.detect_plugin_drift(updated)
assert 'context7' in drift
assert 'version_changed' in drift['context7']
assert 'grd' not in drift
print('PASS: detect_plugin_drift - version change')

# Test 4: detect_plugin_drift - mcp count change
updated2 = {'context7': {'version': '1.2.0', 'mcp_count': 3, 'mcp_servers': ['browse', 'query', 'new'], 'last_sync': '2024-01-02'},
            'grd': {'version': '0.3.1', 'mcp_count': 1, 'mcp_servers': ['research'], 'last_sync': '2024-01-02'}}
drift2 = sm3.detect_plugin_drift(updated2)
assert 'mcp_count_changed' in drift2['context7']
print('PASS: detect_plugin_drift - mcp count change')

# Test 5: detect_plugin_drift - plugin added/removed
updated3 = {'context7': {'version': '1.2.0', 'mcp_count': 2, 'mcp_servers': ['browse', 'query'], 'last_sync': '2024-01-02'},
            'new-plugin': {'version': '1.0.0', 'mcp_count': 1, 'mcp_servers': ['tool'], 'last_sync': '2024-01-02'}}
drift3 = sm3.detect_plugin_drift(updated3)
assert drift3.get('grd') == 'removed'
assert drift3.get('new-plugin') == 'added'
print('PASS: detect_plugin_drift - added/removed')

# Test 6: get_plugin_status
status = sm3.get_plugin_status()
assert 'context7' in status
assert status['context7']['version'] == '1.2.0'
print('PASS: get_plugin_status')

# Test 7: Replacement (no stale accumulation)
sm3.record_plugin_sync({'context7': {'version': '1.2.0', 'mcp_count': 2, 'mcp_servers': ['browse', 'query'], 'last_sync': '2024-01-02'}})
status2 = sm3.get_plugin_status()
assert 'grd' not in status2  # grd was removed by replacement
print('PASS: Replacement clears stale plugins')

import shutil
shutil.rmtree(td)
print('ALL 7 CHECKS PASSED')
" (Level 2: Proxy)
  </verify>
  <done>
    StateManager has record_plugin_sync(), detect_plugin_drift(), and get_plugin_status() methods.
    Plugin metadata persists to state.json with proper account-scoped nesting.
    Drift detection catches version changes, MCP count changes, added and removed plugins.
    Replacement semantics prevent stale plugin accumulation.
    All 7 verification checks pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate plugin metadata persistence into orchestrator</name>
  <files>src/orchestrator.py</files>
  <action>
    Extend SyncOrchestrator._update_state() to extract and persist plugin metadata:

    1. **Add _extract_plugin_metadata() private method:**
       - Accept mcp_scoped dict (from source_data['mcp_servers_scoped'])
       - Iterate entries, filter to source == "plugin"
       - Group by plugin_name, collecting: version, mcp_servers list, mcp_count
       - Add last_sync: datetime.now().isoformat() per plugin
       - Return plugins dict: {plugin_name: {version, mcp_count, mcp_servers, last_sync}}
       - Import datetime at top of method (from datetime import datetime) - it's already imported in state_manager.py

    2. **Update _update_state() method:**
       - After the for loop that calls record_sync() for each target, add:
       - Call reader.discover_all() to get source_data (reader is already a parameter)
       - Extract mcp_scoped from source_data.get('mcp_servers_scoped', {})
       - Call self._extract_plugin_metadata(mcp_scoped)
       - If plugins_metadata is non-empty, call self.state_manager.record_plugin_sync(plugins_metadata, account=self.account)
       - IMPORTANT: Record plugin metadata AFTER successful target syncs (per research Pitfall 1)

    3. **Optimization: avoid double discover_all():**
       - In sync_all(), source_data is already computed before adapter sync
       - Pass source_data to _update_state() as additional parameter instead of re-calling reader.discover_all()
       - Update _update_state() signature: def _update_state(self, results, reader, source_data=None)
       - If source_data not passed, fall back to reader.discover_all()

    Implementation notes:
    - Keep the from datetime import datetime as a module-level import if not already present, or local import in method
    - Use metadata.get("source") == "plugin" pattern (safe .get with default)
    - Use metadata.get("plugin_name", "unknown") pattern for missing fields
  </action>
  <verify>
    python -c "
import tempfile, json, os
from pathlib import Path
from unittest.mock import patch, MagicMock

# Setup temp dirs
td = tempfile.mkdtemp()
project_dir = Path(td) / 'project'
project_dir.mkdir()
cc_home = Path(td) / 'claude_home'
cc_home.mkdir()

# Create minimal Claude config
(cc_home / '.claude.json').write_text(json.dumps({'mcpServers': {}}))

# Create state dir
state_dir = Path(td) / 'harnesssync'
state_dir.mkdir()

os.environ['CLAUDE_PROJECT_DIR'] = str(project_dir)

from src.orchestrator import SyncOrchestrator

# Test 1: _extract_plugin_metadata
orch = SyncOrchestrator(project_dir=project_dir, cc_home=cc_home)
orch.state_manager = MagicMock()

mcp_scoped = {
    'context7-browse': {
        'config': {'command': 'npx', 'args': ['-y', 'context7']},
        'metadata': {'scope': 'user', 'source': 'plugin', 'plugin_name': 'context7', 'plugin_version': '1.2.0'}
    },
    'context7-query': {
        'config': {'command': 'npx', 'args': ['-y', 'context7']},
        'metadata': {'scope': 'user', 'source': 'plugin', 'plugin_name': 'context7', 'plugin_version': '1.2.0'}
    },
    'user-server': {
        'config': {'command': 'my-server'},
        'metadata': {'scope': 'user', 'source': 'file'}
    }
}

plugins = orch._extract_plugin_metadata(mcp_scoped)
assert 'context7' in plugins
assert plugins['context7']['version'] == '1.2.0'
assert plugins['context7']['mcp_count'] == 2
assert len(plugins['context7']['mcp_servers']) == 2
assert 'user-server' not in str(plugins)  # File-based excluded
print('PASS: _extract_plugin_metadata filters and groups correctly')

# Test 2: Verify _extract_plugin_metadata method exists
assert hasattr(orch, '_extract_plugin_metadata')
print('PASS: _extract_plugin_metadata method exists')

# Cleanup
import shutil
shutil.rmtree(td)
del os.environ['CLAUDE_PROJECT_DIR']
print('ALL 2 CHECKS PASSED')
" (Level 2: Proxy)
  </verify>
  <done>
    Orchestrator extracts plugin metadata from mcp_scoped data after sync.
    _extract_plugin_metadata() correctly filters plugin-sourced MCPs and groups by plugin_name.
    _update_state() calls record_plugin_sync() after successful target sync.
    Plugin metadata flows: SourceReader -> orchestrator -> StateManager -> state.json.
    All 2 verification checks pass.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity): StateManager methods exist and accept correct parameter types
Level 2 (Proxy): 9 checks total â€” plugin record/retrieve, drift detection (version, count, add, remove), replacement semantics, orchestrator extraction
Level 3 (Deferred): Real plugin update in live Claude Code session triggers drift detection
</verification>

<success_criteria>
1. StateManager.record_plugin_sync() persists plugin metadata to state.json
2. StateManager.detect_plugin_drift() detects version changes, MCP count changes, additions, and removals
3. StateManager.get_plugin_status() returns stored plugin data
4. SyncOrchestrator._update_state() extracts and records plugin metadata after successful sync
5. No stale plugin accumulation (replacement semantics)
6. Account-scoped plugin tracking works correctly
7. All 9 verification checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-state-enhancements-integration/11-01-SUMMARY.md`
</output>
