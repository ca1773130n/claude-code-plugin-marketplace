---
phase: 11-state-enhancements-integration
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified: [src/commands/sync_status.py, verify_phase11_integration.py]
autonomous: true
verification_level: proxy

must_haves:
  truths:
    - "/sync-status displays MCP servers grouped by source: User-configured, Project-configured, Local-configured, Plugin-provided"
    - "/sync-status Plugin-provided section shows plugin_name@version with MCP server list and scope labels"
    - "/sync-status shows Plugin Drift section when detect_plugin_drift() returns non-empty results"
    - "Plugin drift warning displayed as informational (warn-only, no auto-sync per research recommendation)"
    - "Integration test simulates plugin version update (1.0.0 -> 1.1.0) and verifies drift detection"
    - "Full pipeline test validates 3 plugins, 2 user MCPs, 1 project MCP, 1 local MCP with correct scoping and drift"
  artifacts:
    - path: "src/commands/sync_status.py"
      provides: "MCP grouping by source with scope labels and plugin drift display"
    - path: "verify_phase11_integration.py"
      provides: "Integration test for plugin update simulation and full v2.0 pipeline"
  key_links:
    - from: "src/commands/sync_status.py"
      to: "src/state_manager.py"
      via: "detect_plugin_drift() and get_plugin_status() calls"
      pattern: "detect_plugin_drift|get_plugin_status"
    - from: "src/commands/sync_status.py"
      to: "src/source_reader.py"
      via: "get_mcp_servers_with_scope() for current MCP discovery with metadata"
      pattern: "get_mcp_servers_with_scope"
---

<objective>
Refactor /sync-status to display MCP servers grouped by source (user/project/local/plugin) with scope labels, add plugin drift warnings, and create integration tests verifying the full Phase 11 and v2.0 pipeline.

Purpose: Enable users to see at a glance which MCP servers come from plugins vs user configuration, detect plugin version changes, and validate the complete v2.0 feature set end-to-end. This satisfies requirements STATE-02 (grouped MCP display) and success criteria #3, #4, #6, #7.

Output: Enhanced /sync-status with MCP source grouping and plugin drift display; integration test script verifying plugin update simulation and full v2.0 pipeline.
</objective>

<execution_context>
@${CLAUDE_PLUGIN_ROOT}/references/execute-plan.md
@${CLAUDE_PLUGIN_ROOT}/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-state-enhancements-integration/11-RESEARCH.md

# Plan 01 output (StateManager plugin methods)
@.planning/phases/11-state-enhancements-integration/11-01-SUMMARY.md

# Source files being modified
@src/commands/sync_status.py
@src/state_manager.py
@src/source_reader.py
@src/orchestrator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MCP source grouping and plugin drift to /sync-status</name>
  <files>src/commands/sync_status.py</files>
  <action>
    Refactor /sync-status to display MCP servers grouped by source and plugin drift warnings:

    1. **Add _group_mcps_by_source(mcp_servers_scoped: dict) -> dict helper function:**
       - Accept mcp_servers_scoped dict from SourceReader.get_mcp_servers_with_scope()
       - Group servers into: {"user": [], "project": [], "local": [], "plugins": {}}
       - For plugin servers: group by "plugin_name@plugin_version" key
       - Each entry stores (server_name, scope) tuple
       - File-based servers go into user/project/local lists based on metadata.scope

    2. **Add _format_mcp_groups(groups: dict) -> list[str] helper function:**
       - Accept output from _group_mcps_by_source()
       - Format as indented text lines per research display format:
         - "  MCP Servers:" header
         - "    User-configured (N):" with "      - server_name (user)" per server
         - "    Project-configured (N):" with "      - server_name (project)" per server
         - "    Local-configured (N):" with "      - server_name (local)" per server
         - "    Plugin-provided:" with "      plugin_name@version (N):" and "        - server_name (scope)" per server
       - Truncate each group to 10 servers with "... and N more" suffix (per research)
       - Plugin sub-groups truncate to 5 servers
       - Return list of formatted lines

    3. **Add _format_plugin_drift(drift: dict) -> list[str] helper function:**
       - Accept drift dict from StateManager.detect_plugin_drift()
       - If empty, return empty list (no output)
       - Otherwise format as:
         - "  Plugin Drift:" header
         - "    - plugin_name: drift_reason" per entry
       - Return list of formatted lines

    4. **Add _extract_current_plugins(mcp_scoped: dict) -> dict helper function:**
       - Extract current plugin metadata from mcp_scoped (same logic as orchestrator._extract_plugin_metadata)
       - Returns {plugin_name: {version, mcp_count, mcp_servers, last_sync}}
       - Used to pass current plugins to detect_plugin_drift()

    5. **Update _show_default_status() (v1 path):**
       - After creating SourceReader, call reader.get_mcp_servers_with_scope() to get scoped MCPs
       - After per-target status section (after drift detection block), add:
         - MCP source grouping: call _group_mcps_by_source(), _format_mcp_groups(), print lines
         - Plugin drift: extract current plugins, call state_manager.detect_plugin_drift(current_plugins), _format_plugin_drift(), print lines
       - Only show these sections if mcp_scoped is non-empty

    6. **Update _show_account_status(account_name) similarly:**
       - After per-target section, add MCP grouping and plugin drift display
       - Pass account parameter to detect_plugin_drift()

    Implementation notes:
    - Import SourceReader is already done at top of file
    - StateManager already imported at top of file
    - Use metadata.get() pattern throughout for safety
    - Do NOT auto-trigger re-sync on drift — just display warning (per research recommendation: conservative approach)
    - Keep existing drift detection (file hash based) intact — plugin drift is ADDITIONAL information
  </action>
  <verify>
    python -c "
import sys, os, json, tempfile
from pathlib import Path
from unittest.mock import patch, MagicMock

# Import the helper functions
sys.path.insert(0, '.')

# Test 1: _group_mcps_by_source
from src.commands.sync_status import _group_mcps_by_source
scoped = {
    'user-server': {'config': {}, 'metadata': {'scope': 'user', 'source': 'file'}},
    'project-db': {'config': {}, 'metadata': {'scope': 'project', 'source': 'file'}},
    'local-key': {'config': {}, 'metadata': {'scope': 'local', 'source': 'file'}},
    'ctx-browse': {'config': {}, 'metadata': {'scope': 'user', 'source': 'plugin', 'plugin_name': 'context7', 'plugin_version': '1.2.0'}},
    'ctx-query': {'config': {}, 'metadata': {'scope': 'user', 'source': 'plugin', 'plugin_name': 'context7', 'plugin_version': '1.2.0'}},
    'grd-research': {'config': {}, 'metadata': {'scope': 'user', 'source': 'plugin', 'plugin_name': 'grd', 'plugin_version': '0.3.1'}}
}
groups = _group_mcps_by_source(scoped)
assert 'user-server' in groups['user']
assert 'project-db' in groups['project']
assert 'local-key' in groups['local']
assert 'context7@1.2.0' in groups['plugins']
assert len(groups['plugins']['context7@1.2.0']) == 2
assert 'grd@0.3.1' in groups['plugins']
print('PASS: _group_mcps_by_source groups correctly')

# Test 2: _format_mcp_groups
from src.commands.sync_status import _format_mcp_groups
lines = _format_mcp_groups(groups)
output = '\n'.join(lines)
assert 'User-configured (1)' in output
assert 'Project-configured (1)' in output
assert 'Local-configured (1)' in output
assert 'Plugin-provided' in output
assert 'context7@1.2.0 (2)' in output
assert 'grd@0.3.1 (1)' in output
print('PASS: _format_mcp_groups formats correctly')

# Test 3: _format_plugin_drift
from src.commands.sync_status import _format_plugin_drift
drift = {'context7': 'version_changed: 1.2.0 -> 1.3.0', 'old-plugin': 'removed'}
lines = _format_plugin_drift(drift)
output = '\n'.join(lines)
assert 'Plugin Drift' in output
assert 'context7: version_changed' in output
assert 'old-plugin: removed' in output
print('PASS: _format_plugin_drift formats correctly')

# Test 4: _format_plugin_drift with empty dict
lines_empty = _format_plugin_drift({})
assert len(lines_empty) == 0
print('PASS: _format_plugin_drift empty returns no lines')

# Test 5: _extract_current_plugins
from src.commands.sync_status import _extract_current_plugins
plugins = _extract_current_plugins(scoped)
assert 'context7' in plugins
assert plugins['context7']['version'] == '1.2.0'
assert plugins['context7']['mcp_count'] == 2
assert 'grd' in plugins
assert plugins['grd']['mcp_count'] == 1
assert 'user-server' not in str(plugins.keys())
print('PASS: _extract_current_plugins extracts plugin metadata')

print('ALL 5 CHECKS PASSED')
" (Level 2: Proxy)
  </verify>
  <done>
    /sync-status helper functions implemented: _group_mcps_by_source, _format_mcp_groups, _format_plugin_drift, _extract_current_plugins.
    MCP servers grouped by source (User-configured, Project-configured, Local-configured, Plugin-provided).
    Plugin-provided section shows plugin_name@version with server list and scope labels.
    Plugin drift warnings displayed when detected.
    Truncation applied (10 per group, 5 per plugin sub-group).
    All 5 verification checks pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration test for plugin update simulation and full v2.0 pipeline</name>
  <files>verify_phase11_integration.py</files>
  <action>
    Create verify_phase11_integration.py with comprehensive integration tests:

    **Section 1: Plugin Update Simulation (Success Criteria #6)**
    Test plugin version update 1.0.0 -> 1.1.0:

    1. Create fixture state with plugin "test-plugin" at version 1.0.0, mcp_count=1
    2. Create fixture "current" plugins with version 1.1.0, mcp_count=2 (added new MCP server)
    3. Call StateManager.detect_plugin_drift() with current plugins
    4. Verify drift detected: "version_changed: 1.0.0 -> 1.1.0"
    5. Call StateManager.record_plugin_sync() with updated plugins
    6. Verify state.json updated with version 1.1.0 and mcp_count=2
    7. Call detect_plugin_drift() again with same current — verify no drift (re-sync cleared it)
    8. Verify get_plugin_status() returns updated data

    **Section 2: Full v2.0 Pipeline (Success Criteria #7)**
    Setup mock environment with:
    - 3 plugins with MCPs (context7 with 2 MCPs, grd with 1 MCP, test-plugin with 1 MCP)
    - 2 user-configured MCPs (in ~/.claude.json mcpServers)
    - 1 project-configured MCP (in .mcp.json)
    - 1 local-configured MCP (in ~/.claude.json projects section)

    Verify:
    1. SourceReader.get_mcp_servers_with_scope() discovers all 8 MCPs (100% discovery)
    2. Each MCP has correct scope label (user/project/local)
    3. Each MCP has correct source label (file/plugin)
    4. Plugin MCPs have plugin_name and plugin_version metadata
    5. _group_mcps_by_source() produces correct groupings
    6. _extract_current_plugins() produces correct plugin metadata
    7. StateManager.record_plugin_sync() + get_plugin_status() round-trips correctly
    8. Drift detection: modify one plugin version, detect drift, re-sync, verify drift clears

    **Section 3: MCP Source Grouping Display (Success Criteria #3, #4)**
    1. _format_mcp_groups() output contains "User-configured" section
    2. _format_mcp_groups() output contains "Project-configured" section
    3. _format_mcp_groups() output contains "Plugin-provided" section with plugin@version
    4. _format_plugin_drift() output contains drift warnings when drift exists
    5. _format_plugin_drift() output is empty when no drift

    **Section 4: Account-Scoped Plugin Tracking**
    1. record_plugin_sync with account="work" stores under accounts.work.plugins
    2. detect_plugin_drift with account="work" reads from accounts.work.plugins
    3. get_plugin_status with account="work" returns account-scoped data

    Use unittest.mock.patch for Path.home() isolation (same pattern as verify_phase10_integration.py).
    Use tempdir for state files.
    Print pass/fail for each check with running count.
    Exit 0 on all pass, exit 1 on any failure.
  </action>
  <verify>
    python verify_phase11_integration.py (Level 2: Proxy)
    Expected: All checks pass with exit code 0
  </verify>
  <done>
    Integration test covers all 7 Phase 11 success criteria:
    1. StateManager plugin tracking schema (record/retrieve)
    2. Plugin version change detection and re-sync trigger (warn-only)
    3. /sync-status MCP grouping by source
    4. /sync-status plugin@version display format
    5. Plugin drift detection (version, count, add, remove)
    6. Plugin update simulation (1.0.0 -> 1.1.0 with new MCP)
    7. Full pipeline: 3 plugins, 2 user, 1 project, 1 local MCPs
    All checks pass with exit code 0.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity): Helper functions exist and accept correct types
Level 2 (Proxy): 5 sync-status checks + full integration test (estimated 25-30 checks total)
Level 3 (Deferred): Real /sync-status in live Claude Code session with actual plugins installed
</verification>

<success_criteria>
1. /sync-status displays MCPs grouped by source (User-configured, Project-configured, Local-configured, Plugin-provided)
2. Plugin-provided section shows plugin_name@version with server list
3. Plugin drift warnings displayed when version or MCP count changes detected
4. Integration test simulates plugin update (1.0.0 -> 1.1.0) and verifies drift detection + clearance
5. Full pipeline test validates 3 plugins + 2 user + 1 project + 1 local MCPs end-to-end
6. Account-scoped plugin tracking verified
7. All verification checks pass (estimated 30-35 total)
</success_criteria>

<output>
After completion, create `.planning/phases/11-state-enhancements-integration/11-02-SUMMARY.md`
</output>
