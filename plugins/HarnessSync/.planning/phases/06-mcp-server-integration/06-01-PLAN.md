---
phase: 06-mcp-server-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/mcp/__init__.py
  - src/mcp/transport.py
  - src/mcp/protocol.py
  - src/mcp/schemas.py
autonomous: true
verification_level: sanity

must_haves:
  truths:
    - "StdioTransport reads JSON-RPC requests from stdin and writes responses to stdout with flush"
    - "StdioTransport never writes to stdout except valid JSON-RPC messages (logging uses stderr only)"
    - "Protocol handler routes initialize, tools/list, tools/call, and notifications correctly"
    - "Protocol handler returns proper JSON-RPC 2.0 error codes (-32700 parse, -32600 invalid, -32601 method not found, -32602 invalid params, -32603 internal)"
    - "Schemas define inputSchema for sync_all (no params), sync_target (target: enum string), get_status (no params)"
    - "Manual validation functions accept valid params and reject invalid params with clear error messages"
  artifacts:
    - path: "src/mcp/__init__.py"
      provides: "Package marker for MCP module"
    - path: "src/mcp/transport.py"
      provides: "Stdio transport with read_message/write_response/write_error"
      min_lines: 40
    - path: "src/mcp/protocol.py"
      provides: "JSON-RPC 2.0 message routing and error construction"
      min_lines: 80
    - path: "src/mcp/schemas.py"
      provides: "Tool definitions with inputSchema and manual validation functions"
      min_lines: 80
  key_links:
    - from: "src/mcp/protocol.py"
      to: "src/mcp/transport.py"
      via: "import and delegation for message I/O"
      pattern: "from.*transport.*import"
    - from: "src/mcp/protocol.py"
      to: "src/mcp/schemas.py"
      via: "import for tools/list response"
      pattern: "from.*schemas.*import"
---

<objective>
Implement the MCP protocol foundation: stdio transport layer, JSON-RPC 2.0 message handling, and tool schema definitions with manual validation.

Purpose: Establish the protocol infrastructure that Plan 06-02 will wire to the SyncOrchestrator. This layer handles all JSON-RPC serialization, message routing, and input validation so the tool handlers can focus purely on business logic.

Output: Four files forming the `src/mcp/` package — transport, protocol, schemas, and package init.
</objective>

<execution_context>
@${CLAUDE_PLUGIN_ROOT}/references/execute-plan.md
@${CLAUDE_PLUGIN_ROOT}/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-mcp-server-integration/06-RESEARCH.md
@plugin.json
@src/lock.py
@src/orchestrator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement stdio transport and JSON-RPC 2.0 protocol handler</name>
  <files>src/mcp/__init__.py, src/mcp/transport.py, src/mcp/protocol.py</files>
  <action>
    Create `src/mcp/` package directory.

    **src/mcp/__init__.py:**
    - Empty package marker (just a docstring describing the MCP server package)

    **src/mcp/transport.py — StdioTransport class:**
    - CRITICAL: Configure `logging.basicConfig(stream=sys.stderr)` at module level — stdout is the JSON-RPC protocol channel, NEVER write anything else to it
    - `read_message()`: Read one line from `sys.stdin.readline()`, return `None` on EOF, parse with `json.loads()`, raise `json.JSONDecodeError` on bad input
    - `write_response(response: dict)`: Serialize with `json.dumps(response)`, write to `sys.stdout`, append `\n`, call `sys.stdout.flush()` — flush is CRITICAL to prevent buffering delays (see research Pitfall 3)
    - `write_error(request_id, code: int, message: str)`: Construct JSON-RPC 2.0 error envelope `{"jsonrpc": "2.0", "id": request_id, "error": {"code": code, "message": message}}` and call `write_response()`
    - Use `sys.stdout.write()` not `print()` to avoid any extra newline/formatting issues

    **src/mcp/protocol.py — ProtocolHandler class:**
    - Constructor takes `transport: StdioTransport`
    - `handle_message(raw: dict) -> dict | None`: Route based on `raw.get("method")`:
      - `"initialize"` → `_handle_initialize(request_id, params)`
      - `"initialized"` → return `None` (notification, no response needed)
      - `"tools/list"` → `_handle_tools_list(request_id, params)`
      - `"tools/call"` → `_handle_tools_call(request_id, params)` (returns dict to be handled by caller — this is the hook point for Plan 06-02)
      - `"notifications/cancelled"` → return `None` (notification, no response)
      - Unknown method → return JSON-RPC error with code `-32601` ("Method not found")
      - Missing `"method"` key → return JSON-RPC error with code `-32600` ("Invalid Request")
    - `_handle_initialize(request_id, params)`: Return JSON-RPC success response with `result.protocolVersion = "2024-11-05"`, `result.capabilities = {"tools": {}}`, `result.serverInfo = {"name": "harnesssync", "version": "1.0.0"}`
    - `_handle_tools_list(request_id, params)`: Import tool definitions from schemas module, return JSON-RPC success with `result.tools = [list of tool defs]`
    - `make_success(request_id, result: dict) -> dict`: Construct `{"jsonrpc": "2.0", "id": request_id, "result": result}`
    - `make_error(request_id, code: int, message: str) -> dict`: Construct `{"jsonrpc": "2.0", "id": request_id, "error": {"code": code, "message": message}}`
    - `make_tool_result(content_text: str, is_error: bool = False) -> dict`: Construct MCP tool result `{"content": [{"type": "text", "text": content_text}], "isError": is_error}`

    JSON-RPC 2.0 error codes to define as module constants:
    - `PARSE_ERROR = -32700`
    - `INVALID_REQUEST = -32600`
    - `METHOD_NOT_FOUND = -32601`
    - `INVALID_PARAMS = -32602`
    - `INTERNAL_ERROR = -32603`
  </action>
  <verify>
    Verify in Python REPL:
    1. `from src.mcp.transport import StdioTransport` — imports without error
    2. `from src.mcp.protocol import ProtocolHandler, PARSE_ERROR, METHOD_NOT_FOUND` — imports without error
    3. `p = ProtocolHandler(None); r = p.handle_message({"jsonrpc": "2.0", "method": "initialize", "id": 1, "params": {}})` — returns dict with `result.capabilities.tools`
    4. `r = p.handle_message({"jsonrpc": "2.0", "method": "unknown", "id": 2})` — returns error with code -32601
    5. `r = p.handle_message({"jsonrpc": "2.0", "id": 3})` — returns error with code -32600 (missing method)
    (Level 1: Sanity)
  </verify>
  <done>
    StdioTransport reads/writes JSON-RPC via stdin/stdout with proper flushing. ProtocolHandler routes all MCP methods and returns correct JSON-RPC 2.0 responses including initialize handshake with capabilities.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement tool schemas with manual input validation</name>
  <files>src/mcp/schemas.py</files>
  <action>
    **src/mcp/schemas.py — Tool definitions and validators:**

    Define three tool schemas as dicts matching MCP tool definition format:

    **SYNC_ALL_TOOL:**
    ```python
    {
        "name": "sync_all",
        "description": "Sync all Claude Code configuration to all registered target CLIs (Codex, Gemini, OpenCode). Returns structured results with per-target sync counts and any errors.",
        "inputSchema": {
            "type": "object",
            "properties": {
                "dry_run": {
                    "type": "boolean",
                    "description": "Preview changes without writing files",
                    "default": False
                },
                "allow_secrets": {
                    "type": "boolean",
                    "description": "Allow sync even when secrets detected in env vars",
                    "default": False
                }
            },
            "required": []
        }
    }
    ```

    **SYNC_TARGET_TOOL:**
    ```python
    {
        "name": "sync_target",
        "description": "Sync Claude Code configuration to a specific target CLI. Returns structured sync results for the specified target.",
        "inputSchema": {
            "type": "object",
            "properties": {
                "target": {
                    "type": "string",
                    "description": "Target CLI to sync to",
                    "enum": ["codex", "gemini", "opencode"]
                },
                "dry_run": {
                    "type": "boolean",
                    "description": "Preview changes without writing files",
                    "default": False
                },
                "allow_secrets": {
                    "type": "boolean",
                    "description": "Allow sync even when secrets detected in env vars",
                    "default": False
                }
            },
            "required": ["target"]
        }
    }
    ```

    **GET_STATUS_TOOL:**
    ```python
    {
        "name": "get_status",
        "description": "Get sync status for all targets including last sync time, file counts, and drift detection (config modified outside HarnessSync).",
        "inputSchema": {
            "type": "object",
            "properties": {},
            "required": []
        }
    }
    ```

    **Module-level list:** `TOOLS = [SYNC_ALL_TOOL, SYNC_TARGET_TOOL, GET_STATUS_TOOL]`

    **Validation functions (manual, since no stdlib JSON Schema validator):**

    `validate_sync_all_params(arguments: dict) -> dict`:
    - `arguments` may be `None` or `{}` (both valid, use defaults)
    - If `arguments` is not None and not a dict, raise `ValueError("Arguments must be an object")`
    - Extract `dry_run` (default `False`), validate is bool if present
    - Extract `allow_secrets` (default `False`), validate is bool if present
    - Return normalized dict `{"dry_run": bool, "allow_secrets": bool}`

    `validate_sync_target_params(arguments: dict) -> dict`:
    - If `arguments` is None or not a dict, raise `ValueError("Arguments must be an object")`
    - If `"target"` not in arguments, raise `ValueError("Missing required parameter: target")`
    - If target not a string, raise `ValueError("Parameter 'target' must be a string")`
    - If target not in `["codex", "gemini", "opencode"]`, raise `ValueError(f"Invalid target: {target}. Must be one of: codex, gemini, opencode")`
    - Extract `dry_run` and `allow_secrets` with same validation as sync_all
    - Return normalized dict `{"target": str, "dry_run": bool, "allow_secrets": bool}`

    `validate_get_status_params(arguments: dict) -> dict`:
    - Accept any input (no required params)
    - Return empty dict `{}`

    **Lookup dict:** `VALIDATORS = {"sync_all": validate_sync_all_params, "sync_target": validate_sync_target_params, "get_status": validate_get_status_params}`
  </action>
  <verify>
    Verify in Python REPL:
    1. `from src.mcp.schemas import TOOLS, VALIDATORS` — imports without error
    2. `len(TOOLS) == 3` — three tools defined
    3. `all("inputSchema" in t for t in TOOLS)` — all have schemas
    4. `VALIDATORS["sync_target"]({"target": "codex"})` — returns `{"target": "codex", "dry_run": False, "allow_secrets": False}`
    5. `VALIDATORS["sync_target"]({})` — raises ValueError with "Missing required parameter: target"
    6. `VALIDATORS["sync_target"]({"target": "invalid"})` — raises ValueError with "Invalid target"
    7. `VALIDATORS["sync_all"](None)` — returns defaults `{"dry_run": False, "allow_secrets": False}`
    8. `VALIDATORS["sync_all"]({"dry_run": True})` — returns `{"dry_run": True, "allow_secrets": False}`
    9. `json.dumps(TOOLS)` — serializes without error (valid JSON)
    (Level 1: Sanity)
  </verify>
  <done>
    Three MCP tool definitions with inputSchema conform to MCP spec. Manual validators accept valid inputs and reject invalid inputs with clear error messages. All schemas serializable to JSON.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- All four files exist and import without errors
- ProtocolHandler routes initialize/tools-list/unknown methods correctly
- Tool schemas are valid JSON-serializable dicts with inputSchema
- Validators accept valid params and reject invalid params with ValueError
- No stdout pollution (logging configured to stderr)

Level 2 (Proxy): Deferred to Plan 06-02 (needs server + tool handlers wired)

Level 3 (Deferred): Integration with Claude Code MCP client
</verification>

<success_criteria>
1. `src/mcp/` package exists with 4 files (init, transport, protocol, schemas)
2. StdioTransport handles read/write/error with proper flush and stderr-only logging
3. ProtocolHandler correctly routes all MCP methods and returns valid JSON-RPC 2.0 responses
4. Three tool schemas defined with inputSchema matching MCP specification
5. Manual validation functions enforce required params, type checking, and enum constraints
6. All JSON-RPC 2.0 error codes defined as constants
</success_criteria>

<output>
After completion, create `.planning/phases/06-mcp-server-integration/06-01-SUMMARY.md`
</output>
