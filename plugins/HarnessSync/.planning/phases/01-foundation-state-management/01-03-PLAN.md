---
phase: 01-foundation-state-management
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/source_reader.py
autonomous: true
verification_level: sanity

must_haves:
  truths:
    - "SourceReader.get_rules() returns combined CLAUDE.md content from user and project scope with section headers"
    - "SourceReader.get_skills() discovers skills from user dir, plugin cache (installed_plugins.json), and project .claude/skills/"
    - "SourceReader.get_agents() discovers .md files from user and project .claude/agents/"
    - "SourceReader.get_commands() discovers .md files from user and project .claude/commands/"
    - "SourceReader.get_mcp_servers() reads from ~/.mcp.json, ~/.claude/.mcp.json, and project .mcp.json"
    - "SourceReader.get_settings() merges settings.json and settings.local.json with local taking precedence"
    - "All discovery methods handle missing directories/files gracefully (return empty, no crash)"
  artifacts:
    - path: "src/source_reader.py"
      provides: "Claude Code configuration discovery across user and project scopes"
      exports: ["SourceReader"]
      min_lines: 120
  key_links:
    - from: "src/source_reader.py"
      to: "src/utils/paths.py"
      via: "import read_json_safe for JSON config reading"
      pattern: "from.*utils.*import.*read_json_safe"
---

<objective>
Implement the SourceReader class that discovers all 6 types of Claude Code configuration (rules, skills, agents, commands, MCP servers, settings) from both user scope (~/.claude/) and project scope (.claude/, CLAUDE.md). This covers requirements SRC-01 through SRC-06.

Purpose: The source reader is the input side of the sync pipeline. Every adapter (Phase 2+) depends on it to discover what needs to be synced. The existing cc2all-sync.py has working discovery functions (get_cc_rules, get_cc_skills, etc.) -- this task refactors them into a proper class with consistent interface and better error handling.

Output: src/source_reader.py with SourceReader class providing get_rules(), get_skills(), get_agents(), get_commands(), get_mcp_servers(), get_settings().

Research basis: Existing cc2all-sync.py patterns (lines 172-323) with enhancements for robustness and type safety.
</objective>

<execution_context>
@.planning/phases/01-foundation-state-management/01-RESEARCH.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@cc2all-sync.py
@.planning/phases/01-foundation-state-management/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SourceReader with all 6 discovery methods</name>
  <files>src/source_reader.py</files>
  <action>
    Create src/source_reader.py implementing the SourceReader class. This refactors the 6 standalone get_cc_* functions from cc2all-sync.py (lines 172-323) into a class with consistent interface.

    Class: SourceReader

    Constructor: `__init__(self, scope: str = "all", project_dir: Path = None)`
    - scope: "user" | "project" | "all"
    - project_dir: Path to project root (required when scope is "project" or "all")
    - Store Claude Code base paths as instance attributes:
      - cc_home: Path.home() / ".claude"
      - cc_settings: cc_home / "settings.json"
      - cc_plugins_registry: cc_home / "plugins" / "installed_plugins.json"
      - cc_skills: cc_home / "skills"
      - cc_agents: cc_home / "agents"
      - cc_commands: cc_home / "commands"
      - cc_mcp_global: Path.home() / ".mcp.json"
      - cc_mcp_claude: cc_home / ".mcp.json"

    Methods (each returns data for the configured scope):

    1. `get_rules(self) -> str` (SRC-01):
       - Refactor from cc2all get_cc_rules() (lines 172-192)
       - User scope: Read ~/.claude/CLAUDE.md if exists
       - Project scope: Read CLAUDE.md, CLAUDE.local.md from project root, plus .claude/CLAUDE.md
       - Combine with section headers: "# [User-level rules from ~/.claude/CLAUDE.md]" etc.
       - Join multiple rule sections with "\n\n---\n\n"
       - Return empty string if no rules found

    2. `get_skills(self) -> dict[str, Path]` (SRC-02):
       - Refactor from cc2all get_cc_skills() (lines 195-242)
       - Returns {skill_name: path_to_skill_dir}
       - User scope: Scan ~/.claude/skills/ for dirs containing SKILL.md
       - User scope: Scan plugin cache via installed_plugins.json (handle both dict and list formats for "plugins" key)
       - Project scope: Scan .claude/skills/ in project_dir
       - Use read_json_safe from src.utils.paths for all JSON reads

    3. `get_agents(self) -> dict[str, Path]` (SRC-03):
       - Refactor from cc2all get_cc_agents() (lines 245-261)
       - Returns {agent_name: path_to_md_file}
       - User scope: Scan ~/.claude/agents/ for .md files
       - Project scope: Scan .claude/agents/ in project_dir
       - Use f.stem as agent name (strip .md extension)

    4. `get_commands(self) -> dict[str, Path]` (SRC-04):
       - Refactor from cc2all get_cc_commands() (lines 265-281)
       - Returns {command_name: path_to_md_file}
       - User scope: Scan ~/.claude/commands/ for .md files
       - Project scope: Scan .claude/commands/ in project_dir
       - Use f.stem as command name

    5. `get_mcp_servers(self) -> dict[str, dict]` (SRC-05):
       - Refactor from cc2all get_cc_mcp() (lines 285-306)
       - Returns {server_name: server_config_dict}
       - User scope: Read ~/.mcp.json and ~/.claude/.mcp.json (merge, later overrides)
       - Project scope: Read .mcp.json in project_dir
       - Each config has at minimum: command, args, env (for stdio type) or url (for url type)

    6. `get_settings(self) -> dict` (SRC-06):
       - Refactor from cc2all get_cc_settings() (lines 309-323)
       - Returns merged settings dict
       - User scope: Read ~/.claude/settings.json
       - Project scope: Read .claude/settings.json, then .claude/settings.local.json (local overrides)
       - Merge via dict.update() (later files override earlier)

    7. `discover_all(self) -> dict`:
       - Convenience method that returns all 6 in a dict:
         ```python
         {
             "rules": self.get_rules(),
             "skills": self.get_skills(),
             "agents": self.get_agents(),
             "commands": self.get_commands(),
             "mcp_servers": self.get_mcp_servers(),
             "settings": self.get_settings(),
         }
         ```

    Key differences from cc2all versions:
    - Instance method instead of standalone functions (scope/project_dir stored once)
    - Use read_json_safe instead of read_json (better error handling, no Logger dependency)
    - All paths computed from instance attributes (not module-level constants)
    - Consistent return types: str for rules, dict[str, Path] for skills/agents/commands, dict for MCP/settings
    - No global Logger dependency -- this module returns data only, caller decides logging

    Imports needed:
    - `from pathlib import Path`
    - `from src.utils.paths import read_json_safe`

    Avoid:
    - Do NOT import Logger (source reader should be pure data discovery)
    - Do NOT import os.path (use pathlib exclusively)
    - Do NOT write to any files (read-only discovery)
    - Do NOT follow symlinks when iterating directories (use iterdir(), not resolve())
  </action>
  <verify>
    Run from project root (Level 1: Sanity):
    ```bash
    python3 -c "
    import tempfile, json
    from pathlib import Path
    from src.source_reader import SourceReader

    # Create a mock project structure in a temp directory
    tmp = Path(tempfile.mkdtemp())
    project = tmp / 'myproject'
    project.mkdir()

    # Create mock project-scope Claude Code configs
    claude_dir = project / '.claude'
    claude_dir.mkdir()

    # SRC-01: Rules
    (project / 'CLAUDE.md').write_text('# Project rules\nBe helpful.')
    (project / 'CLAUDE.local.md').write_text('# Local overrides\nBe fast.')
    (claude_dir / 'CLAUDE.md').write_text('# .claude rules\nBe thorough.')

    # SRC-02: Skills
    skills_dir = claude_dir / 'skills'
    skill1 = skills_dir / 'my-skill'
    skill1.mkdir(parents=True)
    (skill1 / 'SKILL.md').write_text('---\nname: my-skill\n---\nDo things.')

    # SRC-03: Agents
    agents_dir = claude_dir / 'agents'
    agents_dir.mkdir()
    (agents_dir / 'helper.md').write_text('You are a helper agent.')

    # SRC-04: Commands
    commands_dir = claude_dir / 'commands'
    commands_dir.mkdir()
    (commands_dir / 'deploy.md').write_text('Deploy the app to production.')

    # SRC-05: MCP servers
    (project / '.mcp.json').write_text(json.dumps({
        'mcpServers': {
            'filesystem': {
                'command': 'npx',
                'args': ['-y', '@anthropic/mcp-filesystem'],
                'env': {'HOME': '/Users/test'}
            },
            'remote-api': {
                'type': 'url',
                'url': 'https://api.example.com/mcp'
            }
        }
    }))

    # SRC-06: Settings
    (claude_dir / 'settings.json').write_text(json.dumps({
        'allowedTools': ['bash', 'read'],
        'env': {'DEBUG': '1'}
    }))
    (claude_dir / 'settings.local.json').write_text(json.dumps({
        'env': {'DEBUG': '0', 'LOCAL': 'true'}
    }))

    # Test with project scope only (avoids reading real user ~/.claude/)
    reader = SourceReader(scope='project', project_dir=project)

    # Test 1: Rules (SRC-01)
    rules = reader.get_rules()
    assert 'Project rules' in rules, f'Missing project rules in: {rules[:100]}'
    assert 'Local overrides' in rules, f'Missing local rules in: {rules[:100]}'
    assert '.claude rules' in rules, f'Missing .claude rules in: {rules[:100]}'
    print('Test 1 PASSED: Rules discovery (SRC-01)')

    # Test 2: Skills (SRC-02)
    skills = reader.get_skills()
    assert 'my-skill' in skills, f'Missing my-skill in: {list(skills.keys())}'
    assert skills['my-skill'].is_dir()
    print('Test 2 PASSED: Skills discovery (SRC-02)')

    # Test 3: Agents (SRC-03)
    agents = reader.get_agents()
    assert 'helper' in agents, f'Missing helper in: {list(agents.keys())}'
    assert agents['helper'].suffix == '.md'
    print('Test 3 PASSED: Agents discovery (SRC-03)')

    # Test 4: Commands (SRC-04)
    commands = reader.get_commands()
    assert 'deploy' in commands, f'Missing deploy in: {list(commands.keys())}'
    print('Test 4 PASSED: Commands discovery (SRC-04)')

    # Test 5: MCP servers (SRC-05)
    mcp = reader.get_mcp_servers()
    assert 'filesystem' in mcp, f'Missing filesystem in: {list(mcp.keys())}'
    assert mcp['filesystem']['command'] == 'npx'
    assert 'remote-api' in mcp
    print('Test 5 PASSED: MCP servers discovery (SRC-05)')

    # Test 6: Settings (SRC-06)
    settings = reader.get_settings()
    assert settings.get('env', {}).get('DEBUG') == '0', 'Local should override base'
    assert settings.get('env', {}).get('LOCAL') == 'true', 'Local-only key missing'
    assert 'allowedTools' in settings
    print('Test 6 PASSED: Settings discovery (SRC-06)')

    # Test 7: discover_all
    all_config = reader.discover_all()
    assert len(all_config) == 6
    assert all(k in all_config for k in ['rules', 'skills', 'agents', 'commands', 'mcp_servers', 'settings'])
    print('Test 7 PASSED: discover_all returns all 6 types')

    # Test 8: Empty project (no configs)
    empty_project = tmp / 'empty'
    empty_project.mkdir()
    empty_reader = SourceReader(scope='project', project_dir=empty_project)
    assert empty_reader.get_rules() == ''
    assert empty_reader.get_skills() == {}
    assert empty_reader.get_agents() == {}
    assert empty_reader.get_commands() == {}
    assert empty_reader.get_mcp_servers() == {}
    assert empty_reader.get_settings() == {}
    print('Test 8 PASSED: Empty project handled gracefully')

    import shutil
    shutil.rmtree(tmp)
    print('SourceReader: ALL CHECKS PASSED')
    "
    ```
  </verify>
  <done>SourceReader class in src/source_reader.py with all 6 discovery methods (get_rules, get_skills, get_agents, get_commands, get_mcp_servers, get_settings) plus discover_all convenience method. Handles both user and project scope, gracefully handles missing directories/files. All 8 verification tests pass covering SRC-01 through SRC-06.</done>
</task>

<task type="auto">
  <name>Task 2: Handle plugin cache skill discovery and edge cases</name>
  <files>src/source_reader.py</files>
  <action>
    Enhance the SourceReader's get_skills() method to properly handle plugin cache discovery (the most complex discovery path from SRC-02) and add edge case handling across all methods.

    1. Plugin cache skills discovery in get_skills():
       - Read installed_plugins.json from cc_plugins_registry
       - Handle both dict format: {"plugins": {"name": {info}}} and list format: {"plugins": [{info}]}
       - For each plugin entry:
         - Skip if not isinstance(entry, dict)
         - Skip if entry.get("scope") != "user" (only user-scope plugins for user-scope discovery)
         - Get installPath, skip if empty
         - Scan installPath/skills/ for skill directories containing SKILL.md
       - This is already in cc2all (lines 208-233) -- refactor to instance method

    2. Edge cases for all methods:
       - get_rules(): Handle encoding errors in CLAUDE.md files (use errors='replace')
       - get_skills(): Handle symlinked skill directories (don't follow, just record path)
       - get_agents()/get_commands(): Skip non-files and hidden files (starting with .)
       - get_mcp_servers(): Handle malformed server entries (missing command/url) with skip
       - get_settings(): Handle settings files with non-dict top-level (skip with warning to stderr)

    3. Add method: `get_source_paths(self) -> dict[str, list[Path]]`:
       - Returns a mapping of config type to list of source file paths that were found
       - Useful for state tracking (hash each source file for drift detection)
       - Example return:
         ```python
         {
             "rules": [Path("~/.claude/CLAUDE.md"), Path("/project/CLAUDE.md")],
             "skills": [Path("~/.claude/skills/my-skill")],
             "agents": [Path("~/.claude/agents/helper.md")],
             "commands": [],
             "mcp_servers": [Path("~/.mcp.json"), Path("/project/.mcp.json")],
             "settings": [Path("~/.claude/settings.json")]
         }
         ```
       - This is NEW (not in cc2all) -- needed for state manager hash tracking

    Avoid:
    - Do NOT follow symlinks when resolving skill paths (store the symlink path, not the target)
    - Do NOT crash on permission errors (skip with stderr warning)
    - Do NOT import Logger (keep pure data module)
  </action>
  <verify>
    Run from project root (Level 1: Sanity):
    ```bash
    python3 -c "
    import tempfile, json
    from pathlib import Path
    from src.source_reader import SourceReader

    tmp = Path(tempfile.mkdtemp())
    project = tmp / 'project'
    project.mkdir()

    # Setup: Create project with various edge cases
    claude_dir = project / '.claude'
    claude_dir.mkdir()

    # Edge case 1: CLAUDE.md with unusual encoding chars
    (project / 'CLAUDE.md').write_text('Rules with unicode: \u00e9\u00e8\u00ea\u00eb')

    # Edge case 2: Skills with hidden files and non-skill dirs
    skills_dir = claude_dir / 'skills'
    good_skill = skills_dir / 'good-skill'
    good_skill.mkdir(parents=True)
    (good_skill / 'SKILL.md').write_text('Good skill')
    bad_dir = skills_dir / 'no-skillmd'  # dir without SKILL.md
    bad_dir.mkdir()
    (bad_dir / 'random.txt').write_text('not a skill')

    # Edge case 3: Agents with hidden file and non-md file
    agents_dir = claude_dir / 'agents'
    agents_dir.mkdir()
    (agents_dir / 'valid.md').write_text('Valid agent')
    (agents_dir / '.hidden.md').write_text('Hidden file')
    (agents_dir / 'readme.txt').write_text('Not an md file')

    # Edge case 4: MCP with malformed entry
    (project / '.mcp.json').write_text(json.dumps({
        'mcpServers': {
            'good-server': {'command': 'npx', 'args': ['server']},
            'empty-server': {}  # malformed: no command or url
        }
    }))

    # Edge case 5: Settings with non-dict content
    (claude_dir / 'settings.json').write_text(json.dumps({'key': 'value'}))

    reader = SourceReader(scope='project', project_dir=project)

    # Test 1: Unicode rules
    rules = reader.get_rules()
    assert 'unicode' in rules
    print('Test 1 PASSED: Unicode rules handled')

    # Test 2: Skills skip dirs without SKILL.md
    skills = reader.get_skills()
    assert 'good-skill' in skills
    assert 'no-skillmd' not in skills
    print('Test 2 PASSED: Skills filters correctly')

    # Test 3: Agents skip hidden and non-md files
    agents = reader.get_agents()
    assert 'valid' in agents
    assert '.hidden' not in agents
    assert 'readme' not in agents
    print('Test 3 PASSED: Agents filters correctly')

    # Test 4: MCP handles entries gracefully
    mcp = reader.get_mcp_servers()
    assert 'good-server' in mcp
    # empty-server may or may not be included (implementation choice)
    # but must not crash
    print('Test 4 PASSED: MCP handles malformed entries')

    # Test 5: get_source_paths returns file paths
    paths = reader.get_source_paths()
    assert isinstance(paths, dict)
    assert 'rules' in paths
    assert 'skills' in paths
    assert any(str(p).endswith('CLAUDE.md') for p in paths['rules'])
    print('Test 5 PASSED: get_source_paths works')

    import shutil
    shutil.rmtree(tmp)
    print('SourceReader edge cases: ALL CHECKS PASSED')
    "
    ```
  </verify>
  <done>SourceReader handles plugin cache skill discovery, unicode encoding, hidden file filtering, malformed MCP entries, and provides get_source_paths() for state tracking integration. All 5 edge case tests pass.</done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- All 6 discovery methods return correct data types
- Missing directories/files return empty results without crashing
- Plugin cache discovery handles both dict and list formats
- Edge cases (unicode, hidden files, malformed JSON) handled gracefully
- get_source_paths() returns file paths for all config types

Level 2 (Proxy): Deferred to Plan 04 integration verification
Level 3 (Deferred): Real user-scope discovery against actual ~/.claude/ (requires live environment)
</verification>

<success_criteria>
- src/source_reader.py exists with SourceReader class
- 6 discovery methods: get_rules, get_skills, get_agents, get_commands, get_mcp_servers, get_settings
- discover_all() returns all 6 in a dict
- get_source_paths() returns file paths for state tracking
- Handles user scope and project scope
- Gracefully handles missing/corrupted/malformed config files
- All 13 verification tests pass (8 from Task 1, 5 from Task 2)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-state-management/01-03-SUMMARY.md`
</output>
