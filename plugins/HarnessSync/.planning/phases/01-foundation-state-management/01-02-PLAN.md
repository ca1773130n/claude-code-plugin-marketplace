---
phase: 01-foundation-state-management
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/state_manager.py
autonomous: true
verification_level: sanity

must_haves:
  truths:
    - "StateManager persists state to ~/.harnesssync/state.json with atomic writes (tempfile + rename)"
    - "State tracks per-target sync entries with timestamp, file hashes dict, status, and sync method"
    - "detect_drift returns a list of changed file paths by comparing stored hashes to current file hashes"
    - "Atomic write survives interrupted writes without corrupting existing state file"
    - "StateManager loads gracefully when state file is missing, corrupted, or from older schema version"
  artifacts:
    - path: "src/state_manager.py"
      provides: "State management with atomic writes and drift detection"
      exports: ["StateManager"]
      min_lines: 80
  key_links:
    - from: "src/state_manager.py"
      to: "src/utils/hashing.py"
      via: "import hash_file_sha256 for drift detection"
      pattern: "from.*utils.*import.*hash_file_sha256"
    - from: "src/state_manager.py"
      to: "src/utils/paths.py"
      via: "import ensure_dir for state directory creation"
      pattern: "from.*utils.*import.*ensure_dir"
---

<objective>
Implement the StateManager class that tracks per-target sync status with SHA256 file hashes, sync timestamps, and drift detection. Uses atomic JSON writes (tempfile + os.replace) to prevent corruption on interrupted writes.

Purpose: The state manager is the backbone of CORE-02 (drift detection, sync tracking). Without it, the plugin cannot know what changed, what was synced, or when to re-sync. It stores per-target entries (codex, gemini, opencode) each with their own hash map and timestamps.

Output: src/state_manager.py with StateManager class providing load/save/record_sync/detect_drift API.

Research basis: 01-RESEARCH.md Pattern 3 (Atomic State Writes) -- tempfile in same directory + os.replace for atomic rename. Pitfall 3 (State Corruption on Interrupted Write) -- never write directly to state file.
</objective>

<execution_context>
@.planning/phases/01-foundation-state-management/01-RESEARCH.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@cc2all-sync.py
@.planning/phases/01-foundation-state-management/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement StateManager with atomic writes and per-target tracking</name>
  <files>src/state_manager.py</files>
  <action>
    Create src/state_manager.py implementing the StateManager class. This refactors and significantly enhances the basic state from cc2all-sync.py (lines 159-165: load_state/save_state using simple read/write).

    NOTE: This module uses JSON for serialization only. No other serialization format is used.

    Class: StateManager

    Constructor: `__init__(self, state_dir: Path = None)`
    - Default state_dir: Path.home() / ".harnesssync" (note: renamed from ~/.cc2all)
    - state_file: state_dir / "state.json"
    - Load existing state on init via self._load()

    Internal state schema (the JSON structure):
    ```python
    {
        "version": 1,
        "last_sync": "2024-01-01T12:00:00",
        "targets": {
            "codex": {
                "last_sync": "2024-01-01T12:00:00",
                "status": "success",  # "success" | "partial" | "failed"
                "scope": "all",
                "file_hashes": {
                    "/path/to/AGENTS.md": "abc123...",
                    "/path/to/config.toml": "def456..."
                },
                "sync_method": {
                    "/path/to/skills/foo": "symlink",
                    "/path/to/skills/bar": "copy"
                },
                "items_synced": 5,
                "items_skipped": 2,
                "items_failed": 0
            },
            "gemini": { ... },
            "opencode": { ... }
        }
    }
    ```

    Methods:

    1. `_load(self) -> dict`:
       - If state file does not exist, return default empty state: {"version": 1, "targets": {}}
       - Read with read_json_safe from src.utils.paths
       - If "version" key missing or not an int, treat as legacy cc2all state and migrate:
         - Wrap existing data under a "migrated_from" key, add version=1, empty targets
       - If state file exists but read_json_safe returns {} (corrupted JSON):
         - Rename corrupted file to state.json.bak with timestamp suffix
         - Return fresh default state
       - Return parsed state dict

    2. `_save(self) -> None`:
       - ATOMIC WRITE per 01-RESEARCH.md Pattern 3:
         - Create tempfile in SAME directory as state file (critical: same filesystem for os.replace)
         - Use tempfile.NamedTemporaryFile(mode='w', dir=self.state_dir, suffix='.tmp', delete=False)
         - Write JSON with indent=2, ensure_ascii=False, trailing newline
         - Flush and fsync (f.flush(); os.fsync(f.fileno()))
         - os.replace(temp_path, self._state_file_path) -- atomic on POSIX and Windows
       - Wrap in try/finally: on failure, clean up temp file if it exists
       - Call ensure_dir(self.state_dir) before writing

    3. `record_sync(self, target: str, scope: str, file_hashes: dict[str, str], sync_methods: dict[str, str], synced: int, skipped: int, failed: int) -> None`:
       - target: "codex" | "gemini" | "opencode"
       - Update self._state["targets"][target] with:
         - last_sync: datetime.now().isoformat()
         - status: "success" if failed==0, "partial" if failed>0 and synced>0, "failed" if synced==0 and failed>0
         - scope: the scope string
         - file_hashes: dict mapping absolute file path strings to hash strings
         - sync_method: dict mapping absolute file path strings to method strings
         - items_synced, items_skipped, items_failed: the count integers
       - Update self._state["last_sync"] to current time
       - Call self._save()

    4. `detect_drift(self, target: str, current_hashes: dict[str, str]) -> list[str]`:
       - Compare current_hashes against stored file_hashes for target
       - Return list of file paths where hash differs or file is new/removed
       - If target not in state, return all keys from current_hashes as "all new"

    5. `get_target_status(self, target: str) -> dict | None`:
       - Return the target's state dict, or None if not tracked

    6. `get_all_status(self) -> dict`:
       - Return the full state dict (for /sync-status command in later phases)

    7. `clear_target(self, target: str) -> None`:
       - Remove target from state and save

    8. Class method: `migrate_from_cc2all(cls, old_state_dir: Path = None, new_state_dir: Path = None) -> 'StateManager'`:
       - old_state_dir defaults to Path.home() / ".cc2all"
       - new_state_dir defaults to Path.home() / ".harnesssync"
       - If old_state_dir / "sync-state.json" exists, read it, create new StateManager, copy last_sync
       - If old state doesn't exist, just return fresh StateManager
       - Does NOT delete old directory

    Properties:
    - `last_sync -> str | None`: Return self._state.get("last_sync")
    - `state_file -> Path`: Return the state file path

    Imports needed:
    - `from pathlib import Path`
    - `from datetime import datetime`
    - `import tempfile, os, json`
    - `from src.utils.paths import ensure_dir, read_json_safe`

    Avoid:
    - Do NOT write directly to state file (always atomic via tempfile + replace)
    - Do NOT use any serialization format other than JSON
    - Do NOT add file locking (that is PLG-04 scope in Phase 4)
    - Do NOT import Logger (state manager should be pure data, no side effects)
  </action>
  <verify>
    Run from project root (Level 1: Sanity):
    ```bash
    python3 -c "
    import tempfile, os, json
    from pathlib import Path
    from src.state_manager import StateManager

    # Use a temp dir for testing
    tmp = Path(tempfile.mkdtemp())
    sm = StateManager(state_dir=tmp)

    # Test 1: Fresh state is empty
    assert sm.last_sync is None, f'Expected None, got {sm.last_sync}'
    assert sm.get_target_status('codex') is None
    print('Test 1 PASSED: Fresh state is empty')

    # Test 2: Record a sync
    sm.record_sync(
        target='codex',
        scope='user',
        file_hashes={'/home/user/.codex/AGENTS.md': 'abc123def456'},
        sync_methods={'/home/user/.codex/skills/foo': 'symlink'},
        synced=3, skipped=1, failed=0
    )
    status = sm.get_target_status('codex')
    assert status is not None
    assert status['status'] == 'success'
    assert status['items_synced'] == 3
    assert sm.last_sync is not None
    print('Test 2 PASSED: Record sync works')

    # Test 3: State file exists and is valid JSON
    state_file = tmp / 'state.json'
    assert state_file.exists()
    data = json.loads(state_file.read_text())
    assert data['version'] == 1
    assert 'codex' in data['targets']
    print('Test 3 PASSED: State file is valid JSON')

    # Test 4: Detect drift
    drifted = sm.detect_drift('codex', {
        '/home/user/.codex/AGENTS.md': 'CHANGED_HASH',
        '/home/user/.codex/new_file.txt': 'newfilehash1'
    })
    assert '/home/user/.codex/AGENTS.md' in drifted, 'Should detect changed hash'
    assert '/home/user/.codex/new_file.txt' in drifted, 'Should detect new file'
    print('Test 4 PASSED: Drift detection works')

    # Test 5: Reload from disk
    sm2 = StateManager(state_dir=tmp)
    assert sm2.get_target_status('codex') is not None
    assert sm2.get_target_status('codex')['items_synced'] == 3
    print('Test 5 PASSED: State persists and reloads')

    # Test 6: Partial/failed status
    sm.record_sync('gemini', 'all', {}, {}, synced=2, skipped=0, failed=1)
    assert sm.get_target_status('gemini')['status'] == 'partial'
    sm.record_sync('opencode', 'all', {}, {}, synced=0, skipped=0, failed=3)
    assert sm.get_target_status('opencode')['status'] == 'failed'
    print('Test 6 PASSED: Status logic (partial, failed)')

    # Test 7: Clear target
    sm.clear_target('opencode')
    assert sm.get_target_status('opencode') is None
    assert sm.get_target_status('codex') is not None  # others untouched
    print('Test 7 PASSED: Clear target works')

    # Test 8: get_all_status returns full state
    full = sm.get_all_status()
    assert 'version' in full
    assert 'targets' in full
    print('Test 8 PASSED: get_all_status works')

    # Test 9: Legacy state migration (flat cc2all format)
    legacy_dir = tmp / 'legacy'
    legacy_dir.mkdir()
    (legacy_dir / 'state.json').write_text(json.dumps({
        'last_sync': '2024-06-15 10:30:00',
        'scope': 'all',
        'elapsed_ms': 150
    }))
    sm_legacy = StateManager(state_dir=legacy_dir)
    full_legacy = sm_legacy.get_all_status()
    assert full_legacy.get('version') == 1
    assert 'targets' in full_legacy
    print('Test 9 PASSED: Legacy migration adds version and targets')

    # Test 10: Corrupted state recovery
    corrupt_dir = tmp / 'corrupt'
    corrupt_dir.mkdir()
    (corrupt_dir / 'state.json').write_text('{this is not valid json!!!')
    sm_corrupt = StateManager(state_dir=corrupt_dir)
    assert sm_corrupt.get_all_status().get('version') == 1
    backups = list(corrupt_dir.glob('state.json.bak*'))
    assert len(backups) >= 1, 'Expected backup of corrupted file'
    print('Test 10 PASSED: Corrupted state recovered with backup')

    # Test 11: migrate_from_cc2all class method
    old_dir = tmp / 'old_cc2all'
    old_dir.mkdir()
    (old_dir / 'sync-state.json').write_text(json.dumps({'last_sync': '2024-01-01 00:00:00'}))
    new_dir = tmp / 'new_harnesssync'
    sm_migrated = StateManager.migrate_from_cc2all(old_state_dir=old_dir, new_state_dir=new_dir)
    assert sm_migrated.last_sync is not None
    assert (new_dir / 'state.json').exists()
    print('Test 11 PASSED: migrate_from_cc2all works')

    import shutil
    shutil.rmtree(tmp)
    print('StateManager: ALL CHECKS PASSED')
    "
    ```
  </verify>
  <done>StateManager class in src/state_manager.py with atomic JSON writes (tempfile+replace), per-target tracking (codex/gemini/opencode), drift detection via hash comparison, status derivation (success/partial/failed), legacy cc2all migration, corrupted state recovery, and disk persistence. All 11 verification tests pass.</done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- StateManager instantiates with clean state when no file exists
- record_sync persists to disk and reloads correctly
- detect_drift finds changed/new/removed files
- Atomic writes produce valid JSON (never partial writes)
- Legacy migration upgrades flat state to versioned schema
- Corrupted state triggers backup and recovery

Level 2 (Proxy): Deferred to Plan 04 integration verification
Level 3 (Deferred): Concurrent access behavior, network filesystem edge cases
</verification>

<success_criteria>
- src/state_manager.py exists with StateManager class
- Atomic writes via tempfile + os.replace (never direct write to state.json)
- Per-target tracking with file_hashes, sync_methods, status, timestamps
- Drift detection compares stored vs current hashes
- Legacy cc2all state migration works
- Corrupted state creates backup and recovers gracefully
- All 11 verification tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-state-management/01-02-SUMMARY.md`
</output>
