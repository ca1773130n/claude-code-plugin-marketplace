---
phase: 09-plugin-discovery-scope-aware-source-reading
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified: [src/source_reader.py]
autonomous: true
verification_level: proxy

must_haves:
  truths:
    - "get_mcp_servers_with_scope() returns dict mapping server_name -> {config, metadata} with scope and source fields"
    - "User-scope MCPs read from ~/.claude.json top-level mcpServers (NOT ~/.mcp.json or ~/.claude/.mcp.json)"
    - "Project-scope MCPs read from .mcp.json in project root with mcpServers wrapper"
    - "Local-scope MCPs read from ~/.claude.json under projects[absolutePath].mcpServers"
    - "Plugin MCPs tagged as scope=user, source=plugin with plugin_name and plugin_version"
    - "Scope precedence: local > project > user — same-named server at local scope overrides project and user"
    - "get_mcp_servers() backward-compatible (returns flat dict without metadata)"
    - "discover_all() includes mcp_servers_scoped key for scope-aware consumers"
    - "Proxy verification with 3 plugins, 5 MCP servers across 3 scopes passes with 100% discovery and correct precedence"
  artifacts:
    - path: "src/source_reader.py"
      provides: "get_mcp_servers_with_scope(), _get_user_scope_mcps(), _get_local_scope_mcps() methods"
      contains: "get_mcp_servers_with_scope"
  key_links:
    - from: "src/source_reader.py::get_mcp_servers_with_scope"
      to: "src/source_reader.py::_get_plugin_mcp_servers"
      via: "method call for plugin layer in layered discovery"
      pattern: "self._get_plugin_mcp_servers"
    - from: "src/source_reader.py::get_mcp_servers_with_scope"
      to: "src/source_reader.py::_get_local_scope_mcps"
      via: "method call for local layer in layered discovery"
      pattern: "self._get_local_scope_mcps"
---

<objective>
Implement 3-tier scope-aware MCP discovery with precedence-based deduplication and origin tagging.

Purpose: Enable HarnessSync to know WHERE each MCP server came from (user/project/local/plugin) and correctly resolve conflicts when the same server name appears at multiple scopes. This is critical for Phase 10's scope-aware target sync — adapters need scope metadata to write configs to the correct target-level files.

Output: get_mcp_servers_with_scope() public method implementing layered discovery with scope tagging and precedence resolution. Updated discover_all() with scoped MCP data. Backward-compatible get_mcp_servers().
</objective>

<execution_context>
@${CLAUDE_PLUGIN_ROOT}/references/execute-plan.md
@${CLAUDE_PLUGIN_ROOT}/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-plugin-discovery-scope-aware-source-reading/09-RESEARCH.md
@.planning/phases/09-plugin-discovery-scope-aware-source-reading/09-01-SUMMARY.md

@src/source_reader.py
@src/utils/paths.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement scope-specific MCP discovery methods</name>
  <files>src/source_reader.py</files>
  <action>
    Add new private methods and one public method to SourceReader for 3-tier scope-aware MCP discovery:

    1. `_get_user_scope_mcps(self) -> dict[str, dict]`:
       - Read ~/.claude.json (Path.home() / ".claude.json") — NOTE: this is NOT the same as ~/.claude/.mcp.json
       - Extract top-level "mcpServers" field
       - Filter malformed entries (must have command or url)
       - IMPORTANT: This replaces the v1.0 pattern of reading ~/.mcp.json and ~/.claude/.mcp.json
         The v1.0 sources (cc_mcp_global, cc_mcp_claude) were incorrect for user-scope MCPs.
         User-scope MCPs live in ~/.claude.json, NOT in .mcp.json files.
         Research: v2-claude-plugins.md lines 432-448 confirm ~/.claude.json is user-scope MCP location
       - Return dict mapping server_name -> server_config

    2. `_get_project_scope_mcps(self) -> dict[str, dict]`:
       - Return empty dict if no project_dir
       - Read project_dir / ".mcp.json"
       - Extract "mcpServers" field (project .mcp.json wraps in mcpServers key)
       - Filter malformed entries
       - Return dict mapping server_name -> server_config

    3. `_get_local_scope_mcps(self) -> dict[str, dict]`:
       - Return empty dict if no project_dir
       - Read ~/.claude.json (Path.home() / ".claude.json")
       - Navigate to projects[absoluteProjectPath].mcpServers
       - Use str(self.project_dir.resolve()) as project key
       - Filter malformed entries (must have command or url)
       - CRITICAL: MCP "local scope" is in ~/.claude.json (home dir), NOT .claude/settings.local.json (project dir)
         Research: 09-RESEARCH.md Pitfall 1 warns about this confusion
       - Return dict mapping server_name -> server_config

    4. `get_mcp_servers_with_scope(self) -> dict[str, dict]`:
       - Implement the layered discovery pattern from 09-RESEARCH.md:

       Layer 1 (lowest precedence): User-scope file-based MCPs
       - If scope in ("user", "all"): call _get_user_scope_mcps()
       - Tag each with metadata: {"scope": "user", "source": "file"}

       Layer 2 (same precedence as user): Plugin MCPs
       - If scope in ("user", "all"): call _get_plugin_mcp_servers() (from Plan 01)
       - For each server, extract _plugin_name, _plugin_version, _source from config
       - Remove underscore-prefixed metadata keys from config (clean config)
       - Tag with metadata: {"scope": "user", "source": "plugin", "plugin_name": name, "plugin_version": version}
       - Only add if name not already in servers (file-based user MCPs have priority over plugins)

       Layer 3 (overrides user): Project-scope MCPs
       - If scope in ("project", "all") and project_dir: call _get_project_scope_mcps()
       - Tag each with metadata: {"scope": "project", "source": "file"}
       - OVERRIDES user-scope servers with same name (higher precedence)

       Layer 4 (highest precedence): Local-scope MCPs
       - If scope in ("project", "all") and project_dir: call _get_local_scope_mcps()
       - Tag each with metadata: {"scope": "local", "source": "file"}
       - OVERRIDES all lower scopes with same name

       Return format: dict mapping server_name -> {"config": {server_config}, "metadata": {scope, source, ...}}

    5. Update `get_mcp_servers(self) -> dict[str, dict]`:
       - Reimplement to call get_mcp_servers_with_scope() internally
       - Return FLAT dict (server_name -> config) for backward compatibility
       - Strip metadata, return only config dicts
       - This ensures existing adapters (Codex, Gemini, OpenCode) continue to work unchanged

    6. Update `discover_all(self) -> dict`:
       - Keep existing "mcp_servers" key (flat, backward-compatible via get_mcp_servers())
       - ADD new "mcp_servers_scoped" key with full scope metadata (via get_mcp_servers_with_scope())
       - Phase 10 adapters will consume mcp_servers_scoped for scope-aware sync

    7. Update `get_source_paths(self) -> dict[str, list[Path]]`:
       - Add ~/.claude.json to mcp_servers paths if it exists (new source for user + local scope MCPs)
       - Keep existing project .mcp.json path
       - Remove cc_mcp_global and cc_mcp_claude from MCP source paths (those were v1.0 incorrect sources)

    AVOID:
    - Don't break backward compatibility of get_mcp_servers() return type
    - Don't mutate the original config dicts from _get_plugin_mcp_servers() (create copies)
    - Don't crash if ~/.claude.json doesn't exist or has unexpected structure
    - Don't read settings.local.json for MCP local scope (that's for general settings, not MCPs)
  </action>
  <verify>
    Run inline verification script:
    ```
    python3 -c "
    import tempfile, json, os, sys
    from pathlib import Path

    # Create comprehensive mock environment
    with tempfile.TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)
        cc_home = tmpdir / '.claude'
        cc_home.mkdir()
        project_dir = tmpdir / 'myproject'
        project_dir.mkdir()

        # 1. Create settings.json with enabled plugins
        settings = {'enabledPlugins': {'plugin-a@market': True, 'plugin-b@market': True}}
        (cc_home / 'settings.json').write_text(json.dumps(settings))

        # 2. Create ~/.claude.json with user-scope MCPs AND local-scope MCPs
        claude_json_path = tmpdir / '.claude.json'
        claude_json = {
            'mcpServers': {
                'user-server': {'command': 'npx', 'args': ['-y', 'user-mcp']},
                'shared-server': {'command': 'npx', 'args': ['-y', 'user-version']}
            },
            'projects': {
                str(project_dir.resolve()): {
                    'mcpServers': {
                        'local-server': {'command': 'local-cmd', 'args': []},
                        'shared-server': {'command': 'npx', 'args': ['-y', 'local-override']}
                    }
                }
            }
        }
        claude_json_path.write_text(json.dumps(claude_json))

        # 3. Create project .mcp.json with project-scope MCPs
        project_mcp = {'mcpServers': {'project-server': {'command': 'proj-cmd', 'args': []}, 'shared-server': {'command': 'npx', 'args': ['-y', 'project-version']}}}
        (project_dir / '.mcp.json').write_text(json.dumps(project_mcp))

        # 4. Create plugin registry with 2 plugins providing MCP servers
        plugins_dir = cc_home / 'plugins'
        plugins_dir.mkdir()

        # Plugin A: .mcp.json format
        plugin_a_cache = plugins_dir / 'cache' / 'market' / 'plugin-a' / '1.0'
        plugin_a_cache.mkdir(parents=True)
        (plugin_a_cache / '.mcp.json').write_text(json.dumps({'plugin-a-server': {'command': 'pa-cmd', 'args': []}}))

        # Plugin B: inline mcpServers in plugin.json
        plugin_b_cache = plugins_dir / 'cache' / 'market' / 'plugin-b' / '2.0'
        (plugin_b_cache / '.claude-plugin').mkdir(parents=True)
        (plugin_b_cache / '.claude-plugin' / 'plugin.json').write_text(json.dumps({
            'name': 'plugin-b',
            'mcpServers': {'plugin-b-server': {'command': 'pb-cmd', 'args': []}}
        }))

        registry = {
            'version': 2,
            'plugins': {
                'plugin-a@market': [{'scope': 'user', 'installPath': str(plugin_a_cache), 'version': '1.0'}],
                'plugin-b@market': [{'scope': 'user', 'installPath': str(plugin_b_cache), 'version': '2.0'}]
            }
        }
        (plugins_dir / 'installed_plugins.json').write_text(json.dumps(registry))

        # Monkey-patch Path.home() to use tmpdir
        original_home = Path.home
        Path.home = staticmethod(lambda: tmpdir)

        try:
            sys.path.insert(0, '.')
            # Force reimport
            if 'src.source_reader' in sys.modules:
                del sys.modules['src.source_reader']
            from src.source_reader import SourceReader

            reader = SourceReader(scope='all', project_dir=project_dir, cc_home=cc_home)

            # Test get_mcp_servers_with_scope
            scoped = reader.get_mcp_servers_with_scope()

            # Verify all 5 unique servers discovered (shared-server deduplicated)
            print(f'Discovered servers: {list(scoped.keys())}')
            assert 'user-server' in scoped, f'Missing user-server'
            assert 'project-server' in scoped, f'Missing project-server'
            assert 'local-server' in scoped, f'Missing local-server'
            assert 'plugin-a-server' in scoped, f'Missing plugin-a-server'
            assert 'plugin-b-server' in scoped, f'Missing plugin-b-server'
            assert 'shared-server' in scoped, f'Missing shared-server'
            print('PASS: All servers discovered')

            # Verify scope tagging
            assert scoped['user-server']['metadata']['scope'] == 'user', f'Wrong user scope'
            assert scoped['user-server']['metadata']['source'] == 'file', f'Wrong user source'
            assert scoped['project-server']['metadata']['scope'] == 'project', f'Wrong project scope'
            assert scoped['local-server']['metadata']['scope'] == 'local', f'Wrong local scope'
            assert scoped['plugin-a-server']['metadata']['source'] == 'plugin', f'Wrong plugin source'
            assert scoped['plugin-a-server']['metadata']['plugin_name'] == 'plugin-a', f'Wrong plugin name'
            assert scoped['plugin-b-server']['metadata']['plugin_version'] == '2.0', f'Wrong plugin version'
            print('PASS: Scope and source tagging correct')

            # Verify precedence: shared-server should be LOCAL (highest precedence)
            assert scoped['shared-server']['metadata']['scope'] == 'local', f'Precedence failed: shared-server scope is {scoped[\"shared-server\"][\"metadata\"][\"scope\"]}, expected local'
            assert scoped['shared-server']['config']['args'] == ['-y', 'local-override'], f'Precedence failed: wrong config for shared-server'
            print('PASS: Scope precedence (local > project > user)')

            # Verify backward-compatible get_mcp_servers
            flat = reader.get_mcp_servers()
            assert isinstance(flat, dict), f'get_mcp_servers should return dict'
            assert 'user-server' in flat, f'Flat dict missing user-server'
            assert 'metadata' not in flat.get('user-server', {}), f'Flat dict should not have metadata'
            assert isinstance(flat['user-server'], dict), f'Flat values should be config dicts'
            print('PASS: Backward-compatible get_mcp_servers()')

            # Verify discover_all includes scoped data
            all_data = reader.discover_all()
            assert 'mcp_servers' in all_data, f'Missing mcp_servers in discover_all'
            assert 'mcp_servers_scoped' in all_data, f'Missing mcp_servers_scoped in discover_all'
            assert isinstance(all_data['mcp_servers_scoped'], dict), f'mcp_servers_scoped should be dict'
            print('PASS: discover_all() includes mcp_servers_scoped')

            # Count total: 6 unique server names (user-server, shared-server, project-server, local-server, plugin-a-server, plugin-b-server)
            assert len(scoped) == 6, f'Expected 6 servers, got {len(scoped)}'
            print('PASS: Total server count correct (6)')

            print()
            print('ALL PROXY VERIFICATION TESTS PASSED')
            print(f'Discovery: 6/6 servers (100%)')
            print(f'Scopes verified: user, project, local, plugin')
            print(f'Precedence verified: local > project > user')
            print(f'Backward compatibility: verified')

        finally:
            Path.home = original_home
    "
    ```
    (Level 2: Proxy — comprehensive test with 2 plugins, 5+ servers across 3 scopes, precedence validation, backward compatibility)
  </verify>
  <done>
    Scope-aware MCP discovery implemented with:
    - _get_user_scope_mcps() reads from ~/.claude.json top-level mcpServers
    - _get_project_scope_mcps() reads from .mcp.json in project root
    - _get_local_scope_mcps() reads from ~/.claude.json projects[path].mcpServers
    - get_mcp_servers_with_scope() implements layered discovery with correct precedence (local > project > user)
    - Each server tagged with scope (user/project/local) and source (file/plugin) metadata
    - get_mcp_servers() backward-compatible (returns flat dict)
    - discover_all() returns both flat and scoped MCP data
    - Proxy test passes: 6 servers discovered, 100% coverage, correct precedence for shared-server
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- get_mcp_servers_with_scope() returns dict with config and metadata keys per server
- Scope tagging matches source file (user from ~/.claude.json, project from .mcp.json, local from ~/.claude.json projects)
- Plugin servers tagged with source=plugin and plugin_name/plugin_version metadata

Level 2 (Proxy):
- 6 unique servers discovered from 4 sources (user file, 2 plugins, project file, local scope)
- Precedence verified: shared-server resolves to local scope override
- Backward compatibility: get_mcp_servers() returns flat dict without metadata
- discover_all() contains both mcp_servers and mcp_servers_scoped keys

Level 3 (Deferred):
- Real Claude Code plugin MCP servers discovered and synced to target CLIs
- Scope-aware sync to correct target-level files (user vs project Codex/Gemini configs)
</verification>

<success_criteria>
1. get_mcp_servers_with_scope() discovers servers from all 4 sources (user files, plugins, project files, local scope)
2. Each server has correct scope tag and source attribution
3. Precedence: local-scope server overrides same-named server at project and user scopes
4. get_mcp_servers() returns flat dict (backward-compatible with v1.0 adapters)
5. discover_all() includes mcp_servers_scoped for Phase 10 scope-aware adapters
6. Proxy test with 2 plugins, 5+ servers, 3 scopes: 100% discovery, correct precedence
</success_criteria>

<output>
After completion, create `.planning/phases/09-plugin-discovery-scope-aware-source-reading/09-02-SUMMARY.md`
</output>
