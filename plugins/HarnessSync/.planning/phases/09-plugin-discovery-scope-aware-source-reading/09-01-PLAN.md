---
phase: 09-plugin-discovery-scope-aware-source-reading
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/source_reader.py]
autonomous: true
verification_level: sanity

must_haves:
  truths:
    - "SourceReader._get_plugin_mcp_servers() returns MCP server configs from installed plugins with plugin_name and plugin_version metadata"
    - "SourceReader._expand_plugin_root() replaces all ${CLAUDE_PLUGIN_ROOT} occurrences in nested config dicts with absolute plugin install path"
    - "Plugin discovery handles both .mcp.json at plugin root AND inline mcpServers in plugin.json"
    - "Plugin discovery checks both .claude-plugin/plugin.json and root plugin.json locations (new format first)"
    - "Plugin discovery filters by enabled plugins using _get_enabled_plugins() from settings.json"
    - "Disabled plugins are skipped during MCP discovery"
    - "Version 2 installed_plugins.json format parsed correctly (plugin_key -> list of installs)"
  artifacts:
    - path: "src/source_reader.py"
      provides: "_get_plugin_mcp_servers(), _expand_plugin_root(), _get_enabled_plugins() methods"
      contains: "_get_plugin_mcp_servers"
  key_links:
    - from: "src/source_reader.py"
      to: "src/utils/paths.py"
      via: "read_json_safe import"
      pattern: "from src.utils.paths import read_json_safe"
---

<objective>
Extend SourceReader with plugin MCP server discovery from installed Claude Code plugins.

Purpose: Enable HarnessSync to discover MCP servers bundled with Claude Code plugins (e.g., Context7, GitHub, Figma) so they can be synced to target CLIs. Plugin MCPs are currently invisible to HarnessSync.

Output: Three new private methods on SourceReader: _get_plugin_mcp_servers(), _expand_plugin_root(), _get_enabled_plugins()
</objective>

<execution_context>
@${CLAUDE_PLUGIN_ROOT}/references/execute-plan.md
@${CLAUDE_PLUGIN_ROOT}/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-plugin-discovery-scope-aware-source-reading/09-RESEARCH.md

@src/source_reader.py
@src/utils/paths.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement plugin MCP discovery with dual-format support</name>
  <files>src/source_reader.py</files>
  <action>
    Add three new private methods to SourceReader class:

    1. `_get_enabled_plugins(self) -> set[str]`:
       - Read enabled plugins from settings.json (user scope: ~/.claude/settings.json)
       - If project_dir set and scope includes "project", also read .claude/settings.json
       - Return set of plugin identifiers (e.g., "context7@claude-plugins-official") where value is True
       - If no settings file exists, return empty set (treat as all-enabled for backward compat)
       - Research note: enabledPlugins field maps plugin_key -> bool (v2-claude-plugins.md lines 524-533)

    2. `_expand_plugin_root(self, config: dict, plugin_path: Path) -> dict`:
       - Serialize config dict to JSON string via json.dumps()
       - Replace all "${CLAUDE_PLUGIN_ROOT}" occurrences with str(plugin_path)
       - Parse back to dict via json.loads()
       - This handles expansion in command, args, env, url, headers — any nested field
       - Import json at module level (already available via read_json_safe usage)
       - Research note: expansion must happen at discovery time, not sync time (09-RESEARCH.md Recommendation 2)

    3. `_get_plugin_mcp_servers(self) -> dict[str, dict]`:
       - Return empty dict if cc_plugins_registry doesn't exist
       - Read registry via read_json_safe(self.cc_plugins_registry)
       - Get enabled_plugins via self._get_enabled_plugins()
       - Iterate registry["plugins"] dict: for plugin_key, installs in plugins.items()
         - IMPORTANT: version 2 format maps plugin_key -> LIST of install entries
         - For each install in installs (handle case where installs is a dict by wrapping in list)
         - Filter: only process user-scope plugins (install.get("scope") == "user")
           - Research decision: ALL plugin MCPs treated as user-scope regardless of plugin scope
         - Filter: skip if plugin_key not in enabled_plugins AND enabled_plugins is not empty
         - Get install_path = Path(install.get("installPath", ""))
         - Skip if installPath empty or doesn't exist on disk
         - Discover plugin MCPs via two methods:

         Method 1: Standalone .mcp.json at plugin root
         - Read install_path / ".mcp.json" via read_json_safe
         - Format can be EITHER {"server-name": {config}} (flat) OR {"mcpServers": {"server-name": {config}}} (nested)
         - Handle both: check if top-level has "mcpServers" key, if so use that, otherwise treat entire dict as servers
         - Research note: Context7 uses flat format, Figma uses nested format (v2-claude-plugins.md lines 306-327, 964-978)

         Method 2: Inline mcpServers in plugin.json
         - Check .claude-plugin/plugin.json FIRST (new format, PLGD-04)
         - If not found, check root plugin.json (old format, PLGD-04)
         - Read mcpServers field from whichever is found
         - Only use first found (break after finding one)

         For each discovered server:
         - Call _expand_plugin_root(config, install_path) to resolve ${CLAUDE_PLUGIN_ROOT}
         - Extract plugin name: plugin_key.split("@")[0]
         - Extract plugin version: install.get("version", "unknown")
         - Store metadata in config dict with underscore-prefixed keys:
           config["_plugin_name"] = plugin_name
           config["_plugin_version"] = plugin_version
           config["_source"] = "plugin"
         - Add to servers dict (server_name -> config)

    AVOID:
    - Don't modify get_mcp_servers() yet — that's Plan 02
    - Don't add scope tagging yet — that's Plan 02
    - Don't iterate project-scoped plugins for MCP discovery (all plugin MCPs are user-scope per decision #34)
    - Don't crash on missing/corrupt files — use read_json_safe and try/except

    Add `import json` at module level if not already present (needed for _expand_plugin_root).
  </action>
  <verify>
    Run inline verification script:
    ```
    python3 -c "
    import tempfile, json, os, sys
    from pathlib import Path

    # Create mock Claude Code environment
    with tempfile.TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)
        cc_home = tmpdir / '.claude'
        cc_home.mkdir()

        # Create settings.json with enabled plugins
        settings = {'enabledPlugins': {'test-plugin@test-market': True, 'disabled-plugin@test-market': False}}
        (cc_home / 'settings.json').write_text(json.dumps(settings))

        # Create plugin registry (version 2 format)
        plugins_dir = cc_home / 'plugins'
        plugins_dir.mkdir()

        # Create plugin cache for test-plugin
        plugin_cache = plugins_dir / 'cache' / 'test-market' / 'test-plugin' / '1.0.0'
        plugin_cache.mkdir(parents=True)

        # Method 1: Standalone .mcp.json (flat format)
        mcp_json = {'test-server': {'command': '\${CLAUDE_PLUGIN_ROOT}/bin/server', 'args': ['--port', '3000']}}
        (plugin_cache / '.mcp.json').write_text(json.dumps(mcp_json))

        # Create plugin cache for plugin2 (inline mcpServers in .claude-plugin/plugin.json)
        plugin2_cache = plugins_dir / 'cache' / 'test-market' / 'plugin2' / '2.0.0'
        (plugin2_cache / '.claude-plugin').mkdir(parents=True)
        plugin2_json = {'name': 'plugin2', 'mcpServers': {'inline-server': {'command': 'npx', 'args': ['-y', 'test-mcp']}}}
        (plugin2_cache / '.claude-plugin' / 'plugin.json').write_text(json.dumps(plugin2_json))

        # Create plugin registry
        registry = {
            'version': 2,
            'plugins': {
                'test-plugin@test-market': [{'scope': 'user', 'installPath': str(plugin_cache), 'version': '1.0.0'}],
                'plugin2@test-market': [{'scope': 'user', 'installPath': str(plugin2_cache), 'version': '2.0.0'}],
                'disabled-plugin@test-market': [{'scope': 'user', 'installPath': '/nonexistent', 'version': '0.1.0'}]
            }
        }
        (plugins_dir / 'installed_plugins.json').write_text(json.dumps(registry))

        # Test SourceReader
        sys.path.insert(0, '.')
        from src.source_reader import SourceReader
        reader = SourceReader(scope='user', cc_home=cc_home)

        # Test _get_enabled_plugins
        enabled = reader._get_enabled_plugins()
        assert 'test-plugin@test-market' in enabled, f'Expected test-plugin enabled, got {enabled}'
        assert 'disabled-plugin@test-market' not in enabled, f'Expected disabled-plugin not enabled'
        print('PASS: _get_enabled_plugins()')

        # Test _expand_plugin_root
        config = {'command': '\${CLAUDE_PLUGIN_ROOT}/bin/srv', 'env': {'CONFIG': '\${CLAUDE_PLUGIN_ROOT}/cfg'}}
        expanded = reader._expand_plugin_root(config, Path('/test/path'))
        assert expanded['command'] == '/test/path/bin/srv', f'Expected expanded command, got {expanded[\"command\"]}'
        assert expanded['env']['CONFIG'] == '/test/path/cfg', f'Expected expanded env, got {expanded[\"env\"]}'
        print('PASS: _expand_plugin_root()')

        # Test _get_plugin_mcp_servers
        servers = reader._get_plugin_mcp_servers()
        assert 'test-server' in servers, f'Expected test-server, got {list(servers.keys())}'
        assert 'inline-server' in servers, f'Expected inline-server, got {list(servers.keys())}'
        assert servers['test-server']['_plugin_name'] == 'test-plugin', f'Wrong plugin name: {servers[\"test-server\"].get(\"_plugin_name\")}'
        assert servers['test-server']['_plugin_version'] == '1.0.0', f'Wrong version: {servers[\"test-server\"].get(\"_plugin_version\")}'
        assert '\${CLAUDE_PLUGIN_ROOT}' not in servers['test-server']['command'], f'Variable not expanded: {servers[\"test-server\"][\"command\"]}'
        assert servers['inline-server']['_plugin_name'] == 'plugin2', f'Wrong inline plugin name'
        print('PASS: _get_plugin_mcp_servers()')

        # Test disabled plugin filtering
        assert len([s for s in servers.values() if s.get('_plugin_name') == 'disabled-plugin']) == 0, 'Disabled plugin should be skipped'
        print('PASS: disabled plugin filtering')

        print('ALL TESTS PASSED')
    "
    ```
    (Level 1: Sanity — fixture-based verification of all three methods)
  </verify>
  <done>
    Three private methods added to SourceReader:
    - _get_enabled_plugins() returns set of enabled plugin identifiers from settings.json
    - _expand_plugin_root() resolves ${CLAUDE_PLUGIN_ROOT} in all nested config fields
    - _get_plugin_mcp_servers() discovers MCP servers from plugin cache (both .mcp.json and inline plugin.json formats)
    All tests pass: enabled plugin filtering, variable expansion in nested structures, dual-format MCP discovery, disabled plugin skipping, version 2 registry parsing
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- _get_enabled_plugins() correctly reads enabledPlugins from settings.json
- _expand_plugin_root() replaces ${CLAUDE_PLUGIN_ROOT} in command, args, env fields
- _get_plugin_mcp_servers() discovers servers from both .mcp.json and inline plugin.json
- Disabled plugins are filtered out
- Version 2 installed_plugins.json format (plugin_key -> list) parsed correctly
- Plugin metadata (_plugin_name, _plugin_version, _source) attached to each server config

Level 2 (Proxy): Deferred to Plan 02 integration test
Level 3 (Deferred): Real plugin MCP sync to target CLIs
</verification>

<success_criteria>
1. _get_plugin_mcp_servers() discovers MCP servers from 2+ plugins with different registration methods
2. ${CLAUDE_PLUGIN_ROOT} fully expanded to absolute paths (no variable references remain)
3. Plugin metadata (name, version) preserved on each discovered server config
4. Disabled plugins skipped, missing paths skipped, corrupt JSON handled gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/09-plugin-discovery-scope-aware-source-reading/09-01-SUMMARY.md`
</output>
