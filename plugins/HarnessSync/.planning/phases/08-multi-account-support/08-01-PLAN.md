---
phase: 08-multi-account-support
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/account_manager.py, src/account_discovery.py]
autonomous: true
verification_level: sanity

must_haves:
  truths:
    - "AccountManager creates, reads, updates, and deletes accounts in ~/.harnesssync/accounts.json with atomic writes"
    - "AccountManager validates target path uniqueness across accounts (no two accounts use same target path for same CLI)"
    - "AccountDiscovery finds all ~/.claude* directories within depth-limited home directory scan in <500ms"
    - "AccountDiscovery excludes large directories (node_modules, .git, .cache, Library) to prevent performance degradation"
    - "accounts.json schema includes version, default_account, and accounts dict with source.path, source.scope, and targets mapping"
  artifacts:
    - path: "src/account_manager.py"
      provides: "Account registry CRUD operations"
      exports: ["AccountManager"]
    - path: "src/account_discovery.py"
      provides: "Filesystem scanning for Claude Code config directories"
      exports: ["discover_claude_configs"]
  key_links:
    - from: "src/account_manager.py"
      to: "~/.harnesssync/accounts.json"
      via: "JSON read/write with atomic tempfile+os.replace pattern"
      pattern: "os\\.replace|tempfile\\.NamedTemporaryFile"
    - from: "src/account_discovery.py"
      to: "pathlib.Path"
      via: "iterdir() with depth limit"
      pattern: "iterdir|is_dir|startswith.*\\.claude"
---

<objective>
Create the AccountManager class for multi-account registry CRUD and AccountDiscovery module for filesystem-based Claude Code config directory discovery.

Purpose: These are the foundation modules for Phase 8 multi-account support. AccountManager provides the data layer (accounts.json) and AccountDiscovery provides automated source path detection.

Output: Two new modules (src/account_manager.py, src/account_discovery.py) following established HarnessSync patterns (atomic writes from StateManager, zero dependencies).
</objective>

<execution_context>
@${CLAUDE_PLUGIN_ROOT}/references/execute-plan.md
@${CLAUDE_PLUGIN_ROOT}/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-multi-account-support/08-RESEARCH.md
@src/state_manager.py
@src/utils/paths.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement AccountManager with CRUD operations and atomic persistence</name>
  <files>src/account_manager.py</files>
  <action>
    Create src/account_manager.py following the established StateManager pattern (atomic writes via tempfile + os.replace, JSON serialization). Following AWS CLI profiles pattern from research:

    Class: AccountManager
    - __init__(config_dir: Path = None) - defaults to Path.home() / ".harnesssync"
    - accounts_file property pointing to config_dir / "accounts.json"
    - _load() -> dict: Load from accounts.json, return default {"version": 1, "default_account": None, "accounts": {}} on missing/corrupt
    - _save() -> None: Atomic write using tempfile.NamedTemporaryFile + os.fsync + os.replace (copy pattern from StateManager._save)
    - add_account(name: str, source_path: Path, targets: dict[str, Path]) -> None:
      * Validate source_path.is_dir()
      * Validate name is non-empty, no spaces, alphanumeric+dash+underscore only
      * Validate no target path collision with OTHER accounts (same target CLI pointing to same path)
      * Store: accounts[name] = {"source": {"path": str, "scope": "user"}, "targets": {cli_name: str(path)}}
      * If first account added and no default_account set, auto-set default_account to this name
      * Call _save()
    - remove_account(name: str) -> bool: Remove account by name, update default_account if removed was default, return True if existed
    - get_account(name: str) -> dict | None: Return account config or None
    - list_accounts() -> list[str]: Return sorted list of account names
    - get_default_account() -> str | None: Return default_account name
    - set_default_account(name: str) -> None: Validate name exists, set as default
    - has_accounts() -> bool: Return True if any accounts configured
    - validate_no_target_collision(name: str, targets: dict[str, Path]) -> list[str]: Return list of collision error messages (empty = valid)

    Use only stdlib imports: json, os, tempfile, pathlib, re (for name validation).
    Follow the exact atomic write pattern from src/state_manager.py lines 105-149.
    Error handling: ValueError for validation failures, OSError for filesystem issues.
  </action>
  <verify>
    python -c "
import tempfile, os, sys
sys.path.insert(0, '.')
from pathlib import Path

# Test in temp directory
with tempfile.TemporaryDirectory() as td:
    from src.account_manager import AccountManager
    am = AccountManager(config_dir=Path(td))

    # Test empty state
    assert am.list_accounts() == [], 'Empty accounts list'
    assert am.has_accounts() is False, 'No accounts'
    assert am.get_default_account() is None, 'No default'

    # Create mock source dirs
    src1 = Path(td) / '.claude-personal'
    src1.mkdir()
    src2 = Path(td) / '.claude-work'
    src2.mkdir()

    # Test add account
    am.add_account('personal', src1, {'codex': Path(td) / '.codex-personal'})
    assert 'personal' in am.list_accounts(), 'Account added'
    assert am.get_default_account() == 'personal', 'First account is default'
    assert am.has_accounts() is True, 'Has accounts'

    # Test second account
    am.add_account('work', src2, {'codex': Path(td) / '.codex-work'})
    assert len(am.list_accounts()) == 2, 'Two accounts'

    # Test target collision detection
    try:
        am.add_account('test', src1, {'codex': Path(td) / '.codex-personal'})
        assert False, 'Should raise ValueError for collision'
    except ValueError as e:
        assert 'collision' in str(e).lower(), f'Error mentions collision: {e}'

    # Test remove
    assert am.remove_account('work') is True, 'Removed'
    assert len(am.list_accounts()) == 1, 'One account left'

    # Test persistence (reload)
    am2 = AccountManager(config_dir=Path(td))
    assert am2.list_accounts() == ['personal'], 'Persisted and reloaded'

    # Test name validation
    try:
        am.add_account('invalid name', src1, {})
        assert False, 'Should reject space in name'
    except ValueError:
        pass

    print('All AccountManager tests passed')
" (Level 1: Sanity)
  </verify>
  <done>AccountManager class persists accounts.json atomically, validates account names and target path collisions, supports full CRUD, auto-sets default account on first add, and survives reload from disk.</done>
</task>

<task type="auto">
  <name>Task 2: Implement AccountDiscovery with depth-limited home directory scanning</name>
  <files>src/account_discovery.py</files>
  <action>
    Create src/account_discovery.py with filesystem discovery following the research recommendation for bounded scanning:

    Function: discover_claude_configs(home_dir: Path = None, max_depth: int = 2) -> list[Path]
    - Default home_dir to Path.home()
    - Use iterdir() with manual depth tracking (NOT rglob which has no depth limit)
    - Match directories whose name starts with ".claude" (covers .claude, .claude-personal1, .claude-work, etc.)
    - Exclude set: {'.git', 'node_modules', '.cache', 'Library', 'Applications', '.npm', '.cargo', '.venv', '__pycache__', '.Trash', '.local', '.pyenv', '.nvm', '.rbenv'}
    - Only recurse into hidden directories at depth 1 (home level), skip visible directories at depth 1 to avoid scanning Documents/Downloads/etc.
    - Actually, for Claude Code configs, the expected pattern is ~/.claude* at depth 1. Depth 2 scanning should be limited (only look in immediate children of ~).
    - Implementation approach: At depth 1, iterate ~ looking for .claude* directories. Also check obvious additional locations like ~/.*/ for nested .claude* at depth 2.
    - Wrap all iterdir calls in try/except (OSError, PermissionError) for robustness
    - Sort results by path name for deterministic output
    - Return list of Path objects pointing to discovered directories

    Function: validate_claude_config(path: Path) -> bool
    - Check if path is a directory
    - Check for at least one expected Claude Code file/dir: settings.json, CLAUDE.md, skills/, agents/, commands/, .mcp.json
    - Return True if path looks like a valid Claude Code config directory
    - This helps filter false positives (random .claude* named directories)

    Function: discover_target_configs(home_dir: Path = None) -> dict[str, list[Path]]
    - Scan for target CLI directories: .codex*, .gemini*, .opencode*
    - Return dict mapping cli_name -> list of discovered paths
    - Useful for setup wizard to suggest target paths

    Use only stdlib: pathlib, os.

    Performance target: <500ms for depth=2 scan on typical macOS home directory.
    Avoid: rglob(), os.walk() without limits, scanning into excluded directories.
  </action>
  <verify>
    python -c "
import tempfile, os, sys
sys.path.insert(0, '.')
from pathlib import Path

with tempfile.TemporaryDirectory() as td:
    home = Path(td)

    # Create mock Claude config directories
    (home / '.claude').mkdir()
    (home / '.claude' / 'settings.json').write_text('{}')
    (home / '.claude-personal1').mkdir()
    (home / '.claude-personal1' / 'CLAUDE.md').write_text('# Rules')
    (home / '.claude-work').mkdir()
    (home / '.claude-work' / 'skills').mkdir()

    # Create non-Claude directories (should be excluded)
    (home / '.config').mkdir()
    (home / 'Documents').mkdir()
    (home / 'node_modules').mkdir()

    # Create target directories
    (home / '.codex').mkdir()
    (home / '.codex-work').mkdir()
    (home / '.gemini').mkdir()

    from src.account_discovery import discover_claude_configs, validate_claude_config, discover_target_configs

    # Test discovery
    configs = discover_claude_configs(home_dir=home, max_depth=2)
    names = [p.name for p in configs]
    assert '.claude' in names, f'Found .claude: {names}'
    assert '.claude-personal1' in names, f'Found .claude-personal1: {names}'
    assert '.claude-work' in names, f'Found .claude-work: {names}'
    assert '.config' not in names, f'Excluded .config: {names}'
    assert 'Documents' not in names, f'Excluded Documents: {names}'

    # Test validation
    assert validate_claude_config(home / '.claude') is True, 'Valid config (has settings.json)'
    assert validate_claude_config(home / '.claude-personal1') is True, 'Valid config (has CLAUDE.md)'
    assert validate_claude_config(home / '.config') is False, 'Not a Claude config'

    # Test target discovery
    targets = discover_target_configs(home_dir=home)
    assert 'codex' in targets, f'Found codex targets: {targets}'
    assert len(targets['codex']) == 2, f'Two codex dirs: {targets[\"codex\"]}'

    print('All AccountDiscovery tests passed')
" (Level 1: Sanity)
  </verify>
  <done>AccountDiscovery discovers ~/.claude* directories with depth-limited scanning, validates discovered paths for Claude Code config structure, and discovers target CLI directories. All scans handle permission errors gracefully and exclude known large directories.</done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- AccountManager creates/reads/updates/deletes accounts in accounts.json
- AccountManager validates name format (no spaces, alphanumeric+dash+underscore)
- AccountManager detects target path collisions across accounts
- AccountManager atomic writes survive process interruption (tempfile+replace pattern)
- AccountDiscovery finds .claude* directories at depth 1 of home
- AccountDiscovery excludes node_modules, .git, .cache, Library, etc.
- AccountDiscovery validates Claude config directories (has settings.json or CLAUDE.md)
- Both modules use only stdlib imports

Level 2 (Proxy):
- AccountManager persists across process restarts (write + reload)
- AccountDiscovery completes in <500ms on test directory with 50+ entries
- Target collision error messages identify both conflicting accounts

Level 3 (Deferred):
- Performance on production home directories (1M+ files)
- Cross-platform path handling (Windows backslash)
</verification>

<success_criteria>
1. AccountManager handles full lifecycle: add -> get -> update -> remove -> list with atomic persistence
2. AccountDiscovery finds all .claude* directories within bounded depth scan
3. Target path collision validation prevents cross-account contamination at configuration time
4. Both modules follow established HarnessSync patterns (zero deps, atomic writes, error handling)
</success_criteria>

<output>
After completion, create `.planning/phases/08-multi-account-support/08-01-SUMMARY.md`
</output>
