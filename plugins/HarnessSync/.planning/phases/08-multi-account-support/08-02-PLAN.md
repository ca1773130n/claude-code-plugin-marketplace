---
phase: 08-multi-account-support
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [src/source_reader.py, src/state_manager.py]
autonomous: true
verification_level: sanity

must_haves:
  truths:
    - "SourceReader accepts optional cc_home parameter to override default ~/.claude/ path"
    - "SourceReader with custom cc_home discovers rules, skills, agents, commands, MCP, settings from that path instead of ~/.claude/"
    - "StateManager v2 nests state by account: state['accounts'][account_name]['targets'][target_name]"
    - "StateManager auto-migrates v1 state (flat targets) to v2 by wrapping in 'default' account on first load"
    - "StateManager record_sync and detect_drift accept account parameter for account-scoped operations"
    - "v1 state.json (without accounts key) is transparently migrated to v2 schema without data loss"
  artifacts:
    - path: "src/source_reader.py"
      provides: "Parameterized SourceReader with cc_home override"
      exports: ["SourceReader"]
    - path: "src/state_manager.py"
      provides: "Account-aware StateManager with v2 schema and migration"
      exports: ["StateManager"]
  key_links:
    - from: "src/source_reader.py"
      to: "cc_home parameter"
      via: "Path constructor in __init__"
      pattern: "cc_home.*Path"
    - from: "src/state_manager.py"
      to: "accounts nested structure"
      via: "account parameter in record_sync/detect_drift"
      pattern: "def record_sync.*account|def detect_drift.*account"
---

<objective>
Extend SourceReader with cc_home parameterization and upgrade StateManager to v2 schema with per-account state nesting and automatic v1 migration.

Purpose: These modifications enable the core sync engine to operate on arbitrary Claude Code directories (not just ~/.claude/) and track state per account without cross-contamination. This is the data layer foundation for multi-account support.

Output: Modified src/source_reader.py (backward-compatible cc_home parameter) and src/state_manager.py (v2 schema with migration from v1).
</objective>

<execution_context>
@${CLAUDE_PLUGIN_ROOT}/references/execute-plan.md
@${CLAUDE_PLUGIN_ROOT}/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-multi-account-support/08-RESEARCH.md
@src/source_reader.py
@src/state_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Parameterize SourceReader cc_home for multi-account source discovery</name>
  <files>src/source_reader.py</files>
  <action>
    Modify src/source_reader.py to accept an optional cc_home parameter:

    1. Update __init__ signature:
       def __init__(self, scope: str = "all", project_dir: Path = None, cc_home: Path = None):

    2. Replace hardcoded path:
       OLD: self.cc_home = Path.home() / ".claude"
       NEW: self.cc_home = cc_home if cc_home is not None else Path.home() / ".claude"

    3. Update all derived paths that use self.cc_home:
       - self.cc_settings = self.cc_home / "settings.json"
       - self.cc_plugins_registry = self.cc_home / "plugins" / "installed_plugins.json"
       - self.cc_skills = self.cc_home / "skills"
       - self.cc_agents = self.cc_home / "agents"
       - self.cc_commands = self.cc_home / "commands"
       - self.cc_mcp_claude = self.cc_home / ".mcp.json"

    4. Keep self.cc_mcp_global as Path.home() / ".mcp.json" since global MCP config is user-level, not account-level. BUT add a parameter to override this too for testing:
       self.cc_mcp_global = cc_home.parent / ".mcp.json" if cc_home is not None else Path.home() / ".mcp.json"
       Actually, reconsider: The global .mcp.json at ~ is truly global. When cc_home is overridden (e.g., ~/.claude-work/), the global MCP config is still at ~/.mcp.json. Keep it as Path.home() / ".mcp.json" always.

    5. This change MUST be backward compatible:
       - Existing code calling SourceReader(scope="all", project_dir=some_path) still works identically
       - Only callers passing cc_home= get different behavior
       - Default cc_home=None preserves existing ~/.claude/ behavior

    6. Do NOT modify any method logic (get_rules, get_skills, etc.) â€” they already use self.cc_home, self.cc_skills, etc. so parameterization flows through automatically.

    7. Update the class docstring to mention the cc_home parameter.
  </action>
  <verify>
    python -c "
import tempfile, os, sys
sys.path.insert(0, '.')
from pathlib import Path

with tempfile.TemporaryDirectory() as td:
    custom_home = Path(td) / '.claude-work'
    custom_home.mkdir(parents=True)

    # Create mock config files
    (custom_home / 'CLAUDE.md').write_text('# Work rules')
    (custom_home / 'settings.json').write_text('{\"key\": \"value\"}')
    skills_dir = custom_home / 'skills' / 'test-skill'
    skills_dir.mkdir(parents=True)
    (skills_dir / 'SKILL.md').write_text('---\ndescription: test\n---\nTest skill')

    from src.source_reader import SourceReader

    # Test with custom cc_home (user scope only to avoid project scope issues)
    reader = SourceReader(scope='user', cc_home=custom_home)
    assert reader.cc_home == custom_home, f'cc_home set: {reader.cc_home}'
    assert reader.cc_settings == custom_home / 'settings.json', 'settings path derived'
    assert reader.cc_skills == custom_home / 'skills', 'skills path derived'

    # Test rules discovery from custom path
    rules = reader.get_rules()
    assert 'Work rules' in rules, f'Found custom rules: {rules}'

    # Test default (no cc_home)
    reader_default = SourceReader(scope='user')
    assert reader_default.cc_home == Path.home() / '.claude', 'Default cc_home preserved'

    # Test backward compatibility (original signature still works)
    reader_compat = SourceReader(scope='all', project_dir=Path(td))
    assert reader_compat.cc_home == Path.home() / '.claude', 'Backward compatible'

    print('All SourceReader parameterization tests passed')
" (Level 1: Sanity)
  </verify>
  <done>SourceReader accepts optional cc_home parameter, derives all internal paths from it, and remains fully backward compatible when cc_home is not provided.</done>
</task>

<task type="auto">
  <name>Task 2: Upgrade StateManager to v2 schema with account nesting and v1 migration</name>
  <files>src/state_manager.py</files>
  <action>
    Modify src/state_manager.py to support per-account state tracking:

    1. Update state schema to v2:
       {
         "version": 2,
         "last_sync": "...",
         "accounts": {
           "personal": {
             "last_sync": "...",
             "targets": {
               "codex": { "last_sync": "...", "status": "...", "file_hashes": {...}, ... }
             }
           }
         },
         "targets": { ... }  # Kept for backward compatibility during transition
       }

    2. Add v1-to-v2 migration in _load():
       - If state has "version": 1 and "targets" but no "accounts":
         * Create "accounts" dict with single "default" account
         * Move existing targets into accounts["default"]["targets"]
         * Set version to 2
         * Set default_account to "default"
         * Preserve original "targets" key for backward compatibility
         * Log migration (print to stderr)
         * Auto-save migrated state
       - If state has no "version" key (legacy cc2all), migrate to v2 directly

    3. Add account-aware record_sync method (overload existing):
       def record_sync(self, target, scope, file_hashes, sync_methods, synced, skipped, failed, account=None):
       - If account is None, use backward-compatible v1 behavior (write to state["targets"][target])
       - If account is provided, write to state["accounts"][account]["targets"][target]
       - Also update state["accounts"][account]["last_sync"]
       - This preserves FULL backward compatibility: existing callers passing no account= work identically

    4. Add account-aware detect_drift (overload existing):
       def detect_drift(self, target, current_hashes, account=None):
       - If account is None, use v1 behavior (read from state["targets"][target])
       - If account is provided, read from state["accounts"][account]["targets"][target]

    5. Add new methods:
       - get_account_status(account: str) -> dict | None: Return account state (last_sync + targets)
       - list_state_accounts() -> list[str]: Return list of account names in state
       - get_account_target_status(account: str, target: str) -> dict | None: Get specific account+target state

    6. Update get_all_status() to include accounts data.

    7. Keep ALL existing methods and their behavior unchanged when account= is not passed. This is critical for backward compatibility with existing /sync, /sync-status, hooks, and MCP tools that don't know about accounts yet.

    8. Ensure the v1 migration only happens ONCE (check version number).
  </action>
  <verify>
    python -c "
import tempfile, os, sys, json
sys.path.insert(0, '.')
from pathlib import Path

with tempfile.TemporaryDirectory() as td:
    state_dir = Path(td)

    # === Test 1: v1 migration ===
    # Create v1 state file
    v1_state = {
        'version': 1,
        'last_sync': '2026-02-15T10:00:00',
        'targets': {
            'codex': {
                'last_sync': '2026-02-15T10:00:00',
                'status': 'success',
                'scope': 'all',
                'file_hashes': {'/path/to/file': 'abc123'},
                'items_synced': 5,
                'items_skipped': 0,
                'items_failed': 0
            }
        }
    }
    (state_dir / 'state.json').write_text(json.dumps(v1_state, indent=2))

    from src.state_manager import StateManager
    sm = StateManager(state_dir=state_dir)

    # Check migration happened
    state = sm.get_all_status()
    assert state.get('version') == 2, f'Migrated to v2: {state.get(\"version\")}'
    assert 'accounts' in state, 'Has accounts key'
    assert 'default' in state['accounts'], 'Default account created'
    assert 'codex' in state['accounts']['default']['targets'], 'Targets migrated'
    assert state['accounts']['default']['targets']['codex']['status'] == 'success', 'Status preserved'

    # === Test 2: backward-compatible record_sync (no account) ===
    sm.record_sync('gemini', 'all', {'/f1': 'h1'}, {'/f1': 'copy'}, 3, 1, 0)
    assert sm.get_target_status('gemini') is not None, 'v1-style target recorded'
    assert sm.get_target_status('gemini')['status'] == 'success', 'Status correct'

    # === Test 3: account-aware record_sync ===
    sm.record_sync('codex', 'user', {'/f2': 'h2'}, {'/f2': 'symlink'}, 2, 0, 0, account='work')
    work_status = sm.get_account_target_status('work', 'codex')
    assert work_status is not None, 'Account target recorded'
    assert work_status['items_synced'] == 2, 'Items correct'

    # === Test 4: account-aware drift detection ===
    drift = sm.detect_drift('codex', {'/f2': 'h2_changed'}, account='work')
    assert '/f2' in drift, 'Drift detected for account'

    # === Test 5: backward-compatible drift detection ===
    drift_v1 = sm.detect_drift('gemini', {'/f1': 'h1_changed'})
    assert '/f1' in drift_v1, 'v1-style drift detected'

    # === Test 6: list accounts ===
    accounts = sm.list_state_accounts()
    assert 'default' in accounts, 'Default account in list'
    assert 'work' in accounts, 'Work account in list'

    # === Test 7: fresh state (no migration needed) ===
    state_dir2 = Path(td) / 'fresh'
    state_dir2.mkdir()
    sm2 = StateManager(state_dir=state_dir2)
    fresh_state = sm2.get_all_status()
    assert fresh_state.get('version') in (1, 2), f'Fresh state valid: {fresh_state}'

    print('All StateManager v2 tests passed')
" (Level 1: Sanity)
  </verify>
  <done>StateManager supports v2 schema with per-account state nesting, auto-migrates v1 state to v2 with "default" account, and maintains full backward compatibility for all existing callers that don't pass account parameter.</done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- SourceReader with cc_home=Path("/custom/.claude") uses custom path for all internal paths
- SourceReader with no cc_home defaults to ~/.claude/ (backward compatible)
- StateManager loads v1 state.json and migrates to v2 schema
- StateManager record_sync(account=None) writes to flat targets (v1 compat)
- StateManager record_sync(account="work") writes to accounts.work.targets
- StateManager detect_drift works with and without account parameter
- Migration preserves all v1 data (file_hashes, status, timestamps)

Level 2 (Proxy):
- v1 state with 3 targets migrates correctly (all targets under "default" account)
- Existing /sync command works unchanged (no account parameter passed)
- Existing /sync-status command works unchanged
- PostToolUse hook works unchanged

Level 3 (Deferred):
- Migration of corrupted v1 state files
- Concurrent access during migration
</verification>

<success_criteria>
1. SourceReader cc_home parameterization is fully backward compatible (no existing code breaks)
2. StateManager v2 migration is lossless (all v1 data preserved under "default" account)
3. All existing StateManager callers work identically when not passing account parameter
4. Account-scoped record_sync and detect_drift isolate state per account
</success_criteria>

<output>
After completion, create `.planning/phases/08-multi-account-support/08-02-SUMMARY.md`
</output>
