---
phase: 08-multi-account-support
plan: 04
type: execute
wave: 2
depends_on: [08-01, 08-02]
files_modified: [src/orchestrator.py, src/commands/sync.py, src/commands/sync_status.py, commands/sync.md, commands/sync-status.md]
autonomous: true
verification_level: proxy

must_haves:
  truths:
    - "SyncOrchestrator accepts optional account parameter and uses AccountManager to resolve source/target paths"
    - "SyncOrchestrator with account= creates SourceReader with account-specific cc_home and records state per account"
    - "SyncOrchestrator without account= works identically to v1 (backward compatible)"
    - "/sync --account NAME syncs only the specified account's source to its configured targets"
    - "/sync without --account syncs all configured accounts (or v1 behavior if no accounts configured)"
    - "/sync-status --account NAME shows per-target status for specific account"
    - "/sync-status --list-accounts shows all configured accounts with sync status"
    - "Account sync isolation: syncing account A does not modify account B state or files"
  artifacts:
    - path: "src/orchestrator.py"
      provides: "Account-aware SyncOrchestrator"
      exports: ["SyncOrchestrator"]
    - path: "src/commands/sync.py"
      provides: "/sync command with --account flag"
      exports: ["main"]
    - path: "src/commands/sync_status.py"
      provides: "/sync-status command with --account and --list-accounts flags"
      exports: ["main"]
    - path: "commands/sync.md"
      provides: "Updated slash command definition with --account option"
    - path: "commands/sync-status.md"
      provides: "Updated slash command definition with --account and --list-accounts options"
  key_links:
    - from: "src/orchestrator.py"
      to: "src/account_manager.py"
      via: "AccountManager for account resolution"
      pattern: "from src\\.account_manager import AccountManager"
    - from: "src/orchestrator.py"
      to: "src/source_reader.py"
      via: "SourceReader with cc_home parameter"
      pattern: "SourceReader.*cc_home"
    - from: "src/orchestrator.py"
      to: "src/state_manager.py"
      via: "StateManager with account parameter"
      pattern: "record_sync.*account|detect_drift.*account"
    - from: "src/commands/sync.py"
      to: "src/orchestrator.py"
      via: "SyncOrchestrator with account parameter"
      pattern: "SyncOrchestrator.*account"
---

<objective>
Extend SyncOrchestrator, /sync, and /sync-status with account-aware operations, enabling per-account sync and status reporting while maintaining full backward compatibility.

Purpose: This plan connects the foundation modules (AccountManager, SourceReader cc_home, StateManager v2) to user-facing commands. After this plan, users can sync specific accounts independently and view per-account status with drift detection.

Output: Modified orchestrator, sync command, sync-status command, and updated slash command definitions.
</objective>

<execution_context>
@${CLAUDE_PLUGIN_ROOT}/references/execute-plan.md
@${CLAUDE_PLUGIN_ROOT}/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-multi-account-support/08-RESEARCH.md
@.planning/phases/08-multi-account-support/08-01-SUMMARY.md
@.planning/phases/08-multi-account-support/08-02-SUMMARY.md
@src/orchestrator.py
@src/commands/sync.py
@src/commands/sync_status.py
@commands/sync.md
@commands/sync-status.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend SyncOrchestrator with account-aware sync operations</name>
  <files>src/orchestrator.py</files>
  <action>
    Modify src/orchestrator.py to support per-account sync:

    1. Add import:
       from src.account_manager import AccountManager

    2. Update __init__ signature:
       def __init__(self, project_dir: Path, scope: str = "all", dry_run: bool = False,
                    allow_secrets: bool = False, account: str = None, cc_home: Path = None):
       - account: Optional account name from AccountManager
       - cc_home: Optional override for SourceReader (derived from account if provided)
       - Store self.account = account
       - If account is provided and cc_home is not:
         * Load AccountManager
         * Get account config: am.get_account(account)
         * Set cc_home from account config source.path
         * Store self.account_config for target path resolution

    3. Modify sync_all():
       - When constructing SourceReader, pass cc_home:
         reader = SourceReader(scope=self.scope, project_dir=self.project_dir, cc_home=self.cc_home)
       - When calling state_manager.record_sync(), pass account=self.account
       - When calling state_manager.detect_drift(), pass account=self.account
       - If account config has specific target paths, pass them to adapters
         (This may require adapters to accept target_dir parameter - check adapter base)

    4. Add sync_account(account_name: str) method:
       - Load account config from AccountManager
       - Create SourceReader with account's cc_home
       - Sync to account's configured targets only
       - Record state per account
       - Return results dict

    5. Add sync_all_accounts() method:
       - Load AccountManager
       - If no accounts configured, fall back to sync_all() (v1 behavior)
       - If accounts configured, iterate over all accounts and call sync_account() for each
       - Return dict mapping account_name -> results
       - Sequential sync (per research: acceptable for 2-3 accounts)

    6. CRITICAL backward compatibility:
       - When account=None (default), ALL existing behavior unchanged
       - sync_all() with no account parameter works exactly as before
       - Only when account= is explicitly passed does account-aware behavior activate

    7. For target path resolution with accounts:
       - Check if adapters accept target_dir or similar parameter
       - If adapters are currently hardcoded to ~/.codex/, ~/.gemini/, ~/.opencode/:
         * Need to check adapter __init__ or sync methods for path parameterization
         * If hardcoded, add target_dir parameter to adapter base class sync methods
         * OR set environment variable / class variable before sync
       - Research the adapter base class and concrete adapters to determine approach
       - The simplest approach: adapters already use self.target_dir or similar that can be overridden
       - If not, add it as a parameter to AdapterRegistry.sync() or individual adapter constructors
  </action>
  <verify>
    python -c "
import sys, os
sys.path.insert(0, '.')
from pathlib import Path

# Verify imports work
from src.orchestrator import SyncOrchestrator

# Verify backward compatibility (no account parameter)
import inspect
sig = inspect.signature(SyncOrchestrator.__init__)
params = list(sig.parameters.keys())
assert 'account' in params, f'Has account parameter: {params}'
assert 'cc_home' in params, f'Has cc_home parameter: {params}'

# Verify default values preserve backward compat
defaults = {k: v.default for k, v in sig.parameters.items() if v.default is not inspect.Parameter.empty}
assert defaults.get('account') is None, 'account defaults to None'
assert defaults.get('cc_home') is None, 'cc_home defaults to None'

# Test construction without account (v1 compat)
try:
    orch = SyncOrchestrator(project_dir=Path('.'), scope='user')
    print('v1-compatible construction works')
except Exception as e:
    print(f'Construction error (may be expected in test env): {e}')

print('All orchestrator extension tests passed')
" (Level 1: Sanity)
  </verify>
  <done>SyncOrchestrator supports account parameter for per-account sync operations with source path resolution from AccountManager, account-scoped state recording, and full backward compatibility when account is not specified.</done>
</task>

<task type="auto">
  <name>Task 2: Extend /sync and /sync-status commands with account flags</name>
  <files>src/commands/sync.py, src/commands/sync_status.py, commands/sync.md, commands/sync-status.md</files>
  <action>
    Extend both commands to support multi-account operations:

    1. src/commands/sync.py modifications:
       a. Add --account argument to argparse:
          parser.add_argument('--account', type=str, default=None,
                              help='Sync specific account (default: all accounts or v1 behavior)')
       b. In main(), after debounce check:
          - If args.account is provided:
            * Create SyncOrchestrator with account=args.account
            * Call orchestrator.sync_all() (which now uses account-scoped paths)
          - If args.account is None:
            * Check if AccountManager has any accounts configured
            * If yes: iterate over all accounts, sync each (call sync_all_accounts or loop)
            * If no: fall back to existing v1 behavior (single sync_all without account)
       c. Update format_results_table to handle account-grouped results:
          - If results are account-keyed, print per-account sections
          - If results are target-keyed (v1 format), print as before
       d. Add --all-accounts flag (explicit sync all accounts, vs default auto-detect)

    2. src/commands/sync_status.py modifications:
       a. Add arguments:
          parser = argparse.ArgumentParser(...)  # Add argparse (currently doesn't use it)
          parser.add_argument('--account', type=str, default=None,
                              help='Show status for specific account')
          parser.add_argument('--list-accounts', action='store_true',
                              help='List all configured accounts')
       b. If --list-accounts:
          - Load AccountManager
          - Print table: Account | Source | Targets | Default | Last Sync
          - For each account, show last sync time from StateManager
       c. If --account NAME:
          - Load account config from AccountManager
          - Create SourceReader with account's cc_home
          - Show per-target status for that account (using StateManager.get_account_target_status)
          - Show drift detection scoped to account
       d. If no flags (default):
          - Check if accounts configured
          - If yes: show status for all accounts (grouped by account)
          - If no: show v1 status (existing behavior)
       e. Need to add argparse to sync_status.py (currently it has no argument parsing)

    3. commands/sync.md update:
       - Add --account option to usage and description:
         Usage: /sync [--scope user|project|all] [--dry-run] [--allow-secrets] [--account NAME]
         - --account NAME: Sync specific account only (omit to sync all accounts)

    4. commands/sync-status.md update:
       - Add new options:
         Usage: /sync-status [--account NAME] [--list-accounts]
         - --account NAME: Show status for specific account
         - --list-accounts: List all configured accounts with sync status

    Follow existing patterns:
    - shlex.split for argument parsing (from sync.py)
    - PLUGIN_ROOT resolution (same as sync.py)
    - Exit 0 always (decision #39)
    - Errors to stderr
  </action>
  <verify>
    python -c "
import sys, os
sys.path.insert(0, '.')
from pathlib import Path

# Verify sync.py accepts --account
import argparse, shlex
from src.commands.sync import main as sync_main

# Check that the argparse in sync.py includes --account
# (We test by checking the source has the argument)
import inspect
source = inspect.getsource(sync_main)
assert '--account' in source, '/sync has --account argument'
print('/sync --account argument present')

# Verify sync_status.py accepts --account and --list-accounts
from src.commands.sync_status import main as status_main
source2 = inspect.getsource(status_main)
assert '--account' in source2, '/sync-status has --account argument'
assert '--list-accounts' in source2 or 'list_accounts' in source2, '/sync-status has --list-accounts'
print('/sync-status --account and --list-accounts arguments present')

# Verify command definitions updated
sync_md = Path('commands/sync.md').read_text()
assert '--account' in sync_md, 'sync.md mentions --account'
status_md = Path('commands/sync-status.md').read_text()
assert '--account' in status_md, 'sync-status.md mentions --account'
assert '--list-accounts' in status_md, 'sync-status.md mentions --list-accounts'

print('All command extension tests passed')
" (Level 1: Sanity)

    python src/commands/sync_status.py --list-accounts 2>/dev/null; echo "sync-status --list-accounts exit: $?" (Level 2: Proxy)
    python src/commands/sync.py --account nonexistent --dry-run 2>/dev/null; echo "sync --account exit: $?" (Level 2: Proxy)
  </verify>
  <done>/sync supports --account NAME for per-account sync, /sync-status supports --account NAME for per-account status and --list-accounts for account listing. Both commands maintain full backward compatibility when no account flags are passed. Slash command definitions updated to document new options.</done>
</task>

<task type="auto">
  <name>Task 3: Integration verification of full multi-account sync pipeline</name>
  <files>src/orchestrator.py</files>
  <action>
    Create and run a comprehensive integration test that validates the full multi-account pipeline end-to-end:

    1. Set up test environment in tempdir:
       - Create two mock Claude Code config directories:
         * {tmp}/.claude-personal/ with CLAUDE.md ("Personal rules"), settings.json
         * {tmp}/.claude-work/ with CLAUDE.md ("Work rules"), settings.json
       - Create AccountManager with two accounts:
         * "personal" -> source: .claude-personal/, targets: {codex: .codex-personal/}
         * "work" -> source: .claude-work/, targets: {codex: .codex-work/}

    2. Test account isolation:
       - Sync "personal" account
       - Verify personal target files created/updated
       - Verify work target files NOT created/modified
       - Sync "work" account
       - Verify work target files created/updated
       - Verify personal target files unchanged

    3. Test state isolation:
       - Check StateManager state for "personal" account has correct file hashes
       - Check StateManager state for "work" account has correct file hashes
       - Verify no cross-contamination between account states

    4. Test status reporting:
       - Verify get_account_target_status("personal", "codex") returns correct data
       - Verify get_account_target_status("work", "codex") returns correct data
       - Verify drift detection works per-account

    5. Test backward compatibility:
       - In a separate tempdir with NO accounts configured
       - Run sync_all() without account parameter
       - Verify v1 behavior (reads from default ~/.claude/, writes to flat state)

    NOTE: This is a verification task, not a code modification task. The test validates the integration works. If it fails, fix issues in orchestrator.py (the only file this plan modifies that orchestrates everything).

    The integration test should be written as an inline Python verification script, not a permanent test file.
  </action>
  <verify>
    python -c "
import sys, os, json, tempfile
sys.path.insert(0, '.')
from pathlib import Path

print('=== Multi-Account Integration Test ===')

with tempfile.TemporaryDirectory() as td:
    td = Path(td)

    # --- Setup: Two Claude Code config dirs ---
    personal_src = td / '.claude-personal'
    personal_src.mkdir()
    (personal_src / 'CLAUDE.md').write_text('# Personal rules\nBe concise.')

    work_src = td / '.claude-work'
    work_src.mkdir()
    (work_src / 'CLAUDE.md').write_text('# Work rules\nBe formal.')

    # --- Setup: Account registry ---
    config_dir = td / '.harnesssync'
    config_dir.mkdir()

    from src.account_manager import AccountManager
    am = AccountManager(config_dir=config_dir)
    am.add_account('personal', personal_src, {'codex': td / '.codex-personal'})
    am.add_account('work', work_src, {'codex': td / '.codex-work'})

    print('[1] AccountManager: 2 accounts configured')
    assert len(am.list_accounts()) == 2

    # --- Test: SourceReader isolation ---
    from src.source_reader import SourceReader
    reader_p = SourceReader(scope='user', cc_home=personal_src)
    rules_p = reader_p.get_rules()
    assert 'Personal rules' in rules_p, f'Personal rules found: {rules_p[:50]}'

    reader_w = SourceReader(scope='user', cc_home=work_src)
    rules_w = reader_w.get_rules()
    assert 'Work rules' in rules_w, f'Work rules found: {rules_w[:50]}'
    assert 'Personal' not in rules_w, 'No cross-contamination in reader'

    print('[2] SourceReader: isolated per cc_home')

    # --- Test: StateManager v2 isolation ---
    from src.state_manager import StateManager
    sm = StateManager(state_dir=config_dir)
    sm.record_sync('codex', 'user', {'/p/file': 'hash_p'}, {}, 1, 0, 0, account='personal')
    sm.record_sync('codex', 'user', {'/w/file': 'hash_w'}, {}, 2, 0, 0, account='work')

    p_status = sm.get_account_target_status('personal', 'codex')
    w_status = sm.get_account_target_status('work', 'codex')
    assert p_status['items_synced'] == 1, 'Personal sync count'
    assert w_status['items_synced'] == 2, 'Work sync count'
    assert p_status['file_hashes'].get('/w/file') is None, 'No cross-contamination in state'

    print('[3] StateManager: account-isolated state')

    # --- Test: Drift detection per account ---
    drift_p = sm.detect_drift('codex', {'/p/file': 'hash_p_changed'}, account='personal')
    assert '/p/file' in drift_p, 'Personal drift detected'

    drift_w = sm.detect_drift('codex', {'/w/file': 'hash_w'}, account='work')
    assert len(drift_w) == 0, 'No work drift (unchanged)'

    print('[4] Drift detection: per-account isolation')

    # --- Test: State persistence ---
    sm2 = StateManager(state_dir=config_dir)
    accounts = sm2.list_state_accounts()
    assert 'personal' in accounts, 'Personal persisted'
    assert 'work' in accounts, 'Work persisted'

    print('[5] State persistence: survives reload')

    print()
    print('=== All integration tests passed ===')
" (Level 2: Proxy)
  </verify>
  <done>Full multi-account pipeline verified: AccountManager stores accounts, SourceReader reads from account-specific paths, StateManager tracks state per account with isolation, drift detection works per account, and all data persists across process restarts.</done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- SyncOrchestrator.__init__ accepts account and cc_home parameters with None defaults
- /sync argparse includes --account argument
- /sync-status argparse includes --account and --list-accounts arguments
- Command definitions (.md files) document new flags
- All existing tests still pass (backward compatibility)

Level 2 (Proxy):
- Full integration test passes: 2 accounts, isolated sync, isolated state, isolated drift detection
- /sync-status --list-accounts executes without crash
- /sync --account nonexistent --dry-run handles gracefully (error message, exit 0)
- v1 behavior preserved when no accounts configured

Level 3 (Deferred):
- Live Claude Code session with /sync --account work
- 3+ accounts synced sequentially in <10 seconds
- Hook-triggered sync with multi-account awareness
</verification>

<success_criteria>
1. SyncOrchestrator routes sync operations to correct source paths based on account configuration
2. /sync --account NAME isolates sync to specified account
3. /sync-status provides per-account status with drift detection
4. Full backward compatibility: no accounts configured = exact v1 behavior
5. No cross-contamination between accounts (state, source, targets all isolated)
</success_criteria>

<output>
After completion, create `.planning/phases/08-multi-account-support/08-04-SUMMARY.md`
</output>
