---
phase: 05-safety-validation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [src/conflict_detector.py, src/secret_detector.py]
autonomous: true
verification_level: proxy

must_haves:
  truths:
    - "ConflictDetector.check() compares current target file SHA256 hash against last recorded hash in StateManager"
    - "ConflictDetector returns list of conflicting files with old hash, new hash, and target name"
    - "ConflictDetector uses hmac.compare_digest() for secure hash comparison (not == operator)"
    - "SecretDetector.scan() detects env vars with names matching API_KEY, SECRET, PASSWORD, TOKEN keywords"
    - "SecretDetector skips env vars with TEST_, EXAMPLE_, DEMO_ prefixes (whitelist)"
    - "SecretDetector requires value to match complexity pattern (16+ alphanumeric chars) to reduce false positives"
    - "SecretDetector blocks sync by default, allows override with allow_secrets=True parameter"
  artifacts:
    - path: "src/conflict_detector.py"
      provides: "Pre-sync conflict detection via hash comparison"
      exports: ["ConflictDetector"]
    - path: "src/secret_detector.py"
      provides: "Environment variable secret scanning"
      exports: ["SecretDetector"]
  key_links:
    - from: "src/conflict_detector.py"
      to: "src/state_manager.py"
      via: "reads stored hashes for comparison"
      pattern: "from.*state_manager.*import.*StateManager"
    - from: "src/conflict_detector.py"
      to: "src/utils/hashing.py"
      via: "uses hash_file_sha256 for current file hashing"
      pattern: "from.*utils.*hashing.*import.*hash_file_sha256"
    - from: "src/secret_detector.py"
      to: "src/utils/logger.py"
      via: "import for warning output"
      pattern: "from.*utils.*logger.*import"
---

<objective>
Implement pre-sync conflict detection (SAF-02) and secret detection (SAF-03).

Purpose: Warn users about manual config edits that would be overwritten (conflict detection) and block sync when environment variables contain potential secrets (secret detection). These are pre-sync validation gates that run before any write operations.

Output: Two independent validator modules -- ConflictDetector for hash-based drift warning and SecretDetector for environment variable scanning.

Research basis: SHA256 hash comparison with hmac.compare_digest() from hashlib/hmac documentation, regex+keyword secret detection approach from TruffleHog/Secrets-Patterns-DB.
</objective>

<execution_context>
@${CLAUDE_PLUGIN_ROOT}/references/execute-plan.md
@${CLAUDE_PLUGIN_ROOT}/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-safety-validation/05-RESEARCH.md
@src/state_manager.py
@src/utils/hashing.py
@src/utils/logger.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ConflictDetector for hash-based drift detection</name>
  <files>src/conflict_detector.py</files>
  <action>
    Create src/conflict_detector.py implementing SAF-02.

    Based on SHA256 hash comparison with hmac.compare_digest() for secure comparison:

    **ConflictDetector class:**
    - __init__(self, state_manager: StateManager = None): Accept optional StateManager for dependency injection (testing). Default: create new StateManager().
    - check(self, target_name: str) -> list[dict]: Check if target config files have been modified outside HarnessSync since last sync.
      1. Get stored state for target from state_manager.get_target_status(target_name)
      2. Extract file_hashes dict from stored state (maps file_path -> stored_hash)
      3. For each file in file_hashes: compute current hash using hash_file_sha256(Path(file_path))
      4. Compare using hmac.compare_digest(stored_hash, current_hash) â€” NOT == operator (per RESEARCH.md Don't Hand-Roll, prevents timing attacks)
      5. If mismatch: append conflict dict {file_path, stored_hash, current_hash, target_name} to results
      6. If file deleted (current hash empty): append conflict dict with current_hash="" and note="deleted"
      7. Return list of conflict dicts (empty list = no conflicts)
    - check_all(self) -> dict[str, list[dict]]: Run check() for all targets (codex, gemini, opencode). Return dict mapping target_name -> list of conflicts.
    - format_warnings(self, conflicts: dict[str, list[dict]]) -> str: Format conflict warnings for user output. For each target with conflicts, show: target name, list of modified files with "(modified)" or "(deleted)" indicator. Use Logger.warn() style formatting.

    Import: hmac (for compare_digest), src.state_manager.StateManager, src.utils.hashing.hash_file_sha256, src.utils.logger.Logger, pathlib.Path.

    Avoid:
    - Using == for hash comparison (timing attack vector per RESEARCH.md)
    - Modifying state during conflict check (read-only operation)
    - Blocking sync on conflict detection (warn only, caller decides whether to proceed)
  </action>
  <verify>
    python3 -c "
import tempfile, os, sys, json
sys.path.insert(0, '.')
from pathlib import Path
from src.conflict_detector import ConflictDetector
from src.state_manager import StateManager
from src.utils.hashing import hash_file_sha256

# Test 1: No conflicts when files unchanged
with tempfile.TemporaryDirectory() as tmpdir:
    os.environ['HARNESSSYNC_STATE_DIR'] = tmpdir
    sm = StateManager(state_dir=Path(tmpdir))

    # Create a config file and record its hash
    config_file = Path(tmpdir) / 'AGENTS.md'
    config_file.write_text('# Agents')
    file_hash = hash_file_sha256(config_file)

    sm.record_sync(
        target='codex',
        scope='all',
        file_hashes={str(config_file): file_hash},
        sync_methods={},
        synced=1, skipped=0, failed=0
    )

    cd = ConflictDetector(state_manager=sm)
    conflicts = cd.check('codex')
    assert len(conflicts) == 0, f'Expected 0 conflicts, got {len(conflicts)}'
    print('PASS: No conflicts when files unchanged')

# Test 2: Detects modification
    config_file.write_text('# Modified Agents')
    conflicts = cd.check('codex')
    assert len(conflicts) == 1, f'Expected 1 conflict, got {len(conflicts)}'
    assert conflicts[0]['file_path'] == str(config_file), 'Wrong file in conflict'
    print('PASS: Detects file modification')

# Test 3: Detects deletion
    config_file.unlink()
    conflicts = cd.check('codex')
    assert len(conflicts) == 1, f'Expected 1 conflict, got {len(conflicts)}'
    assert conflicts[0].get('note') == 'deleted' or conflicts[0]['current_hash'] == '', 'Deletion not detected'
    print('PASS: Detects file deletion')

# Test 4: check_all returns all targets
    result = cd.check_all()
    assert isinstance(result, dict), 'check_all should return dict'
    print('PASS: check_all returns dict')

# Test 5: format_warnings produces output
    # Re-create file with different content
    config_file.write_text('# Different')
    sm.record_sync(target='codex', scope='all', file_hashes={str(config_file): 'oldhash'}, sync_methods={}, synced=1, skipped=0, failed=0)
    conflicts_all = cd.check_all()
    warning = cd.format_warnings(conflicts_all)
    assert isinstance(warning, str), 'format_warnings should return string'
    print('PASS: format_warnings produces string output')

print('All 5 conflict detector tests passed')
" (Level 2: Proxy)
  </verify>
  <done>
    ConflictDetector compares current file hashes against stored state using hmac.compare_digest(), detects both modifications and deletions, provides formatted warnings, and operates read-only without modifying state. Supports both single-target and all-target scanning.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SecretDetector for environment variable scanning</name>
  <files>src/secret_detector.py</files>
  <action>
    Create src/secret_detector.py implementing SAF-03.

    Based on regex+keyword approach from TruffleHog/Secrets-Patterns-DB (reduces false positives from 60% to 15-20%):

    **Module-level constants:**
    - SECRET_KEYWORDS: List of keyword strings to match in env var names: ['API_KEY', 'APIKEY', 'API-KEY', 'SECRET', 'SECRET_KEY', 'PASSWORD', 'PASSWD', 'PWD', 'TOKEN', 'ACCESS_TOKEN', 'AUTH_TOKEN', 'PRIVATE_KEY']
    - SAFE_PREFIXES: List of prefixes to whitelist: ['TEST_', 'EXAMPLE_', 'DEMO_', 'MOCK_', 'FAKE_', 'DUMMY_']
    - SECRET_VALUE_PATTERN: Compiled regex re.compile(r'^[A-Za-z0-9_\-+=/.]{16,}$') -- value must be 16+ chars of alphanumeric/special to be suspicious

    **SecretDetector class:**
    - __init__(self): Initialize Logger instance.
    - scan(self, env_vars: dict[str, str]) -> list[dict]: Scan environment variables for potential secrets. For each var_name, var_value in env_vars:
      1. Skip if var_name.upper() starts with any SAFE_PREFIX
      2. Skip if var_name.upper() does not contain any SECRET_KEYWORD
      3. Skip if var_value does not match SECRET_VALUE_PATTERN (too short or not complex enough)
      4. If all checks pass: append detection dict {var_name, keywords_matched: list, confidence: 'medium', reason: str}
      Return list of detection dicts.
    - scan_mcp_env(self, mcp_servers: dict) -> list[dict]: Extract env vars from MCP server configurations (the 'env' dict within each server config), then pass to scan(). This is the primary entry point since MCP configs carry env vars that get synced to targets.
    - should_block(self, detections: list[dict], allow_secrets: bool = False) -> bool: Return True if detections is non-empty AND allow_secrets is False.
    - format_warnings(self, detections: list[dict]) -> str: Format secret detection warnings. Show: count of detected secrets, list of var names (mask the values!), instruction to use --allow-secrets to override.

    CRITICAL: Never log or display the actual secret values. Only show variable names and detection reason.

    Import: re, src.utils.logger.Logger.

    Avoid:
    - Logging or printing secret values (security risk per RESEARCH.md)
    - Using entropy-based detection (deferred per RESEARCH.md Open Question 2 -- start with regex+keyword)
    - Blocking sync without providing override mechanism (--allow-secrets)
    - Matching overly broad patterns that cause false positive fatigue (per RESEARCH.md Pitfall 4)
  </action>
  <verify>
    python3 -c "
import sys
sys.path.insert(0, '.')
from src.secret_detector import SecretDetector

sd = SecretDetector()

# Test 1: Detects API key pattern
detections = sd.scan({
    'OPENAI_API_KEY': 'sk-abcdefghijklmnop1234567890abcdef',
    'HOME': '/Users/test'
})
assert len(detections) == 1, f'Expected 1 detection, got {len(detections)}'
assert detections[0]['var_name'] == 'OPENAI_API_KEY', 'Wrong var detected'
print('PASS: Detects API key pattern')

# Test 2: Skips TEST_ prefix
detections = sd.scan({
    'TEST_API_KEY': 'sk-abcdefghijklmnop1234567890abcdef',
    'EXAMPLE_TOKEN': 'tok-abcdefghijklmnop12345678'
})
assert len(detections) == 0, f'Expected 0 detections, got {len(detections)}'
print('PASS: Skips TEST_ and EXAMPLE_ prefixes')

# Test 3: Skips short values (not complex enough)
detections = sd.scan({
    'MY_API_KEY': 'short',
    'DB_PASSWORD': '123'
})
assert len(detections) == 0, f'Expected 0 detections, got {len(detections)}'
print('PASS: Skips short/simple values')

# Test 4: should_block respects allow_secrets
detections = sd.scan({'MY_SECRET': 'abcdefghijklmnopqrstuvwxyz1234567890'})
assert sd.should_block(detections, allow_secrets=False) == True, 'Should block without override'
assert sd.should_block(detections, allow_secrets=True) == False, 'Should not block with override'
print('PASS: should_block respects allow_secrets')

# Test 5: format_warnings masks values
warning = sd.format_warnings(detections)
assert 'MY_SECRET' in warning, 'Variable name should be in warning'
assert 'abcdefghijklmnop' not in warning, 'Value should NOT be in warning'
assert 'allow-secrets' in warning.lower() or 'allow_secrets' in warning.lower(), 'Override hint missing'
print('PASS: format_warnings masks values and shows override hint')

# Test 6: scan_mcp_env extracts env vars from MCP configs
mcp = {
    'server1': {
        'command': 'node',
        'args': ['server.js'],
        'env': {
            'API_KEY': 'sk-verylongsecretkeythatislongenough1234',
            'PORT': '3000'
        }
    }
}
detections = sd.scan_mcp_env(mcp)
assert len(detections) == 1, f'Expected 1 MCP detection, got {len(detections)}'
print('PASS: scan_mcp_env extracts and scans MCP env vars')

print('All 6 secret detector tests passed')
" (Level 2: Proxy)
  </verify>
  <done>
    SecretDetector scans environment variables using regex+keyword approach with 15-20% false positive rate (vs 60% regex-only), whitelists TEST_/EXAMPLE_/DEMO_ prefixes, requires 16+ char complex values, blocks sync by default with allow_secrets override, never exposes secret values in output, and supports scanning MCP server environment configurations.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- S1: ConflictDetector class exists with check, check_all, format_warnings methods
- S2: hmac.compare_digest used for hash comparison (grep verify)
- S3: SecretDetector class exists with scan, scan_mcp_env, should_block, format_warnings methods
- S4: SECRET_KEYWORDS list contains API_KEY, SECRET, PASSWORD, TOKEN
- S5: SAFE_PREFIXES list contains TEST_, EXAMPLE_, DEMO_

Level 2 (Proxy):
- P1: ConflictDetector detects file modification via hash mismatch
- P2: ConflictDetector detects file deletion
- P3: SecretDetector detects API key pattern in env vars
- P4: SecretDetector skips whitelisted prefixes and short values
- P5: should_block returns False when allow_secrets=True
- P6: format_warnings never contains actual secret values

Level 3 (Deferred):
- DEFER-05-03: Secret detection on production .env files (security risk -- requires sanitized test data)
- DEFER-05-04: Entropy-based detection (deferred per RESEARCH.md Open Question 2)
</verification>

<success_criteria>
1. ConflictDetector detects modifications and deletions using hmac.compare_digest() hash comparison
2. SecretDetector identifies secrets via keyword+regex with whitelist filtering
3. Secret values never appear in logs or output
4. allow_secrets override bypasses blocking
5. All 11 verification tests pass (5 conflict + 6 secret)
6. No external dependencies added (Python stdlib only)
</success_criteria>

<output>
After completion, create `.planning/phases/05-safety-validation/05-02-SUMMARY.md`
</output>
