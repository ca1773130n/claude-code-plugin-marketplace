---
phase: 05-safety-validation
plan: 03
type: execute
wave: 2
depends_on: [05-01, 05-02]
files_modified: [src/compatibility_reporter.py, src/orchestrator.py, src/commands/sync.py]
autonomous: true
verification_level: proxy

must_haves:
  truths:
    - "CompatibilityReporter.generate() produces per-target breakdown of synced/adapted/skipped/failed items with explanations"
    - "CompatibilityReporter output distinguishes 'synced' (direct map), 'adapted' (format translation), and 'failed' (incompatible)"
    - "SyncOrchestrator.sync_all() runs conflict detection before sync and warns on hash mismatches"
    - "SyncOrchestrator.sync_all() runs secret detection on MCP env vars and blocks if secrets found (unless allow_secrets=True)"
    - "SyncOrchestrator.sync_all() runs backup before sync and rolls back on failure"
    - "SyncOrchestrator.sync_all() runs symlink cleanup after successful sync"
    - "/sync command accepts --allow-secrets flag and passes it through to orchestrator"
    - "Compatibility report displayed after sync completes (if any adapted or failed items)"
  artifacts:
    - path: "src/compatibility_reporter.py"
      provides: "Sync compatibility analysis and reporting"
      exports: ["CompatibilityReporter"]
    - path: "src/orchestrator.py"
      provides: "Updated orchestrator integrating all safety features"
    - path: "src/commands/sync.py"
      provides: "Updated /sync command with --allow-secrets flag"
  key_links:
    - from: "src/orchestrator.py"
      to: "src/backup_manager.py"
      via: "import BackupManager for pre-sync backup"
      pattern: "from.*backup_manager.*import"
    - from: "src/orchestrator.py"
      to: "src/conflict_detector.py"
      via: "import ConflictDetector for pre-sync check"
      pattern: "from.*conflict_detector.*import"
    - from: "src/orchestrator.py"
      to: "src/secret_detector.py"
      via: "import SecretDetector for env var scanning"
      pattern: "from.*secret_detector.*import"
    - from: "src/orchestrator.py"
      to: "src/symlink_cleaner.py"
      via: "import SymlinkCleaner for post-sync cleanup"
      pattern: "from.*symlink_cleaner.*import"
    - from: "src/orchestrator.py"
      to: "src/compatibility_reporter.py"
      via: "import CompatibilityReporter for result analysis"
      pattern: "from.*compatibility_reporter.*import"
    - from: "src/commands/sync.py"
      to: "src/orchestrator.py"
      via: "passes allow_secrets parameter"
      pattern: "allow_secrets"
---

<objective>
Implement compatibility reporting (SAF-04) and integrate all safety features (SAF-01 through SAF-05) into the sync orchestrator and /sync command.

Purpose: Complete the safety validation pipeline by (1) creating the compatibility reporter that analyzes sync results, and (2) wiring backup, conflict detection, secret scanning, and symlink cleanup into the existing orchestrator. This is the integration plan that makes all Phase 5 safety features operational.

Output: CompatibilityReporter module and updated orchestrator.py + sync.py with full safety pipeline.

Research basis: Aggregate SyncResult data for compatibility reporting (existing adapter pattern), integration of backup/rollback context pattern.
</objective>

<execution_context>
@${CLAUDE_PLUGIN_ROOT}/references/execute-plan.md
@${CLAUDE_PLUGIN_ROOT}/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-safety-validation/05-RESEARCH.md
@.planning/phases/05-safety-validation/05-01-SUMMARY.md
@.planning/phases/05-safety-validation/05-02-SUMMARY.md
@src/orchestrator.py
@src/commands/sync.py
@src/adapters/result.py
@src/backup_manager.py
@src/conflict_detector.py
@src/secret_detector.py
@src/symlink_cleaner.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CompatibilityReporter for sync result analysis</name>
  <files>src/compatibility_reporter.py</files>
  <action>
    Create src/compatibility_reporter.py implementing SAF-04.

    **CompatibilityReporter class:**
    - __init__(self): Initialize Logger.
    - generate(self, results: dict) -> dict: Analyze sync results from orchestrator. Input: dict mapping target_name -> {config_type: SyncResult}. Output: dict mapping target_name -> report dict with:
      - synced_items: list of {config_type, count, files: list} -- items that mapped directly
      - adapted_items: list of {config_type, count, explanation: str} -- items requiring format translation. Explanation derived from config_type:
        - "rules": "Rules content concatenated/inlined to target format"
        - "agents": "Agent .md files converted to target skill/agent format"
        - "commands": "Command .md files converted to target format"
        - "mcp": "MCP server config translated from JSON to target format"
        - "settings": "Settings mapped with conservative permission defaults"
        - "skills": "Skills synced via symlinks" (or "Skills inlined for Gemini")
      - skipped_items: list of {config_type, count, files: list} -- items skipped (already current or incompatible)
      - failed_items: list of {config_type, count, files: list, reasons: list} -- items that failed to sync
      - summary: {total_synced, total_adapted, total_skipped, total_failed, status}
    - format_report(self, report: dict) -> str: Format compatibility report for user output. Structure:
      - Header: "Sync Compatibility Report"
      - Per target section with target name header
      - Green checkmark items for synced (direct map)
      - Yellow arrow items for adapted (with explanation)
      - Gray dash items for skipped
      - Red X items for failed (with reason)
      - Footer summary: "N synced | N adapted | N skipped | N failed"
    - has_issues(self, report: dict) -> bool: Return True if any target has adapted or failed items (used by orchestrator to decide whether to display report).

    The SyncResult dataclass already has synced/skipped/failed/adapted counts and file lists from src/adapters/result.py. CompatibilityReporter aggregates and enriches these with explanations.

    Import: src.adapters.result.SyncResult, src.utils.logger.Logger.

    Avoid:
    - Modifying SyncResult objects (read-only analysis)
    - Duplicating count logic already in SyncResult (use .synced, .adapted, .failed, .skipped properties)
  </action>
  <verify>
    python3 -c "
import sys
sys.path.insert(0, '.')
from src.compatibility_reporter import CompatibilityReporter
from src.adapters.result import SyncResult

cr = CompatibilityReporter()

# Test 1: Generate report from sync results
results = {
    'codex': {
        'rules': SyncResult(synced=1, adapted=1, synced_files=['AGENTS.md']),
        'skills': SyncResult(synced=3, synced_files=['skill1.md', 'skill2.md', 'skill3.md']),
        'mcp': SyncResult(synced=2, adapted=2, failed=1, failed_files=['broken_server']),
    },
    'gemini': {
        'rules': SyncResult(synced=1, adapted=1),
        'skills': SyncResult(adapted=3),
    }
}
report = cr.generate(results)
assert 'codex' in report, 'Missing codex in report'
assert 'gemini' in report, 'Missing gemini in report'
assert 'summary' in report['codex'], 'Missing summary in codex report'
print('PASS: Generate produces per-target report')

# Test 2: Summary counts are correct
codex_summary = report['codex']['summary']
assert codex_summary['total_synced'] == 6, f'Expected 6 synced, got {codex_summary[\"total_synced\"]}'
assert codex_summary['total_failed'] == 1, f'Expected 1 failed, got {codex_summary[\"total_failed\"]}'
print('PASS: Summary counts correct')

# Test 3: format_report produces readable output
formatted = cr.format_report(report)
assert 'codex' in formatted.lower() or 'Codex' in formatted, 'Target name missing'
assert 'gemini' in formatted.lower() or 'Gemini' in formatted, 'Target name missing'
assert isinstance(formatted, str), 'format_report should return string'
print('PASS: format_report produces output')

# Test 4: has_issues detects adapted/failed items
assert cr.has_issues(report) == True, 'Should have issues (adapted + failed items)'
print('PASS: has_issues detects issues')

# Test 5: Clean report has no issues
clean_results = {
    'codex': {
        'rules': SyncResult(synced=1),
        'skills': SyncResult(synced=2),
    }
}
clean_report = cr.generate(clean_results)
assert cr.has_issues(clean_report) == False, 'Clean report should have no issues'
print('PASS: Clean report has no issues')

print('All 5 compatibility reporter tests passed')
" (Level 2: Proxy)
  </verify>
  <done>
    CompatibilityReporter generates per-target breakdown of synced/adapted/skipped/failed items with explanations, produces formatted human-readable report, and correctly identifies when adapted or failed items require user attention.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate all safety features into orchestrator and /sync command</name>
  <files>src/orchestrator.py, src/commands/sync.py</files>
  <action>
    Update src/orchestrator.py to integrate all Phase 5 safety features into the sync pipeline. Update src/commands/sync.py to accept --allow-secrets flag.

    **SyncOrchestrator changes (src/orchestrator.py):**

    1. Add new __init__ parameter: allow_secrets: bool = False. Store as self.allow_secrets.

    2. Add new imports at top of file:
       - from src.backup_manager import BackupManager, BackupContext
       - from src.conflict_detector import ConflictDetector
       - from src.secret_detector import SecretDetector
       - from src.symlink_cleaner import SymlinkCleaner
       - from src.compatibility_reporter import CompatibilityReporter

    3. Modify sync_all() method to implement the full safety pipeline:

       a. **Pre-sync: Secret detection** (before any writes):
          - Create SecretDetector instance
          - Extract MCP env vars from source_data using scan_mcp_env()
          - If detections found and should_block() returns True:
            - Log warning with format_warnings()
            - Return early with special result: {'_blocked': True, '_reason': 'secrets_detected', '_warnings': formatted_warnings}

       b. **Pre-sync: Conflict detection** (before any writes):
          - Create ConflictDetector instance with self.state_manager
          - Run check_all()
          - If conflicts found: Log warning with format_warnings() but DO NOT block (non-blocking per design)
          - Store conflict info for inclusion in results

       c. **Pre-sync: Backup** (before adapter writes, skip in dry-run mode):
          - Create BackupManager instance
          - For each target adapter, identify its output files (target config paths)
          - Use BackupContext to register backups
          - If adapter.sync_all() raises exception, BackupContext auto-rolls back

       d. **Sync: Execute adapters** (existing logic, wrapped in BackupContext):
          - Existing adapter.sync_all() calls remain unchanged
          - If any adapter throws, BackupContext triggers rollback

       e. **Post-sync: Symlink cleanup** (after successful sync, skip in dry-run):
          - Create SymlinkCleaner(self.project_dir)
          - Run cleanup_all()
          - Log removed symlinks count

       f. **Post-sync: Compatibility report** (after sync):
          - Create CompatibilityReporter
          - Generate report from results
          - If has_issues(): store report in results under '_compatibility_report' key

       g. **Post-sync: Backup cleanup** (after successful sync):
          - For each target, run backup_manager.cleanup_old_backups(target_name, keep_count=10)

    4. Keep existing _preview_sync() and _update_state() methods unchanged.

    5. Keep existing get_status() method unchanged.

    **Important integration constraints:**
    - Safety features are additive -- existing sync logic must not break
    - If any safety module import fails (e.g., file missing during development), catch ImportError and log warning, continue without that feature
    - Dry-run mode skips backup, symlink cleanup, and backup cleanup (no side effects)
    - Secret detection and conflict detection still run in dry-run mode (informational)

    **/sync command changes (src/commands/sync.py):**

    1. Add --allow-secrets argument to parser:
       parser.add_argument('--allow-secrets', action='store_true', help='Allow sync even when secrets detected in env vars')

    2. Pass allow_secrets=args.allow_secrets to SyncOrchestrator constructor.

    3. After sync completes, check for '_blocked' in results:
       - If blocked: print the warning message and exit (don't show results table)

    4. After sync completes, check for '_compatibility_report' in results:
       - If present: print the formatted report after the results table

    5. After sync completes, check for '_conflicts' in results:
       - If present: print the conflict warnings before the results table
  </action>
  <verify>
    python3 -c "
import tempfile, os, sys, json
sys.path.insert(0, '.')
from pathlib import Path

# Test 1: Orchestrator imports all safety modules
from src.orchestrator import SyncOrchestrator
import inspect
source = inspect.getsource(SyncOrchestrator)
assert 'BackupManager' in source or 'backup_manager' in source, 'BackupManager not imported'
assert 'ConflictDetector' in source or 'conflict_detector' in source, 'ConflictDetector not imported'
assert 'SecretDetector' in source or 'secret_detector' in source, 'SecretDetector not imported'
assert 'SymlinkCleaner' in source or 'symlink_cleaner' in source, 'SymlinkCleaner not imported'
assert 'CompatibilityReporter' in source or 'compatibility_reporter' in source, 'CompatibilityReporter not imported'
print('PASS: Orchestrator imports all safety modules')

# Test 2: Orchestrator accepts allow_secrets parameter
sig = inspect.signature(SyncOrchestrator.__init__)
assert 'allow_secrets' in sig.parameters, 'allow_secrets parameter missing'
print('PASS: Orchestrator accepts allow_secrets')

# Test 3: /sync command has --allow-secrets flag
from src.commands import sync as sync_cmd
source = inspect.getsource(sync_cmd)
assert 'allow-secrets' in source or 'allow_secrets' in source, '--allow-secrets flag missing'
print('PASS: /sync command has --allow-secrets flag')

# Test 4: Secret detection blocks sync
with tempfile.TemporaryDirectory() as tmpdir:
    os.environ['HARNESSSYNC_STATE_DIR'] = tmpdir
    project_dir = Path(tmpdir)

    # Create minimal source structure for SourceReader
    claude_dir = project_dir / '.claude'
    claude_dir.mkdir()
    mcp_file = project_dir / '.mcp.json'
    mcp_file.write_text(json.dumps({
        'mcpServers': {
            'test': {
                'command': 'node',
                'args': ['server.js'],
                'env': {
                    'SECRET_API_KEY': 'sk_live_abcdefghijklmnopqrstuvwxyz1234567890'
                }
            }
        }
    }))

    # This tests that the orchestrator can be instantiated with allow_secrets
    orch = SyncOrchestrator(project_dir=project_dir, allow_secrets=True)
    assert orch.allow_secrets == True, 'allow_secrets not stored'
    print('PASS: Orchestrator stores allow_secrets')

# Test 5: Compatibility report integration
from src.compatibility_reporter import CompatibilityReporter
from src.adapters.result import SyncResult
cr = CompatibilityReporter()
results = {
    'codex': {
        'rules': SyncResult(synced=1, adapted=1),
        'mcp': SyncResult(failed=1, failed_files=['error']),
    }
}
report = cr.generate(results)
assert cr.has_issues(report), 'Should detect issues'
formatted = cr.format_report(report)
assert len(formatted) > 0, 'Report should not be empty'
print('PASS: Compatibility report integrates correctly')

print('All 5 integration tests passed')
" (Level 2: Proxy)
  </verify>
  <done>
    Orchestrator runs full safety pipeline: secret detection (blocks if detected, --allow-secrets overrides), conflict detection (warns, non-blocking), backup with rollback context, adapter sync, symlink cleanup, compatibility reporting, and backup retention cleanup. /sync command accepts --allow-secrets flag. All safety features are additive and do not break existing sync logic. Dry-run mode skips write-side-effect features while still running informational checks.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- S1: CompatibilityReporter class exists with generate, format_report, has_issues methods
- S2: SyncOrchestrator imports all 5 safety modules (grep verify)
- S3: SyncOrchestrator.__init__ accepts allow_secrets parameter
- S4: /sync command argparse includes --allow-secrets flag
- S5: Orchestrator sync_all method references safety modules

Level 2 (Proxy):
- P1: CompatibilityReporter generates correct per-target breakdown with counts
- P2: CompatibilityReporter distinguishes synced vs adapted vs failed items
- P3: Orchestrator stores allow_secrets parameter
- P4: /sync command source contains allow-secrets or allow_secrets
- P5: Full integration: compatibility report formats correctly for mixed results

Level 3 (Deferred):
- DEFER-05-05: End-to-end sync with backup/rollback on real adapter failure (requires live adapters)
- DEFER-05-06: Concurrent sync with backup + lock interaction (requires rapid successive syncs)
</verification>

<success_criteria>
1. CompatibilityReporter generates per-target sync analysis with synced/adapted/skipped/failed breakdown and explanations
2. SyncOrchestrator integrates all 5 safety features in correct order: secrets -> conflicts -> backup -> sync -> cleanup -> report -> retention
3. /sync command accepts --allow-secrets flag and passes through to orchestrator
4. Safety features are additive -- existing sync behavior unchanged when no issues detected
5. All 10 verification tests pass (5 reporter + 5 integration)
6. No external dependencies added (Python stdlib only)
</success_criteria>

<output>
After completion, create `.planning/phases/05-safety-validation/05-03-SUMMARY.md`
</output>
