---
phase: 02-adapter-framework-codex-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/adapters/__init__.py
  - src/adapters/base.py
  - src/adapters/registry.py
  - src/adapters/result.py
  - src/utils/toml_writer.py
autonomous: true
verification_level: sanity

must_haves:
  truths:
    - "AdapterBase is an ABC with 6 abstract sync methods (sync_rules, sync_skills, sync_agents, sync_commands, sync_mcp, sync_settings) and abstract target_name property"
    - "Instantiating a class that inherits AdapterBase without implementing all abstract methods raises TypeError"
    - "AdapterRegistry.register('name') decorator registers an adapter class and validates it inherits from AdapterBase"
    - "AdapterRegistry.get_adapter('name', project_dir) returns an instantiated adapter"
    - "AdapterRegistry.list_targets() returns list of all registered target names"
    - "SyncResult dataclass has synced/skipped/failed/adapted int fields and synced_files/skipped_files/failed_files list fields"
    - "SyncResult.merge(other) combines two results additively"
    - "escape_toml_string correctly escapes backslash, quote, newline, carriage return, and tab characters in correct order"
    - "format_toml_value handles str, int, float, bool, list, and dict types correctly"
    - "Generated TOML strings round-trip through tomllib.loads without error"
  artifacts:
    - path: "src/adapters/__init__.py"
      provides: "Adapter package with public exports"
      contains: "from .base import AdapterBase"
    - path: "src/adapters/base.py"
      provides: "Abstract adapter base class with 6 sync methods"
      exports: ["AdapterBase"]
    - path: "src/adapters/registry.py"
      provides: "Decorator-based adapter registry"
      exports: ["AdapterRegistry"]
    - path: "src/adapters/result.py"
      provides: "SyncResult dataclass for structured sync reporting"
      exports: ["SyncResult"]
    - path: "src/utils/toml_writer.py"
      provides: "Manual TOML formatting with proper escaping"
      exports: ["escape_toml_string", "format_toml_value", "format_toml_table", "format_mcp_server_toml"]
  key_links:
    - from: "src/adapters/__init__.py"
      to: "src/adapters/base.py"
      via: "re-export"
      pattern: "from .base import AdapterBase"
    - from: "src/adapters/__init__.py"
      to: "src/adapters/registry.py"
      via: "re-export"
      pattern: "from .registry import AdapterRegistry"
    - from: "src/adapters/__init__.py"
      to: "src/adapters/result.py"
      via: "re-export"
      pattern: "from .result import SyncResult"
    - from: "src/adapters/base.py"
      to: "src/adapters/result.py"
      via: "import for return types"
      pattern: "from .result import SyncResult"
    - from: "src/adapters/registry.py"
      to: "src/adapters/base.py"
      via: "import for type validation"
      pattern: "from .base import AdapterBase"
---

<objective>
Create the adapter framework infrastructure: abstract base class enforcing the 6-method sync interface, decorator-based registry for dynamic adapter discovery, structured SyncResult dataclass for reporting, and manual TOML writer utility for Codex config generation.

Purpose: This plan delivers the extension points that all target adapters (Codex, Gemini, OpenCode) depend on. The base class + registry pattern means adding a new target requires only a new file with @AdapterRegistry.register decorator -- no core engine changes. The TOML writer is needed by Codex adapter (Plan 02-02/03) for config.toml generation.

Output: src/adapters/ package (base.py, registry.py, result.py, __init__.py) and src/utils/toml_writer.py -- all importable and tested.

Research basis: 02-RESEARCH.md Pattern 1 (ABC Base Class), Pattern 2 (Decorator-Based Registry), Pattern 3 (Manual TOML Generation), Recommendation 1 (Adapter Pattern), Recommendation 2 (Manual TOML), Recommendation 3 (Dataclasses for SyncResult). Pitfall avoidance for TOML escaping order (Pitfall 1), registry type validation (Pitfall 3).
</objective>

<execution_context>
@.planning/phases/02-adapter-framework-codex-sync/02-RESEARCH.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@src/utils/__init__.py
@src/utils/paths.py
@src/state_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement adapter base class, registry, and SyncResult</name>
  <files>src/adapters/__init__.py, src/adapters/base.py, src/adapters/registry.py, src/adapters/result.py</files>
  <action>
    Create the src/adapters/ package with the adapter framework infrastructure based on 02-RESEARCH.md Pattern 1 (ABC Base Class) and Pattern 2 (Decorator-Based Registry).

    1. Create src/adapters/result.py -- SyncResult dataclass (ADP-03):
       ```python
       from dataclasses import dataclass, field
       ```
       - `@dataclass` class SyncResult with fields:
         - `synced: int = 0` -- count of successfully synced items
         - `skipped: int = 0` -- count of items skipped (already up-to-date or incompatible)
         - `failed: int = 0` -- count of items that failed to sync
         - `adapted: int = 0` -- count of items that required format adaptation
         - `synced_files: list[str] = field(default_factory=list)` -- paths of synced files
         - `skipped_files: list[str] = field(default_factory=list)` -- paths of skipped files
         - `failed_files: list[str] = field(default_factory=list)` -- paths of failed files with reason
       - Add `merge(self, other: 'SyncResult') -> 'SyncResult'` method that returns a NEW SyncResult with counts added and file lists concatenated
       - Add `@property total(self) -> int` returning synced + skipped + failed
       - Add `@property status(self) -> str` returning "success" if failed==0, "partial" if synced>0 and failed>0, "failed" if synced==0 and failed>0, "nothing" if total==0
       - Add module docstring explaining what each field means

    2. Create src/adapters/base.py -- AdapterBase ABC (ADP-01):
       ```python
       from abc import ABC, abstractmethod
       from pathlib import Path
       from .result import SyncResult
       ```
       - `class AdapterBase(ABC)` with:
         - `__init__(self, project_dir: Path)`: Store project_dir
         - `@property @abstractmethod target_name(self) -> str`: Return target CLI name (e.g., "codex")
         - `@abstractmethod sync_rules(self, rules: list[dict]) -> SyncResult`: Sync CLAUDE.md rules to target format. Each dict has 'path' (Path) and 'content' (str) keys.
         - `@abstractmethod sync_skills(self, skills: dict[str, Path]) -> SyncResult`: Sync skills to target. Keys are skill names, values are skill directory paths.
         - `@abstractmethod sync_agents(self, agents: dict[str, Path]) -> SyncResult`: Convert and sync agents. Keys are agent names, values are .md file paths.
         - `@abstractmethod sync_commands(self, commands: dict[str, Path]) -> SyncResult`: Convert and sync commands. Keys are command names, values are .md file paths.
         - `@abstractmethod sync_mcp(self, mcp_servers: dict[str, dict]) -> SyncResult`: Translate MCP server configs. Keys are server names, values are server config dicts.
         - `@abstractmethod sync_settings(self, settings: dict) -> SyncResult`: Map settings to target configuration.
         - Non-abstract `sync_all(self, source_data: dict) -> dict[str, SyncResult]` method that calls all 6 sync methods and returns dict keyed by config type ("rules", "skills", etc.) with SyncResult values. Wrap each call in try/except to report failures without aborting.

       IMPORTANT: The `sync_rules` parameter is `list[dict]` not `str` -- each dict has 'path' and 'content' keys as returned by SourceReader.get_rules(). This allows adapters to see which rule files exist and concatenate/merge as needed.

    3. Create src/adapters/registry.py -- AdapterRegistry (ADP-02):
       ```python
       from pathlib import Path
       from .base import AdapterBase
       ```
       - `class AdapterRegistry` with class-level `_adapters: dict[str, type[AdapterBase]] = {}`
       - `@classmethod register(cls, target_name: str)`: Decorator that:
         - Validates `issubclass(adapter_class, AdapterBase)` at registration time (Pitfall 3 prevention)
         - Raises TypeError if validation fails
         - Stores `cls._adapters[target_name] = adapter_class`
         - Returns the adapter class unchanged
       - `@classmethod get_adapter(cls, target_name: str, project_dir: Path) -> AdapterBase`: Instantiate and return registered adapter. Raise ValueError if target_name not registered.
       - `@classmethod list_targets(cls) -> list[str]`: Return sorted list of registered target names.
       - `@classmethod has_target(cls, target_name: str) -> bool`: Check if target is registered.

    4. Create src/adapters/__init__.py with public exports:
       ```python
       from .base import AdapterBase
       from .registry import AdapterRegistry
       from .result import SyncResult
       ```

    Avoid:
    - Do NOT import any external dependencies -- abc, dataclasses, pathlib are all stdlib
    - Do NOT add default implementations in abstract methods (except sync_all which is concrete)
    - Do NOT use dict for SyncResult -- use dataclass for type safety (Recommendation 3)
    - Do NOT validate adapter at instantiation time -- validate at registration time (Pitfall 3)
  </action>
  <verify>
    Run from project root (Level 1: Sanity):
    ```bash
    python3 -c "
    from pathlib import Path
    from src.adapters import AdapterBase, AdapterRegistry, SyncResult

    # Test 1: SyncResult defaults
    r = SyncResult()
    assert r.synced == 0 and r.skipped == 0 and r.failed == 0 and r.adapted == 0
    assert r.synced_files == [] and r.skipped_files == [] and r.failed_files == []
    assert r.total == 0 and r.status == 'nothing'
    print('SyncResult defaults: OK')

    # Test 2: SyncResult merge
    r1 = SyncResult(synced=2, failed=1, synced_files=['a', 'b'], failed_files=['c'])
    r2 = SyncResult(synced=1, skipped=3, synced_files=['d'], skipped_files=['e', 'f', 'g'])
    merged = r1.merge(r2)
    assert merged.synced == 3 and merged.failed == 1 and merged.skipped == 3
    assert merged.synced_files == ['a', 'b', 'd']
    assert merged.status == 'partial'
    print('SyncResult merge: OK')

    # Test 3: SyncResult status logic
    assert SyncResult(synced=5).status == 'success'
    assert SyncResult(synced=3, failed=2).status == 'partial'
    assert SyncResult(failed=3).status == 'failed'
    print('SyncResult status: OK')

    # Test 4: Abstract method enforcement
    class IncompleteAdapter(AdapterBase):
        @property
        def target_name(self) -> str:
            return 'test'
    try:
        IncompleteAdapter(Path('.'))
        assert False, 'Should have raised TypeError'
    except TypeError as e:
        assert 'abstract' in str(e).lower()
        print(f'ABC enforcement: OK ({e})')

    # Test 5: Registry validates inheritance
    try:
        @AdapterRegistry.register('bad')
        class NotAnAdapter:
            pass
        assert False, 'Should have raised TypeError'
    except TypeError:
        print('Registry validation: OK')

    # Test 6: Valid adapter registration
    @AdapterRegistry.register('test-target')
    class TestAdapter(AdapterBase):
        @property
        def target_name(self) -> str:
            return 'test-target'
        def sync_rules(self, rules): return SyncResult()
        def sync_skills(self, skills): return SyncResult()
        def sync_agents(self, agents): return SyncResult()
        def sync_commands(self, commands): return SyncResult()
        def sync_mcp(self, mcp_servers): return SyncResult()
        def sync_settings(self, settings): return SyncResult()

    assert 'test-target' in AdapterRegistry.list_targets()
    assert AdapterRegistry.has_target('test-target')
    adapter = AdapterRegistry.get_adapter('test-target', Path('.'))
    assert adapter.target_name == 'test-target'
    print('Registry registration: OK')

    # Test 7: Registry get_adapter fails for unknown target
    try:
        AdapterRegistry.get_adapter('nonexistent', Path('.'))
        assert False, 'Should have raised ValueError'
    except ValueError:
        print('Registry unknown target: OK')

    # Test 8: sync_all calls all methods
    results = adapter.sync_all({
        'rules': [], 'skills': {}, 'agents': {},
        'commands': {}, 'mcp': {}, 'settings': {}
    })
    assert set(results.keys()) == {'rules', 'skills', 'agents', 'commands', 'mcp', 'settings'}
    print('sync_all: OK')

    print('Adapter Framework: ALL CHECKS PASSED')
    "
    ```
  </verify>
  <done>src/adapters/ package with AdapterBase (ABC, 6 abstract sync methods + concrete sync_all), AdapterRegistry (decorator-based with type validation), and SyncResult (dataclass with merge/status). All 8 verification assertions pass. No external dependencies.</done>
</task>

<task type="auto">
  <name>Task 2: Implement manual TOML writer utility</name>
  <files>src/utils/toml_writer.py</files>
  <action>
    Create src/utils/toml_writer.py implementing manual TOML string formatting based on 02-RESEARCH.md Pattern 3 (Manual TOML Generation with Templates) and the TOML v1.0.0 specification.

    Functions to implement:

    1. `escape_toml_string(s: str) -> str`:
       - Escape special characters for TOML basic strings (double-quoted)
       - CRITICAL: Escape backslash FIRST, then quotes, then control chars (Pitfall 1 prevention)
       - Order: `\` -> `\\`, `"` -> `\"`, `\n` -> `\\n`, `\r` -> `\\r`, `\t` -> `\\t`
       - Return the escaped string (without surrounding quotes)

    2. `format_toml_value(value) -> str`:
       - Format a Python value as a TOML value string
       - str: `"escaped_string"` (using escape_toml_string)
       - int: `42` (no quotes)
       - float: `3.14` (no quotes)
       - bool: `true` or `false` (lowercase, no quotes)
       - list: `["val1", "val2"]` (each element formatted recursively)
       - dict: Return empty string (dicts become nested tables, handled separately)
       - None: Return empty string (skip None values)

    3. `format_toml_table(table_path: str, data: dict, skip_nested: bool = True) -> str`:
       - Format a TOML table section
       - Output: `[table_path]\n` followed by `key = value\n` lines
       - If skip_nested is True, skip dict values (they become their own table sections)
       - If skip_nested is False, inline dict values (not recommended for readability)
       - Handle quoted keys: if key contains special chars (`.`, `"`, spaces), quote it

    4. `format_mcp_server_toml(name: str, config: dict) -> str`:
       - Format a single MCP server as TOML following Codex `[mcp_servers."name"]` format
       - Output the table header: `[mcp_servers."name"]`
       - Required field: `command` (string)
       - Optional fields: `args` (list of strings), `enabled` (bool), `required` (bool)
       - Optional integer fields: `startup_timeout_sec`, `tool_timeout_sec`
       - Optional nested table: `env` dict -> `[mcp_servers."name".env]` section
       - Optional tool filtering: `enabled_tools` (list), `disabled_tools` (list)
       - Handle HTTP-based servers: `url` field instead of `command`/`args`, `bearer_token_env_var` field
       - Preserve env var references as-is (e.g., `${API_KEY}` stays literal) per research Pitfall 2
       - Separate sections with blank lines for readability

    5. `format_mcp_servers_toml(servers: dict[str, dict]) -> str`:
       - Format multiple MCP servers, each separated by double newlines
       - Call format_mcp_server_toml for each server
       - Add a HarnessSync header comment: `# MCP servers managed by HarnessSync\n# Do not edit manually\n\n`

    6. `write_toml_atomic(path: Path, content: str) -> None`:
       - Write TOML content atomically using tempfile + os.replace pattern from Phase 1
       - Reuse the atomic write pattern from state_manager.py (Pitfall 5 prevention)
       - Ensure parent directory exists via ensure_dir

    Add module docstring explaining:
    - Why manual TOML generation (tomllib is read-only, zero-dep constraint)
    - Escaping rules from TOML v1.0.0 spec
    - That env var references like ${VAR} are preserved as-is

    Avoid:
    - Do NOT use tomli-w or tomlkit (zero-dependency constraint)
    - Do NOT try to parse existing TOML files here (that is tomllib's job, done in codex.py)
    - Do NOT expand environment variables during formatting (Pitfall 2)
    - Do NOT escape in wrong order -- backslash MUST come first (Pitfall 1)
  </action>
  <verify>
    Run from project root (Level 1: Sanity):
    ```bash
    python3 -c "
    import tomllib
    from src.utils.toml_writer import (
        escape_toml_string,
        format_toml_value,
        format_mcp_server_toml,
        format_mcp_servers_toml,
    )

    # Test 1: Basic escaping
    assert escape_toml_string('simple') == 'simple'
    assert escape_toml_string('has\"quote') == 'has\\\\\"quote'
    assert escape_toml_string('back\\\\slash') == 'back\\\\\\\\slash'
    assert escape_toml_string('new\\nline') == 'new\\\\nline'
    print('Basic escaping: OK')

    # Test 2: Escaping order - backslash before quotes
    # String: a\"b -> should become a\\\\\\\\\"b in TOML
    s = 'a\\\\\"b'
    escaped = escape_toml_string(s)
    toml_str = f'test = \"{escaped}\"'
    parsed = tomllib.loads(toml_str)
    assert parsed['test'] == s, f'Round-trip failed: {parsed[\"test\"]} != {s}'
    print('Escape order: OK')

    # Test 3: Edge case round-trips through tomllib
    test_strings = [
        'simple',
        'with\"quotes',
        'with\\\\backslash',
        'path\\\\to\\\\file',
        'multi\\nline',
        '\${API_KEY}',
        'combo: \"quoted\\\\path\\n\"',
    ]
    for s in test_strings:
        escaped = escape_toml_string(s)
        toml_str = f'test = \"{escaped}\"'
        try:
            parsed = tomllib.loads(toml_str)
            assert parsed['test'] == s, f'Round-trip failed for [{s}]: got [{parsed[\"test\"]}]'
        except Exception as e:
            assert False, f'TOML parse failed for [{s}]: {e}\\nGenerated: {toml_str}'
    print('Round-trip escaping: OK')

    # Test 4: format_toml_value types
    assert format_toml_value('hello') == '\"hello\"'
    assert format_toml_value(42) == '42'
    assert format_toml_value(3.14) == '3.14'
    assert format_toml_value(True) == 'true'
    assert format_toml_value(False) == 'false'
    print('Value formatting: OK')

    # Test 5: MCP server TOML generation
    server_config = {
        'command': 'node',
        'args': ['server.js', '--port', '3000'],
        'env': {
            'API_KEY': '\${API_KEY}',
            'DB_HOST': 'localhost'
        },
        'enabled': True,
    }
    toml = format_mcp_server_toml('test-server', server_config)
    assert '[mcp_servers.\"test-server\"]' in toml
    assert 'command = \"node\"' in toml
    assert 'API_KEY' in toml
    assert '\${API_KEY}' in toml  # Env var preserved
    print('MCP server TOML: OK')

    # Test 6: Generated MCP server config parses with tomllib
    full_toml = format_mcp_server_toml('my-server', {
        'command': '/usr/bin/mcp-server',
        'args': ['--verbose'],
        'env': {'TOKEN': '\${MCP_TOKEN}'},
        'enabled': True,
        'startup_timeout_sec': 10,
    })
    parsed = tomllib.loads(full_toml)
    assert 'mcp_servers' in parsed
    assert 'my-server' in parsed['mcp_servers']
    srv = parsed['mcp_servers']['my-server']
    assert srv['command'] == '/usr/bin/mcp-server'
    assert srv['args'] == ['--verbose']
    assert srv['env']['TOKEN'] == '\${MCP_TOKEN}'
    assert srv['enabled'] == True
    assert srv['startup_timeout_sec'] == 10
    print('MCP TOML round-trip: OK')

    # Test 7: Multiple servers
    servers = {
        'server-a': {'command': 'a', 'args': ['--flag']},
        'server-b': {'command': 'b', 'env': {'KEY': 'val'}},
    }
    multi_toml = format_mcp_servers_toml(servers)
    assert 'server-a' in multi_toml
    assert 'server-b' in multi_toml
    assert 'HarnessSync' in multi_toml  # Header comment
    # Parse the generated multi-server TOML (strip comments first)
    parseable = '\\n'.join(l for l in multi_toml.split('\\n') if not l.startswith('#'))
    parsed_multi = tomllib.loads(parseable)
    assert len(parsed_multi['mcp_servers']) == 2
    print('Multiple servers: OK')

    print('TOML Writer: ALL CHECKS PASSED')
    "
    ```
  </verify>
  <done>src/utils/toml_writer.py with escape_toml_string (correct order), format_toml_value (6 types), format_mcp_server_toml (full Codex format with env vars), format_mcp_servers_toml (multi-server with header), write_toml_atomic (tempfile + os.replace). All generated TOML round-trips through tomllib without errors. No external dependencies.</done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- AdapterBase enforces abstract methods (TypeError on incomplete implementation)
- AdapterRegistry validates inheritance at registration time (TypeError on non-adapter class)
- SyncResult merge combines counts and file lists correctly
- TOML escaping round-trips all edge cases through tomllib.loads
- MCP server TOML format matches Codex [mcp_servers."name"] specification

Level 2 (Proxy): Deferred to Plan 02-02/03 which will use these in Codex adapter
Level 3 (Deferred): Full sync pipeline with state tracking, actual Codex CLI validation
</verification>

<success_criteria>
- All 5 files exist in src/adapters/ and src/utils/
- AdapterBase ABC enforces 6 sync methods + target_name property
- AdapterRegistry supports register/get_adapter/list_targets/has_target
- SyncResult has merge, total, status with correct semantics
- TOML writer correctly escapes all special characters (backslash first)
- All generated TOML parses cleanly with tomllib
- All verification scripts pass cleanly
- No external dependencies imported anywhere
</success_criteria>

<output>
After completion, create `.planning/phases/02-adapter-framework-codex-sync/02-01-SUMMARY.md`
</output>
