---
phase: 02-adapter-framework-codex-sync
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/adapters/codex.py
autonomous: true
verification_level: proxy

must_haves:
  truths:
    - "CodexAdapter is registered via @AdapterRegistry.register('codex') and discoverable"
    - "sync_rules concatenates all rule file contents into AGENTS.md with HarnessSync header marker and timestamp footer"
    - "sync_rules preserves existing non-managed content in AGENTS.md above the HarnessSync marker"
    - "sync_skills creates symlinks from source skill directories to .agents/skills/{name}/ using create_symlink_with_fallback"
    - "sync_agents parses agent .md frontmatter (name, description) and <role> section, writes SKILL.md in .agents/skills/agent-{name}/"
    - "sync_agents discards Claude-specific fields (tools, color) and preserves name + description in SKILL.md frontmatter"
    - "sync_commands parses command .md files and writes SKILL.md in .agents/skills/cmd-{name}/"
    - "All sync methods return SyncResult with accurate synced/skipped/failed counts and file paths"
  artifacts:
    - path: "src/adapters/codex.py"
      provides: "Codex CLI adapter with rules, skills, agents, and commands sync"
      exports: ["CodexAdapter"]
      min_lines: 150
  key_links:
    - from: "src/adapters/codex.py"
      to: "src/adapters/base.py"
      via: "inheritance"
      pattern: "class CodexAdapter(AdapterBase)"
    - from: "src/adapters/codex.py"
      to: "src/adapters/registry.py"
      via: "self-registration"
      pattern: "@AdapterRegistry.register"
    - from: "src/adapters/codex.py"
      to: "src/adapters/result.py"
      via: "return type"
      pattern: "from .result import SyncResult"
    - from: "src/adapters/codex.py"
      to: "src/utils/paths.py"
      via: "symlink creation"
      pattern: "from src.utils.paths import create_symlink_with_fallback"
---

<objective>
Implement the Codex adapter for rules, skills, agents, and commands sync. This covers the content-oriented sync operations: writing AGENTS.md for rules (CDX-01), creating symlinks for skills (CDX-02), converting Claude Code agents to SKILL.md format (CDX-03), and converting commands to SKILL.md format (CDX-04).

Purpose: Rules and skills/agents/commands are the core configuration content that developers need synced. Rules go to AGENTS.md (Codex's equivalent of CLAUDE.md). Skills use symlinks for zero-copy sharing. Agents and commands require format conversion from Claude Code .md to Codex SKILL.md with YAML frontmatter.

Output: src/adapters/codex.py with CodexAdapter class implementing sync_rules, sync_skills, sync_agents, sync_commands (MCP and settings deferred to Plan 02-03).

Research basis: 02-RESEARCH.md Pattern 4 (Agent-to-Skill Conversion), Codex Skills Documentation (SKILL.md format with name/description frontmatter), AGENTS.md Format (marker-based managed sections), Skills Directory Structure (.agents/skills/ location).
</objective>

<execution_context>
@.planning/phases/02-adapter-framework-codex-sync/02-RESEARCH.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-adapter-framework-codex-sync/02-01-PLAN.md
@src/adapters/base.py
@src/adapters/result.py
@src/utils/paths.py
@src/source_reader.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CodexAdapter with rules and skills sync</name>
  <files>src/adapters/codex.py</files>
  <action>
    Create src/adapters/codex.py with the CodexAdapter class, starting with sync_rules (CDX-01) and sync_skills (CDX-02).

    1. File structure and imports:
       ```python
       import re
       from datetime import datetime, timezone
       from pathlib import Path
       from .base import AdapterBase
       from .registry import AdapterRegistry
       from .result import SyncResult
       from src.utils.paths import create_symlink_with_fallback, ensure_dir
       ```

    2. Define constants:
       - `HARNESSSYNC_MARKER = "<!-- Managed by HarnessSync -->"` -- marker for managed content in AGENTS.md
       - `HARNESSSYNC_MARKER_END = "<!-- End HarnessSync managed content -->"` -- end marker
       - `AGENTS_MD = "AGENTS.md"` -- Codex rules file name
       - `SKILLS_DIR = ".agents/skills"` -- Codex skills directory (per Agent Skills spec)

    3. Register and implement CodexAdapter:
       ```python
       @AdapterRegistry.register("codex")
       class CodexAdapter(AdapterBase):
       ```

       - `__init__(self, project_dir: Path)`: Call super().__init__(project_dir), set up target paths:
         - `self.agents_md_path = project_dir / AGENTS_MD`
         - `self.skills_dir = project_dir / SKILLS_DIR`

       - `@property target_name(self) -> str`: Return `"codex"`

    4. Implement `sync_rules(self, rules: list[dict]) -> SyncResult` (CDX-01):
       - If rules is empty, return SyncResult(skipped=1, skipped_files=["AGENTS.md: no rules to sync"])
       - Concatenate all rule contents with separator: `\n\n---\n\n` between each
       - Build managed section:
         ```
         {HARNESSSYNC_MARKER}
         # Rules synced from Claude Code

         {concatenated rules content}

         ---
         *Last synced by HarnessSync: {ISO timestamp UTC}*
         {HARNESSSYNC_MARKER_END}
         ```
       - If AGENTS.md already exists, read it:
         - Find existing marker section (between HARNESSSYNC_MARKER and HARNESSSYNC_MARKER_END)
         - Replace just the managed section, preserving content outside markers
         - If no markers found, append managed section to end
       - If AGENTS.md does not exist, write managed section as full content
       - Use ensure_dir for parent directory
       - Write file using Path.write_text (non-atomic OK for AGENTS.md since it is not parsed by Codex at startup)
       - Return SyncResult(synced=1, adapted=len(rules), synced_files=[str(self.agents_md_path)])

    5. Implement `sync_skills(self, skills: dict[str, Path]) -> SyncResult` (CDX-02):
       - For each skill name -> source directory:
         - Target: `self.skills_dir / name`
         - Use create_symlink_with_fallback(source_path, target_path)
         - Track success/failure in SyncResult
       - If skills is empty, return SyncResult()
       - Return SyncResult with counts and file paths

    6. Add stub methods for sync_agents, sync_commands, sync_mcp, sync_settings that return SyncResult() -- these will be implemented in Task 2 (agents/commands) and Plan 02-03 (mcp/settings).

    Helper methods:
    - `_read_agents_md(self) -> str`: Read existing AGENTS.md or return empty string
    - `_write_agents_md(self, content: str)`: Write AGENTS.md with ensure_dir
    - `_replace_managed_section(self, existing: str, managed: str) -> str`: Find and replace content between markers, or append if no markers exist

    Avoid:
    - Do NOT use atomic writes for AGENTS.md -- it is human-readable and not parsed at Codex startup (TOML is the critical one)
    - Do NOT modify content outside the HarnessSync markers -- user's manual additions must be preserved
    - Do NOT resolve symlinks when recording paths in SyncResult -- record as-is (Decision #13)
  </action>
  <verify>
    Run from project root (Level 2: Proxy):
    ```bash
    python3 -c "
    import tempfile, os, shutil
    from pathlib import Path
    from src.adapters.codex import CodexAdapter
    from src.adapters import AdapterRegistry, SyncResult

    # Setup: temp project directory
    tmp = Path(tempfile.mkdtemp())

    # Test 1: CodexAdapter is registered
    assert 'codex' in AdapterRegistry.list_targets()
    adapter = AdapterRegistry.get_adapter('codex', tmp)
    assert adapter.target_name == 'codex'
    print('Registration: OK')

    # Test 2: sync_rules with content
    rules = [
        {'path': Path('CLAUDE.md'), 'content': '# Project Rules\n\nBe concise.'},
        {'path': Path('.claude/CLAUDE.md'), 'content': '# Local Rules\n\nUse Python 3.'},
    ]
    result = adapter.sync_rules(rules)
    assert result.synced == 1, f'Expected 1 synced, got {result.synced}'
    assert result.adapted == 2, f'Expected 2 adapted, got {result.adapted}'
    agents_md = tmp / 'AGENTS.md'
    assert agents_md.exists()
    content = agents_md.read_text()
    assert 'Managed by HarnessSync' in content
    assert 'Be concise' in content
    assert 'Use Python 3' in content
    assert 'Last synced by HarnessSync' in content
    print('sync_rules: OK')

    # Test 3: sync_rules preserves existing content outside markers
    agents_md.write_text('# My Custom Instructions\n\nDo X always.\n\n' + content)
    rules2 = [{'path': Path('CLAUDE.md'), 'content': 'Updated rules.'}]
    result2 = adapter.sync_rules(rules2)
    new_content = agents_md.read_text()
    assert 'My Custom Instructions' in new_content, 'User content was lost!'
    assert 'Updated rules' in new_content
    assert 'Be concise' not in new_content, 'Old managed content should be replaced'
    print('Preserve existing: OK')

    # Test 4: sync_rules empty returns skipped
    result3 = adapter.sync_rules([])
    assert result3.skipped == 1
    print('Empty rules: OK')

    # Test 5: sync_skills creates symlinks
    skill_src = tmp / 'source_skills' / 'my-skill'
    skill_src.mkdir(parents=True)
    (skill_src / 'SKILL.md').write_text('---\nname: my-skill\n---\nInstructions')
    result4 = adapter.sync_skills({'my-skill': skill_src})
    assert result4.synced == 1
    target_skill = tmp / '.agents' / 'skills' / 'my-skill'
    assert target_skill.exists() or target_skill.is_symlink()
    print('sync_skills: OK')

    # Test 6: sync_skills with already-linked skill returns skipped
    result5 = adapter.sync_skills({'my-skill': skill_src})
    assert result5.skipped >= 1
    print('Skills idempotent: OK')

    shutil.rmtree(tmp)
    print('Codex Adapter (rules+skills): ALL CHECKS PASSED')
    "
    ```
  </verify>
  <done>CodexAdapter with sync_rules writing AGENTS.md with marker-based managed sections (preserves user content) and sync_skills creating symlinks via create_symlink_with_fallback. Registered via @AdapterRegistry.register("codex"). All 6 verification assertions pass.</done>
</task>

<task type="auto">
  <name>Task 2: Implement agent-to-skill and command-to-skill conversion</name>
  <files>src/adapters/codex.py</files>
  <action>
    Extend CodexAdapter in src/adapters/codex.py with sync_agents (CDX-03) and sync_commands (CDX-04). Replace the stub methods from Task 1.

    1. Add helper methods for parsing Claude Code agent format:

       `_parse_frontmatter(self, content: str) -> tuple[dict, str]`:
       - Extract YAML frontmatter (between `---` delimiters at start of file)
       - Parse simple `key: value` lines (no nested YAML needed -- Claude Code agents use flat frontmatter)
       - Handle multi-word values (strip quotes if present)
       - Return (frontmatter_dict, body_after_frontmatter)
       - If no frontmatter found, return ({}, full_content)

       `_extract_role_section(self, body: str) -> str`:
       - Extract content between `<role>` and `</role>` tags
       - If no role tags found, return the full body (graceful fallback)
       - Strip leading/trailing whitespace from extracted content

       `_format_skill_md(self, name: str, description: str, instructions: str) -> str`:
       - Build Codex SKILL.md content with YAML frontmatter:
         ```
         ---
         name: {name}
         description: {description}
         ---

         {instructions}

         ## When to Use This Skill

         {description}
         ```
       - If description is empty, use name as description fallback

    2. Implement `sync_agents(self, agents: dict[str, Path]) -> SyncResult` (CDX-03):
       - For each agent_name -> agent_path:
         - Read agent .md file content
         - Parse frontmatter to extract name, description (discard tools, color)
         - Extract instructions from <role> section (or full body)
         - Format as SKILL.md using _format_skill_md
         - Target directory: `self.skills_dir / f"agent-{name}"`
         - Create directory if needed via ensure_dir
         - Write SKILL.md to target directory
         - Track in SyncResult (adapted count since format conversion happened)
       - If agent file cannot be read: add to failed_files with reason
       - If agents dict is empty: return SyncResult()

    3. Implement `sync_commands(self, commands: dict[str, Path]) -> SyncResult` (CDX-04):
       - Similar to sync_agents but with different target directory prefix:
         - Target: `self.skills_dir / f"cmd-{name}"`
       - Commands in Claude Code have a simpler format (just markdown with optional frontmatter)
       - Parse frontmatter if present for name/description
       - Use full command content as skill instructions (no <role> extraction needed for commands)
       - If no description found, use "Claude Code command: {name}" as description

    Avoid:
    - Do NOT use PyYAML or any YAML parser -- simple key:value splitting is sufficient for Claude Code frontmatter
    - Do NOT attempt to translate tool permissions from agents to skills -- that is out of scope for skill content
    - Do NOT create empty SKILL.md files -- skip agents/commands that have no content
    - Do NOT overwrite user-created SKILL.md files -- check if file exists and has no HarnessSync marker before writing
  </action>
  <verify>
    Run from project root (Level 2: Proxy):
    ```bash
    python3 -c "
    import tempfile, shutil
    from pathlib import Path
    from src.adapters.codex import CodexAdapter

    tmp = Path(tempfile.mkdtemp())
    adapter = CodexAdapter(tmp)

    # Test 1: Agent with full frontmatter and <role> section
    agent_dir = tmp / 'agents'
    agent_dir.mkdir()
    agent_file = agent_dir / 'reviewer.md'
    agent_file.write_text('''---
name: code-reviewer
description: Reviews code for quality and best practices
tools: Read, Grep, Glob
color: blue
---

<role>
You are a code reviewer. Focus on:
1. Code quality
2. Best practices
3. Security issues
</role>

<additional_context>
Use OWASP guidelines.
</additional_context>
''')

    result = adapter.sync_agents({'reviewer': agent_file})
    assert result.synced == 1, f'Expected 1 synced, got {result.synced}'
    assert result.adapted == 1, f'Expected 1 adapted, got {result.adapted}'

    skill_dir = tmp / '.agents' / 'skills' / 'agent-reviewer'
    assert skill_dir.exists(), 'Skill directory not created'
    skill_md = skill_dir / 'SKILL.md'
    assert skill_md.exists(), 'SKILL.md not created'

    content = skill_md.read_text()
    assert 'name: code-reviewer' in content, 'Name not in frontmatter'
    assert 'description: Reviews code' in content, 'Description not in frontmatter'
    assert 'code reviewer' in content.lower(), 'Role instructions missing'
    assert 'tools:' not in content, 'Claude-specific tools field should be removed'
    assert 'color:' not in content, 'Claude-specific color field should be removed'
    assert 'When to Use This Skill' in content, 'Missing trigger section'
    print('Agent conversion: OK')

    # Test 2: Agent without frontmatter (just body)
    bare_agent = agent_dir / 'helper.md'
    bare_agent.write_text('You are a helpful assistant. Help with anything.')

    result2 = adapter.sync_agents({'helper': bare_agent})
    assert result2.synced == 1
    helper_skill = tmp / '.agents' / 'skills' / 'agent-helper' / 'SKILL.md'
    assert helper_skill.exists()
    helper_content = helper_skill.read_text()
    assert 'helpful assistant' in helper_content
    print('Bare agent: OK')

    # Test 3: Agent with <role> tags
    role_agent = agent_dir / 'planner.md'
    role_agent.write_text('''---
name: planner
description: Plans project tasks
---

<role>
Plan tasks carefully. Break into small steps.
</role>
''')
    result3 = adapter.sync_agents({'planner': role_agent})
    planner_skill = tmp / '.agents' / 'skills' / 'agent-planner' / 'SKILL.md'
    assert 'Plan tasks carefully' in planner_skill.read_text()
    assert 'planner' in planner_skill.read_text()
    print('Role extraction: OK')

    # Test 4: Command conversion
    cmd_dir = tmp / 'commands'
    cmd_dir.mkdir()
    cmd_file = cmd_dir / 'deploy.md'
    cmd_file.write_text('''---
name: deploy
description: Deploy the application
---

Run the deployment pipeline:
1. Build the project
2. Run tests
3. Deploy to staging
''')

    result4 = adapter.sync_commands({'deploy': cmd_file})
    assert result4.synced == 1
    assert result4.adapted == 1
    cmd_skill = tmp / '.agents' / 'skills' / 'cmd-deploy' / 'SKILL.md'
    assert cmd_skill.exists()
    cmd_content = cmd_skill.read_text()
    assert 'name: deploy' in cmd_content
    assert 'deployment pipeline' in cmd_content
    print('Command conversion: OK')

    # Test 5: Command without frontmatter
    bare_cmd = cmd_dir / 'test.md'
    bare_cmd.write_text('Run all tests with pytest. Use -v flag.')
    result5 = adapter.sync_commands({'test': bare_cmd})
    assert result5.synced == 1
    test_skill = tmp / '.agents' / 'skills' / 'cmd-test' / 'SKILL.md'
    assert 'pytest' in test_skill.read_text()
    print('Bare command: OK')

    # Test 6: Empty agents/commands
    assert adapter.sync_agents({}).synced == 0
    assert adapter.sync_commands({}).synced == 0
    print('Empty input: OK')

    # Test 7: Missing agent file handled gracefully
    result6 = adapter.sync_agents({'ghost': Path('/nonexistent/agent.md')})
    assert result6.failed == 1
    assert len(result6.failed_files) == 1
    print('Missing file: OK')

    shutil.rmtree(tmp)
    print('Codex Adapter (agents+commands): ALL CHECKS PASSED')
    "
    ```
  </verify>
  <done>CodexAdapter with sync_agents converting Claude Code agent .md to Codex SKILL.md (extracts frontmatter name/description, <role> instructions, discards tools/color) in .agents/skills/agent-{name}/, and sync_commands converting commands to SKILL.md in .agents/skills/cmd-{name}/. All 7 verification assertions pass including edge cases (bare markdown, missing files, empty input).</done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- CodexAdapter registered and discoverable via AdapterRegistry
- AGENTS.md written with correct marker format

Level 2 (Proxy):
- sync_rules preserves user content outside HarnessSync markers
- sync_skills creates working symlinks that resolve to source
- Agent-to-skill conversion preserves name/description, extracts <role>, discards Claude-specific fields
- Command-to-skill conversion creates valid SKILL.md
- All sync methods return accurate SyncResult counts
- Edge cases handled: empty input, missing files, bare markdown without frontmatter

Level 3 (Deferred): Codex CLI reads generated AGENTS.md and skills directories
</verification>

<success_criteria>
- CodexAdapter class exists in src/adapters/codex.py
- @AdapterRegistry.register("codex") decorator present
- sync_rules writes AGENTS.md with HarnessSync markers and preserves existing content
- sync_skills creates symlinks to .agents/skills/ directory
- sync_agents converts agents to SKILL.md with name/description frontmatter and role instructions
- sync_commands converts commands to SKILL.md with cmd- prefix
- All 4 sync methods return SyncResult with accurate counts
- Claude-specific fields (tools, color) stripped from converted skills
- All verification scripts pass cleanly
- No external dependencies imported
</success_criteria>

<output>
After completion, create `.planning/phases/02-adapter-framework-codex-sync/02-02-SUMMARY.md`
</output>
