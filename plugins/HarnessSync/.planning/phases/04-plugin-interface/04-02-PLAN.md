---
phase: 04-plugin-interface
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/commands/sync.py
  - commands/sync.md
autonomous: true
verification_level: proxy

must_haves:
  truths:
    - "/sync command entry point parses $ARGUMENTS string using shlex.split() + argparse for --scope and --dry-run flags"
    - "/sync with no arguments syncs all targets with scope=all and returns summary statistics (synced/skipped/failed per target)"
    - "/sync --scope user syncs only user-scope config, --scope project syncs only project-scope config"
    - "/sync --dry-run produces unified diff output showing what would change without writing any files"
    - "/sync acquires sync_lock before syncing and exits gracefully if lock is held by another process"
    - "/sync checks should_debounce and skips sync if last sync was <3 seconds ago"
    - "commands/sync.md command file invokes src/commands/sync.py with $ARGUMENTS placeholder"
  artifacts:
    - path: "src/commands/sync.py"
      provides: "/sync slash command implementation with argument parsing, lock, debounce, orchestrator invocation"
      exports: ["main"]
    - path: "commands/sync.md"
      provides: "Claude Code slash command definition for /sync"
      contains: "python"
  key_links:
    - from: "src/commands/sync.py"
      to: "src/orchestrator.py"
      via: "SyncOrchestrator import and sync_all() call"
      pattern: "from src.orchestrator import SyncOrchestrator"
    - from: "src/commands/sync.py"
      to: "src/lock.py"
      via: "sync_lock and should_debounce imports"
      pattern: "from src.lock import sync_lock, should_debounce"
    - from: "commands/sync.md"
      to: "src/commands/sync.py"
      via: "$ARGUMENTS shell invocation"
      pattern: "python.*sync.py.*ARGUMENTS"
---

<objective>
Implement the /sync slash command that users invoke to manually trigger configuration sync across all targets.

Purpose: Users need a way to manually trigger sync on demand (not just reactive hooks). The command supports scope filtering (user/project/all) and dry-run preview mode for safe exploration before committing changes. This is the primary user interface for HarnessSync.

Output: src/commands/sync.py (command script), commands/sync.md (Claude Code command definition)
</objective>

<execution_context>
@${CLAUDE_PLUGIN_ROOT}/references/execute-plan.md
@${CLAUDE_PLUGIN_ROOT}/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-plugin-interface/04-RESEARCH.md
@src/orchestrator.py
@src/lock.py
@src/diff_formatter.py
@src/utils/logger.py
@src/state_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement /sync slash command script and command definition</name>
  <files>src/commands/__init__.py, src/commands/sync.py, commands/sync.md</files>
  <action>
    **Part A: Create src/commands/__init__.py**
    - Empty file (package marker)

    **Part B: Create src/commands/sync.py**

    Implement main() function as the /sync command entry point:

    1. **Argument parsing:**
       - Get raw args from sys.argv[1:] (Claude Code passes $ARGUMENTS as separate args)
       - Join into single string, then shlex.split() to handle quotes/escapes
       - Create argparse.ArgumentParser(prog="sync", description="Sync Claude Code config to all targets")
       - Add --scope argument: choices=["user", "project", "all"], default="all"
       - Add --dry-run argument: action="store_true", help="Preview changes without writing"
       - Parse with parser.parse_args(tokens)
       - Handle parse errors gracefully: print usage and exit

    2. **Debounce check:**
       - Create StateManager() instance
       - Call should_debounce(state_manager)
       - If True: print "Sync skipped (debounce: last sync <3s ago)" and exit 0

    3. **Lock acquisition:**
       - Import sync_lock, LOCK_FILE_DEFAULT from src.lock
       - Wrap sync in `with sync_lock(LOCK_FILE_DEFAULT):` block
       - On BlockingIOError: print "Sync already in progress, skipping" and exit 0

    4. **Orchestrator invocation:**
       - Determine project_dir using Path.cwd() (Claude Code runs commands from project root)
       - Create SyncOrchestrator(project_dir, scope=args.scope, dry_run=args.dry_run)
       - Call results = orchestrator.sync_all()

    5. **Output formatting:**
       - If dry_run: print the preview output from each target
       - If normal sync: print summary table:
         ```
         HarnessSync Results
         ==================
         Target    | Synced | Skipped | Failed | Status
         ----------+--------+---------+--------+--------
         codex     |      5 |       2 |      0 | success
         gemini    |      4 |       3 |      0 | success
         opencode  |      3 |       4 |      0 | success
         ```
       - Print total sync time if measurable
       - Return exit code 0 for success, 1 for any failures

    6. **Error handling:**
       - Wrap entire main() in try/except
       - Catch KeyboardInterrupt: print "Sync cancelled" and exit 130
       - Catch Exception: print error message and exit 1

    **Part C: Create commands/sync.md**

    First, ensure the commands/ directory exists:
    ```python
    Path("commands").mkdir(exist_ok=True)
    ```

    Claude Code slash command definition:
    ```markdown
    ---
    description: Sync Claude Code config to all targets (Codex, Gemini, OpenCode)
    ---

    Sync your Claude Code configuration to all configured targets.

    Usage: /sync [--scope user|project|all] [--dry-run]

    Options:
    - --scope: Sync scope (user, project, or all). Default: all
    - --dry-run: Preview changes without writing files

    !python ${CLAUDE_PLUGIN_ROOT}/src/commands/sync.py $ARGUMENTS
    ```

    Design notes:
    - The command markdown file uses ${CLAUDE_PLUGIN_ROOT} for portability when installed as a plugin
    - Output goes to stdout (Claude Code captures and displays it)
    - Exit code 0 always (even on partial failures) to avoid blocking Claude Code
    - Use sys.path manipulation at top of sync.py to ensure imports work:
      `sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))`
      This adds the project root to sys.path so `from src.xxx import` works regardless of CWD
    - Alternatively, use CLAUDE_PLUGIN_ROOT env var if available for path resolution
  </action>
  <verify>
    # Test 1: Argument parsing
    python -c "
import sys, os
sys.path.insert(0, '.')
from pathlib import Path

# Test basic import
from src.commands.sync import main
print('PASS: sync command module imports')

# Test argparse directly
import shlex, argparse
parser = argparse.ArgumentParser(prog='sync')
parser.add_argument('--scope', choices=['user', 'project', 'all'], default='all')
parser.add_argument('--dry-run', action='store_true')

args = parser.parse_args(shlex.split('--scope user --dry-run'))
assert args.scope == 'user', f'Wrong scope: {args.scope}'
assert args.dry_run == True, f'dry_run should be True'
print('PASS: argument parsing works')

args2 = parser.parse_args([])
assert args2.scope == 'all', f'Default scope should be all: {args2.scope}'
assert args2.dry_run == False, f'Default dry_run should be False'
print('PASS: default arguments correct')
" (Level 1: Sanity)

    # Test 2: Command file exists and has correct structure
    python -c "
from pathlib import Path
cmd_file = Path('commands/sync.md')
assert cmd_file.exists(), 'commands/sync.md should exist'
content = cmd_file.read_text()
assert 'description:' in content, 'Should have frontmatter'
assert 'ARGUMENTS' in content, 'Should reference ARGUMENTS'
assert 'sync.py' in content, 'Should reference sync.py script'
print('PASS: commands/sync.md has correct structure')
" (Level 1: Sanity)

    # Test 3: Full invocation with dry-run (does not write files)
    python -c "
import sys, os, tempfile
sys.path.insert(0, '.')
from pathlib import Path

# Create temp project dir
with tempfile.TemporaryDirectory() as td:
    project_dir = Path(td)
    os.chdir(str(project_dir))

    # Simulate sync.py with --dry-run
    from src.orchestrator import SyncOrchestrator
    orch = SyncOrchestrator(project_dir=project_dir, scope='all', dry_run=True)
    results = orch.sync_all()
    assert isinstance(results, dict), f'Results should be dict: {type(results)}'
    print('PASS: Dry-run sync produces results without error')
" (Level 2: Proxy)
  </verify>
  <done>
    /sync slash command parses --scope and --dry-run flags, checks debounce, acquires file lock,
    invokes SyncOrchestrator, and prints formatted summary table. commands/sync.md defines the
    slash command for Claude Code. Argument parsing handles edge cases (no args, quoted values).
    All 4 tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement /sync-status slash command</name>
  <files>src/commands/sync_status.py, commands/sync-status.md</files>
  <action>
    **Part A: Create src/commands/sync_status.py**

    Implement main() function as the /sync-status command entry point:

    1. **Status retrieval:**
       - Create StateManager() instance
       - Call state = state_manager.get_all_status()
       - Get list of registered targets from AdapterRegistry.list_targets()

    2. **Per-target display:**
       For each target (codex, gemini, opencode):
       - Get target_state = state.get("targets", {}).get(target)
       - If None: display "Never synced" status
       - If exists: display:
         - Last sync timestamp (human-readable, e.g., "2026-02-14 15:30:22")
         - Status (success/partial/failed)
         - Scope used (user/project/all)
         - Items synced/skipped/failed counts

    3. **Drift detection:**
       - For each target with previous sync state:
         - Get stored file hashes from target state
         - Compute current hashes for the same files using hash_file_sha256()
         - Call state_manager.detect_drift(target, current_hashes)
         - If drifted files found: display list with warning indicator
         - If no drift: display "In sync" indicator

    4. **Output formatting:**
       Print structured status report:
       ```
       HarnessSync Status
       ==================

       Last sync: 2026-02-14 15:30:22

       Target: codex
         Status: success
         Last sync: 2026-02-14 15:30:22
         Scope: all
         Items: 5 synced, 2 skipped, 0 failed
         Drift: None detected

       Target: gemini
         Status: success
         Last sync: 2026-02-14 15:30:22
         Scope: all
         Items: 4 synced, 3 skipped, 0 failed
         Drift: 2 files changed
           - ~/.claude/CLAUDE.md (modified)
           - ~/.claude/.mcp.json (modified)

       Target: opencode
         Status: never synced
       ```

    5. **sys.path setup:** Same pattern as sync.py for import resolution

    **Part B: Create commands/sync-status.md**

    First, ensure the commands/ directory exists:
    ```python
    Path("commands").mkdir(exist_ok=True)
    ```

    Claude Code slash command definition:
    ```markdown
    ---
    description: Show HarnessSync status and drift detection for all targets
    ---

    Show sync status, last sync time per target, and drift detection.

    Usage: /sync-status

    !python ${CLAUDE_PLUGIN_ROOT}/src/commands/sync_status.py $ARGUMENTS
    ```

    Design notes:
    - This command is read-only - it never modifies state or target files
    - No lock needed (read-only)
    - No debounce needed (read-only)
    - Drift detection re-hashes current source files and compares against stored hashes
    - For files that no longer exist, show "(deleted)" indicator
    - For new files not in stored hashes, show "(new)" indicator
  </action>
  <verify>
    # Test 1: Import and basic invocation
    python -c "
import sys, os, tempfile
sys.path.insert(0, '.')
from pathlib import Path
from src.commands.sync_status import main
print('PASS: sync_status module imports')
" (Level 1: Sanity)

    # Test 2: Status with no prior syncs
    python -c "
import sys, tempfile
sys.path.insert(0, '.')
from pathlib import Path
from src.state_manager import StateManager

with tempfile.TemporaryDirectory() as td:
    sm = StateManager(state_dir=Path(td))
    status = sm.get_all_status()
    assert status.get('targets') == {} or 'targets' not in status or status.get('targets') == {}, 'Should have empty targets'
    print('PASS: Empty state returns no targets')
" (Level 1: Sanity)

    # Test 3: Status with recorded sync
    python -c "
import sys, tempfile
sys.path.insert(0, '.')
from pathlib import Path
from src.state_manager import StateManager

with tempfile.TemporaryDirectory() as td:
    sm = StateManager(state_dir=Path(td))
    sm.record_sync('codex', 'all', {'/tmp/test': 'abc123'}, {'/tmp/test': 'symlink'}, 3, 1, 0)
    target = sm.get_target_status('codex')
    assert target is not None, 'Should have codex target'
    assert target['status'] == 'success', f'Wrong status: {target[\"status\"]}'
    assert target['items_synced'] == 3, f'Wrong synced count: {target[\"items_synced\"]}'
    print('PASS: Status shows correct sync data')
" (Level 1: Sanity)

    # Test 4: Drift detection
    python -c "
import sys, tempfile
sys.path.insert(0, '.')
from pathlib import Path
from src.state_manager import StateManager

with tempfile.TemporaryDirectory() as td:
    sm = StateManager(state_dir=Path(td))
    sm.record_sync('codex', 'all', {'/tmp/test': 'abc123', '/tmp/test2': 'def456'}, {}, 2, 0, 0)
    # Simulate drift: hash changed for test, test2 removed, test3 added
    drifted = sm.detect_drift('codex', {'/tmp/test': 'CHANGED', '/tmp/test3': 'new123'})
    assert '/tmp/test' in drifted, 'Changed file should be detected'
    assert '/tmp/test2' in drifted, 'Removed file should be detected'
    assert '/tmp/test3' in drifted, 'New file should be detected'
    print('PASS: Drift detection identifies changed, removed, and new files')
" (Level 2: Proxy)

    # Test 5: Command file exists
    python -c "
from pathlib import Path
cmd_file = Path('commands/sync-status.md')
assert cmd_file.exists(), 'commands/sync-status.md should exist'
content = cmd_file.read_text()
assert 'description:' in content, 'Should have frontmatter'
assert 'sync_status.py' in content, 'Should reference sync_status.py'
print('PASS: commands/sync-status.md exists with correct structure')
" (Level 1: Sanity)
  </verify>
  <done>
    /sync-status command displays per-target sync status, timestamps, item counts, and drift detection.
    Drift detection re-hashes current source files and compares against stored state.
    commands/sync-status.md defines the slash command for Claude Code.
    All 5 tests pass. Read-only operation, no locks or debounce needed.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- /sync command parses --scope and --dry-run arguments correctly
- Default arguments: scope=all, dry_run=False
- commands/sync.md exists with correct structure
- /sync-status module imports without error
- Empty state returns no targets
- Recorded sync data appears in status output

Level 2 (Proxy):
- /sync --dry-run produces preview output without writing files
- Drift detection identifies changed, removed, and new files
- commands/sync-status.md exists with correct structure

Level 3 (Deferred):
- /sync invoked from Claude Code session as slash command
- /sync-status displays real drift from actual config changes
</verification>

<success_criteria>
1. src/commands/sync.py parses $ARGUMENTS, checks debounce/lock, invokes SyncOrchestrator, prints formatted results
2. src/commands/sync_status.py displays per-target status with drift detection
3. commands/sync.md and commands/sync-status.md define Claude Code slash commands
4. All 9 verification tests pass (4 for /sync, 5 for /sync-status)
5. No new external dependencies (Python stdlib + existing src/ modules only)
</success_criteria>

<output>
After completion, create `.planning/phases/04-plugin-interface/04-02-SUMMARY.md`
</output>
