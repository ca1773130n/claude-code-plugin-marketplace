---
phase: 04-plugin-interface
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/hooks/post_tool_use.py
  - hooks/hooks.json
autonomous: true
verification_level: proxy

must_haves:
  truths:
    - "PostToolUse hook reads JSON from stdin containing tool_name and tool_input fields"
    - "Hook triggers sync only when file_path matches config patterns (CLAUDE.md, .mcp.json, skills/, agents/, commands/, settings.json)"
    - "Hook skips sync for non-config file edits (exits 0 silently)"
    - "Hook checks should_debounce() and skips sync if last sync was <3 seconds ago"
    - "Hook acquires sync_lock before syncing and exits gracefully if lock is held"
    - "Hook always exits with code 0 (never blocks Claude Code tool execution)"
    - "hooks/hooks.json configures PostToolUse hook with Edit|Write matcher"
  artifacts:
    - path: "src/hooks/post_tool_use.py"
      provides: "PostToolUse hook script for auto-sync on config file edits"
      exports: ["main"]
    - path: "hooks/hooks.json"
      provides: "Hook configuration for Claude Code PostToolUse event"
      contains: "PostToolUse"
  key_links:
    - from: "src/hooks/post_tool_use.py"
      to: "src/orchestrator.py"
      via: "SyncOrchestrator import and sync_all() call"
      pattern: "from src.orchestrator import SyncOrchestrator"
    - from: "src/hooks/post_tool_use.py"
      to: "src/lock.py"
      via: "sync_lock and should_debounce imports"
      pattern: "from src.lock import sync_lock, should_debounce"
    - from: "hooks/hooks.json"
      to: "src/hooks/post_tool_use.py"
      via: "command field referencing hook script"
      pattern: "post_tool_use.py"
---

<objective>
Implement the PostToolUse hook for reactive auto-sync when Claude Code writes to config files, with debouncing and file-based locking.

Purpose: The hook enables the core value proposition of HarnessSync -- configure once, sync everywhere -- by automatically syncing when Claude Code modifies configuration files. Without the hook, users must manually invoke /sync after every edit. The debounce and lock prevent resource waste and race conditions.

Output: src/hooks/post_tool_use.py (hook script), hooks/hooks.json (hook configuration)
</objective>

<execution_context>
@${CLAUDE_PLUGIN_ROOT}/references/execute-plan.md
@${CLAUDE_PLUGIN_ROOT}/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-plugin-interface/04-RESEARCH.md
@src/orchestrator.py
@src/lock.py
@src/state_manager.py
@src/utils/logger.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PostToolUse hook script</name>
  <files>src/hooks/__init__.py, src/hooks/post_tool_use.py</files>
  <action>
    **Part A: Create src/hooks/__init__.py**
    - Empty file (package marker)

    **Part B: Create src/hooks/post_tool_use.py**

    Implement main() function as the PostToolUse hook entry point:

    1. **sys.path setup:**
       - Determine plugin root from script location:
         ```python
         PLUGIN_ROOT = Path(__file__).resolve().parent.parent.parent
         sys.path.insert(0, str(PLUGIN_ROOT))
         ```
       - Also check CLAUDE_PLUGIN_ROOT env var as alternative

    2. **Read hook event data from stdin:**
       - Use json.load(sys.stdin) to parse incoming JSON
       - Extract tool_name = hook_data.get("tool_name", "")
       - Extract file_path = hook_data.get("tool_input", {}).get("file_path", "")
       - Handle json.JSONDecodeError: exit 0 silently (don't block Claude Code)

    3. **Config file pattern matching:**
       - Define CONFIG_PATTERNS list:
         - "CLAUDE.md" (rules files)
         - ".mcp.json" (MCP server configs)
         - "/skills/" (skill directories)
         - "/agents/" (agent definitions)
         - "/commands/" (command definitions)
         - "settings.json" (settings files)
         - "settings.local.json" (local settings)
       - Check if file_path contains any pattern: `any(pattern in file_path for pattern in CONFIG_PATTERNS)`
       - If no match: exit 0 immediately (not a config file, no sync needed)
       - Log to stderr: f"HarnessSync: config change detected: {file_path}"

    4. **Debounce check:**
       - Create StateManager() instance
       - Call should_debounce(state_manager)
       - If True: log to stderr "HarnessSync: sync skipped (debounce)", exit 0

    5. **Lock and sync:**
       - Wrap in try/except:
         - Acquire sync_lock(LOCK_FILE_DEFAULT)
         - Determine project_dir: use CLAUDE_PROJECT_DIR env var if available, else Path.cwd()
         - Create SyncOrchestrator(project_dir, scope="all", dry_run=False)
         - Call results = orchestrator.sync_all()
         - Log to stderr: f"HarnessSync: synced {target_count} targets"
       - On BlockingIOError: log to stderr "HarnessSync: sync in progress, skipping", exit 0
       - On any Exception: log to stderr f"HarnessSync: sync error: {e}", exit 0

    6. **Exit code:**
       - ALWAYS exit 0 (never exit 2 which would block the tool action)
       - PostToolUse hook should be non-blocking -- even if sync fails, the user's edit should succeed
       - All logging goes to stderr (stdout is for hook control messages)

    Design notes:
    - The hook is a standalone script, not a library module. It's invoked as a subprocess by Claude Code.
    - All output goes to stderr because stdout exit codes control tool behavior
    - Keep the hook fast: debounce check + lock check should return in <10ms for non-config files
    - The hook script should be chmod +x executable
    - Error handling is defensive: any unexpected error -> exit 0 (don't block user)
  </action>
  <verify>
    # Test 1: Module imports
    python -c "
import sys
sys.path.insert(0, '.')
from src.hooks.post_tool_use import CONFIG_PATTERNS, is_config_file
print('PASS: post_tool_use module imports')
" (Level 1: Sanity)

    # Test 2: Config file pattern matching
    python -c "
import sys
sys.path.insert(0, '.')
from src.hooks.post_tool_use import is_config_file

# Should match config files
assert is_config_file('/home/user/.claude/CLAUDE.md') == True, 'CLAUDE.md should match'
assert is_config_file('/project/.mcp.json') == True, '.mcp.json should match'
assert is_config_file('/project/.claude/skills/my-skill/SKILL.md') == True, 'skills/ should match'
assert is_config_file('/project/.claude/agents/my-agent.md') == True, 'agents/ should match'
assert is_config_file('/project/.claude/commands/my-cmd.md') == True, 'commands/ should match'
assert is_config_file('/home/user/.claude/settings.json') == True, 'settings.json should match'
assert is_config_file('/project/.claude/settings.local.json') == True, 'settings.local.json should match'

# Should NOT match non-config files
assert is_config_file('/project/src/main.py') == False, 'main.py should not match'
assert is_config_file('/project/README.md') == False, 'README.md should not match'
assert is_config_file('/project/package.json') == False, 'package.json should not match'
assert is_config_file('/project/src/settings.py') == False, 'settings.py should not match'
assert is_config_file('') == False, 'empty string should not match'

print('PASS: Config file pattern matching works correctly')
" (Level 1: Sanity)

    # Test 3: Hook processes stdin JSON correctly
    python -c "
import sys, json, io
sys.path.insert(0, '.')

# Simulate hook receiving config edit event
hook_data = {
    'tool_name': 'Edit',
    'tool_input': {
        'file_path': '/project/CLAUDE.md',
        'old_string': 'old',
        'new_string': 'new'
    }
}

# Test JSON parsing logic (without invoking full main which reads stdin)
from src.hooks.post_tool_use import is_config_file
file_path = hook_data.get('tool_input', {}).get('file_path', '')
assert is_config_file(file_path) == True, f'Should detect CLAUDE.md as config: {file_path}'
print('PASS: Hook correctly identifies config file edits from stdin JSON')
" (Level 2: Proxy)

    # Test 4: Hook ignores non-config edits
    python -c "
import sys
sys.path.insert(0, '.')
from src.hooks.post_tool_use import is_config_file

non_config_data = {
    'tool_name': 'Edit',
    'tool_input': {
        'file_path': '/project/src/app.py'
    }
}
file_path = non_config_data.get('tool_input', {}).get('file_path', '')
assert is_config_file(file_path) == False, f'app.py should not trigger sync: {file_path}'
print('PASS: Hook skips non-config file edits')
" (Level 1: Sanity)
  </verify>
  <done>
    PostToolUse hook reads JSON from stdin, matches config file patterns, checks debounce/lock,
    and triggers sync via SyncOrchestrator. Always exits 0 to never block Claude Code.
    is_config_file() correctly identifies all 7 config patterns and rejects non-config files.
    All 4 tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create hooks.json configuration and update plugin.json</name>
  <files>hooks/hooks.json, plugin.json</files>
  <action>
    **Part A: Create hooks/hooks.json**

    Write hooks.json file for Claude Code hook registration:

    ```json
    {
      "hooks": {
        "PostToolUse": [
          {
            "matcher": "Edit|Write|MultiEdit",
            "hooks": [
              {
                "type": "command",
                "command": "python ${CLAUDE_PLUGIN_ROOT}/src/hooks/post_tool_use.py"
              }
            ]
          }
        ]
      }
    }
    ```

    Design decisions:
    - Match Edit, Write, AND MultiEdit tools (covers all file modification tools)
    - Use ${CLAUDE_PLUGIN_ROOT} for path portability
    - Type "command" indicates external script execution
    - No timeout override (use Claude Code default of 10 minutes, which is more than enough)

    **Part B: Update plugin.json**

    Read existing plugin.json and update it to reflect actual file locations:

    1. Update hooks section to reference hooks/hooks.json:
       ```json
       "hooks": "hooks/hooks.json"
       ```
       (Replace the inline hooks object with a file reference, which is the standard Claude Code plugin pattern)

    2. Update commands section to reference command markdown files:
       ```json
       "commands": {
         "sync": "commands/sync.md",
         "sync-status": "commands/sync-status.md"
       }
       ```
       (Replace the inline command objects with file path references)

    3. Keep existing fields (name, version, description, author, license, main, skills, mcp) unchanged

    Design notes:
    - plugin.json is the manifest Claude Code reads to discover plugin capabilities
    - File references (strings) vs inline objects depends on Claude Code plugin system version
    - Keeping both formats (inline + file) may be needed for compatibility -- check research
    - The key insight from research: commands are markdown files, hooks are configured in hooks.json
    - If Claude Code expects inline commands with script paths, keep the existing format but ensure script paths match actual files
  </action>
  <verify>
    # Test 1: hooks.json is valid JSON with correct structure
    python -c "
import json
from pathlib import Path

hooks_file = Path('hooks/hooks.json')
assert hooks_file.exists(), 'hooks/hooks.json should exist'

data = json.loads(hooks_file.read_text())
assert 'hooks' in data, 'Should have hooks key'
assert 'PostToolUse' in data['hooks'], 'Should have PostToolUse hook'

post_hooks = data['hooks']['PostToolUse']
assert len(post_hooks) > 0, 'Should have at least one PostToolUse entry'

entry = post_hooks[0]
assert 'matcher' in entry, 'Should have matcher'
assert 'Edit' in entry['matcher'], 'Matcher should include Edit'
assert 'Write' in entry['matcher'], 'Matcher should include Write'
assert 'hooks' in entry, 'Should have hooks list'
assert entry['hooks'][0]['type'] == 'command', 'Hook type should be command'
assert 'post_tool_use.py' in entry['hooks'][0]['command'], 'Command should reference post_tool_use.py'

print('PASS: hooks.json has correct structure')
" (Level 1: Sanity)

    # Test 2: plugin.json is valid and references correct files
    python -c "
import json
from pathlib import Path

plugin = json.loads(Path('plugin.json').read_text())
assert plugin['name'] == 'HarnessSync', f'Wrong name: {plugin[\"name\"]}'
assert 'hooks' in plugin, 'Should have hooks section'
assert 'commands' in plugin, 'Should have commands section'
print('PASS: plugin.json is valid with hooks and commands')
" (Level 1: Sanity)

    # Test 3: All referenced files exist
    python -c "
from pathlib import Path

files = [
    'hooks/hooks.json',
    'commands/sync.md',
    'commands/sync-status.md',
    'src/hooks/post_tool_use.py',
    'src/commands/sync.py',
    'src/commands/sync_status.py',
    'plugin.json',
]

missing = [f for f in files if not Path(f).exists()]
assert len(missing) == 0, f'Missing files: {missing}'
print('PASS: All plugin files exist')
" (Level 1: Sanity)

    # Test 4: Integration check - full plugin structure
    python -c "
import json
from pathlib import Path

# Verify plugin manifest points to real files
plugin = json.loads(Path('plugin.json').read_text())
print(f'Plugin: {plugin[\"name\"]} v{plugin[\"version\"]}')
print(f'Commands: {list(plugin.get(\"commands\", {}).keys())}')
print(f'Hooks: {\"PostToolUse\" if \"hooks\" in plugin else \"none\"}')
print(f'Main: {plugin.get(\"main\", \"none\")}')
print('PASS: Plugin manifest integrity verified')
" (Level 2: Proxy)
  </verify>
  <done>
    hooks/hooks.json configures PostToolUse hook with Edit|Write|MultiEdit matcher pointing to
    post_tool_use.py. plugin.json updated to reference actual command and hook file locations.
    All referenced files exist and plugin manifest is valid JSON. All 4 tests pass.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- PostToolUse hook module imports without error
- Config file pattern matching correctly identifies all 7 patterns
- Config file matching rejects non-config files
- hooks/hooks.json is valid JSON with PostToolUse configuration
- plugin.json is valid with hooks and commands sections
- All plugin files exist at referenced paths

Level 2 (Proxy):
- Hook correctly parses stdin JSON and extracts file_path
- Hook skips non-config file edits
- Plugin manifest integrity verified with correct file references

Level 3 (Deferred):
- Hook fires in live Claude Code session after editing CLAUDE.md
- Debounce prevents rapid successive syncs in live session
- Lock prevents concurrent syncs from multiple hook invocations
</verification>

<success_criteria>
1. src/hooks/post_tool_use.py reads stdin JSON, matches config patterns, checks debounce/lock, triggers sync
2. Hook always exits 0 (never blocks Claude Code tool execution)
3. hooks/hooks.json configures PostToolUse with Edit|Write|MultiEdit matcher
4. plugin.json updated with correct file references for commands and hooks
5. All 8 verification tests pass (4 for hook script, 4 for hooks.json/plugin.json)
6. No new external dependencies (Python stdlib only)
</success_criteria>

<output>
After completion, create `.planning/phases/04-plugin-interface/04-03-SUMMARY.md`
</output>
