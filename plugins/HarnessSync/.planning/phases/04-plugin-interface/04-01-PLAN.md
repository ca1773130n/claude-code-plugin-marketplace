---
phase: 04-plugin-interface
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/orchestrator.py
  - src/lock.py
  - src/diff_formatter.py
autonomous: true
verification_level: sanity

must_haves:
  truths:
    - "SyncOrchestrator.sync_all() calls SourceReader.discover_all(), iterates AdapterRegistry adapters, and returns per-target SyncResult dicts"
    - "SyncOrchestrator respects scope argument (user/project/all) and passes it through to SourceReader"
    - "SyncOrchestrator records sync results to StateManager after successful sync (not in dry-run mode)"
    - "sync_lock() context manager acquires exclusive non-blocking fcntl.flock and raises BlockingIOError when lock held"
    - "sync_lock() gracefully skips locking on Windows with warning (fcntl unavailable)"
    - "should_debounce() returns True when last sync was less than 3 seconds ago based on StateManager.last_sync"
    - "DiffFormatter.format_target_diff() generates unified diff output comparing current target state vs proposed sync state"
    - "SyncOrchestrator dry_run=True produces diff output and writes no files"
  artifacts:
    - path: "src/orchestrator.py"
      provides: "SyncOrchestrator class coordinating SourceReader -> AdapterRegistry -> StateManager flow"
      exports: ["SyncOrchestrator"]
    - path: "src/lock.py"
      provides: "File-based locking (sync_lock) and time-based debouncing (should_debounce)"
      exports: ["sync_lock", "should_debounce"]
    - path: "src/diff_formatter.py"
      provides: "Unified diff output for dry-run mode"
      exports: ["DiffFormatter"]
  key_links:
    - from: "src/orchestrator.py"
      to: "src/source_reader.py"
      via: "SourceReader import and discover_all() call"
      pattern: "from src.source_reader import SourceReader"
    - from: "src/orchestrator.py"
      to: "src/adapters/__init__.py"
      via: "AdapterRegistry import and get_adapter() / list_targets() call"
      pattern: "from src.adapters import AdapterRegistry"
    - from: "src/orchestrator.py"
      to: "src/state_manager.py"
      via: "StateManager import and record_sync() call"
      pattern: "from src.state_manager import StateManager"
    - from: "src/orchestrator.py"
      to: "src/lock.py"
      via: "sync_lock import for concurrency protection"
      pattern: "from src.lock import sync_lock"
    - from: "src/orchestrator.py"
      to: "src/diff_formatter.py"
      via: "DiffFormatter import for dry-run preview"
      pattern: "from src.diff_formatter import DiffFormatter"
---

<objective>
Build the core orchestrator that coordinates SourceReader -> AdapterRegistry -> StateManager flow, plus supporting utilities for file locking, debouncing, and diff formatting.

Purpose: All user-facing components (slash commands, hooks) need a shared sync orchestrator. Building it first avoids duplication and creates a single testable coordination layer. The lock and debounce utilities prevent concurrent syncs and rapid-fire redundant syncs.

Output: src/orchestrator.py (SyncOrchestrator class), src/lock.py (sync_lock + should_debounce), src/diff_formatter.py (DiffFormatter for dry-run diffs)
</objective>

<execution_context>
@${CLAUDE_PLUGIN_ROOT}/references/execute-plan.md
@${CLAUDE_PLUGIN_ROOT}/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-plugin-interface/04-RESEARCH.md

@src/source_reader.py
@src/state_manager.py
@src/adapters/__init__.py
@src/adapters/base.py
@src/adapters/registry.py
@src/adapters/result.py
@src/utils/logger.py
@src/utils/hashing.py
@src/utils/paths.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement lock.py with sync_lock context manager and should_debounce</name>
  <files>src/lock.py</files>
  <action>
    Create src/lock.py with two public functions:

    1. **sync_lock(lock_path: Path) context manager:**
       - Accept lock_path parameter (default: ~/.harnesssync/sync.lock)
       - Ensure lock_path.parent directory exists (mkdir -p)
       - Open lock file with os.O_CREAT | os.O_RDWR, mode 0o644
       - Use fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB) for non-blocking exclusive lock
       - On success: yield fd, then unlock (fcntl.LOCK_UN) and close in finally block
       - On BlockingIOError: close fd and re-raise (caller handles gracefully)
       - Platform check: if sys.platform == "win32", skip locking entirely - yield None and print warning to stderr ("File locking not available on Windows - concurrent syncs may conflict")
       - Use contextlib.contextmanager decorator

    2. **should_debounce(state_manager: StateManager, debounce_seconds: float = 3.0) -> bool:**
       - Get state_manager.last_sync timestamp (ISO format string or None)
       - If None: return False (never synced, allow sync)
       - Parse ISO timestamp using datetime.fromisoformat()
       - Compare against time.time() (current Unix time)
       - Return True if elapsed < debounce_seconds (skip this sync)
       - Handle ValueError on malformed timestamps: return False (allow sync)

    Design notes:
    - Import fcntl conditionally inside the function body or at module level with try/except ImportError for Windows compatibility
    - Keep both functions simple - no classes, just module-level functions
    - Use LOCK_FILE_DEFAULT = Path.home() / ".harnesssync" / "sync.lock" as module constant
  </action>
  <verify>
    python -c "
import sys, os, time
sys.path.insert(0, '.')
from pathlib import Path
from src.lock import sync_lock, should_debounce, LOCK_FILE_DEFAULT

# Test 1: sync_lock acquires and releases
import tempfile
with tempfile.TemporaryDirectory() as td:
    lock_path = Path(td) / 'test.lock'
    with sync_lock(lock_path) as fd:
        assert fd is not None, 'Lock should return file descriptor'
        assert lock_path.exists(), 'Lock file should exist'
    print('PASS: sync_lock acquires and releases')

# Test 2: sync_lock raises BlockingIOError when held
import tempfile
with tempfile.TemporaryDirectory() as td:
    lock_path = Path(td) / 'test2.lock'
    with sync_lock(lock_path):
        try:
            with sync_lock(lock_path):
                assert False, 'Should have raised BlockingIOError'
        except BlockingIOError:
            print('PASS: sync_lock blocks concurrent acquisition')

# Test 3: should_debounce with no last_sync
from src.state_manager import StateManager
with tempfile.TemporaryDirectory() as td:
    sm = StateManager(state_dir=Path(td))
    result = should_debounce(sm)
    assert result == False, f'Expected False, got {result}'
    print('PASS: should_debounce returns False when no last_sync')

# Test 4: should_debounce with recent sync
from src.state_manager import StateManager
with tempfile.TemporaryDirectory() as td:
    sm = StateManager(state_dir=Path(td))
    sm.record_sync('test', 'all', {}, {}, 1, 0, 0)
    result = should_debounce(sm)
    assert result == True, f'Expected True (just synced), got {result}'
    print('PASS: should_debounce returns True after recent sync')

# Test 5: LOCK_FILE_DEFAULT path
assert str(LOCK_FILE_DEFAULT).endswith('.harnesssync/sync.lock'), f'Wrong default: {LOCK_FILE_DEFAULT}'
print('PASS: LOCK_FILE_DEFAULT correct')
print('ALL TESTS PASSED')
" (Level 1: Sanity)
  </verify>
  <done>
    sync_lock context manager acquires exclusive non-blocking flock, raises BlockingIOError when held,
    skips gracefully on Windows. should_debounce checks last_sync timestamp from StateManager and returns
    True when elapsed < 3 seconds. All 5 tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement orchestrator.py and diff_formatter.py</name>
  <files>src/orchestrator.py, src/diff_formatter.py</files>
  <action>
    **Part A: Create src/diff_formatter.py**

    Implement DiffFormatter class with these methods:

    1. **__init__(self):**
       - Initialize empty list self.diffs to accumulate diff sections

    2. **add_text_diff(self, label: str, old_content: str, new_content: str) -> None:**
       - Use difflib.unified_diff(old_lines, new_lines, fromfile=f"current/{label}", tofile=f"synced/{label}", lineterm="")
       - Store diff lines in self.diffs if any differences found
       - If no differences, store "[no changes]" note for this label

    3. **add_file_diff(self, label: str, old_path: Path | None, new_content: str) -> None:**
       - If old_path exists and is a file: read its content and call add_text_diff
       - If old_path is None or doesn't exist: treat as empty old content (shows all lines as additions)

    4. **add_structural_diff(self, label: str, old_items: dict, new_items: dict) -> None:**
       - For structured data (MCP servers, settings): show added/removed/changed keys
       - Format: "+ added: key_name", "- removed: key_name", "~ changed: key_name"

    5. **format_output(self) -> str:**
       - Join all accumulated diffs with section separators
       - Return complete diff string for display

    **Part B: Create src/orchestrator.py**

    Implement SyncOrchestrator class:

    1. **__init__(self, project_dir: Path, scope: str = "all", dry_run: bool = False):**
       - Store project_dir, scope, dry_run
       - Create Logger instance
       - Create StateManager instance (default path)

    2. **sync_all(self) -> dict[str, dict[str, SyncResult]]:**
       - Create SourceReader(scope=self.scope, project_dir=self.project_dir)
       - Call source_data = reader.discover_all()
       - Get targets = AdapterRegistry.list_targets()
       - For each target:
         - adapter = AdapterRegistry.get_adapter(target, self.project_dir)
         - If self.dry_run: call self._preview_sync(adapter, source_data) and add to results
         - Else: call adapter.sync_all(source_data) and add to results
       - If NOT dry_run: call self._update_state(results, reader) to persist
       - Log summary via self.logger
       - Return results dict: {target_name: {config_type: SyncResult}}

    3. **_preview_sync(self, adapter, source_data: dict) -> dict[str, str]:**
       - Create DiffFormatter instance
       - For rules: generate diff between current target rules file content vs new content
       - For skills/agents/commands: show which would be added/removed/updated
       - For MCP: show structural diff of server configs
       - For settings: show structural diff
       - Return {"preview": diff_formatter.format_output(), "is_preview": True}

    4. **_update_state(self, results: dict, reader: SourceReader) -> None:**
       - For each target in results:
         - Aggregate SyncResult counts across all config types
         - Get source_paths from reader.get_source_paths()
         - Hash each source file using hash_file_sha256()
         - Call self.state_manager.record_sync(target, scope, file_hashes, sync_methods, synced, skipped, failed)

    5. **get_status(self) -> dict:**
       - Return self.state_manager.get_all_status()
       - Include drift detection: for each target, get current file hashes and compare via detect_drift()

    Design notes:
    - The sync_all() method does NOT acquire locks or check debounce. Callers (commands, hooks) handle that.
      This keeps orchestrator testable without needing lock infrastructure.
    - sync_all() accepts source_data from SourceReader.discover_all() which uses keys:
      'rules' (str), 'skills' (dict), 'agents' (dict), 'commands' (dict), 'mcp_servers' (dict), 'settings' (dict)
    - AdapterBase.sync_all() expects keys: 'rules', 'skills', 'agents', 'commands', 'mcp', 'settings'
      Note the key difference: SourceReader uses 'mcp_servers', AdapterBase expects 'mcp'.
      The orchestrator should translate: source_data_for_adapter = {**source_data, 'mcp': source_data.pop('mcp_servers', {})}
    - Import from existing modules only (src.source_reader, src.adapters, src.state_manager, src.utils.*)
  </action>
  <verify>
    python -c "
import sys, tempfile
sys.path.insert(0, '.')
from pathlib import Path

# Test 1: DiffFormatter text diff
from src.diff_formatter import DiffFormatter
df = DiffFormatter()
df.add_text_diff('rules', 'line1\nline2\n', 'line1\nline3\n')
output = df.format_output()
assert 'line2' in output and 'line3' in output, f'Diff should show changes: {output}'
print('PASS: DiffFormatter generates text diff')

# Test 2: DiffFormatter no changes
df2 = DiffFormatter()
df2.add_text_diff('rules', 'same\n', 'same\n')
output2 = df2.format_output()
assert 'no changes' in output2.lower(), f'Should indicate no changes: {output2}'
print('PASS: DiffFormatter reports no changes correctly')

# Test 3: DiffFormatter structural diff
df3 = DiffFormatter()
df3.add_structural_diff('mcp', {'server-a': {}}, {'server-a': {}, 'server-b': {}})
output3 = df3.format_output()
assert 'server-b' in output3, f'Should show added server: {output3}'
print('PASS: DiffFormatter structural diff works')

# Test 4: SyncOrchestrator instantiation
from src.orchestrator import SyncOrchestrator
with tempfile.TemporaryDirectory() as td:
    project_dir = Path(td)
    orch = SyncOrchestrator(project_dir=project_dir, scope='all', dry_run=False)
    assert orch.scope == 'all'
    assert orch.dry_run == False
    print('PASS: SyncOrchestrator instantiates correctly')

# Test 5: SyncOrchestrator dry_run mode
with tempfile.TemporaryDirectory() as td:
    project_dir = Path(td)
    orch = SyncOrchestrator(project_dir=project_dir, scope='all', dry_run=True)
    results = orch.sync_all()
    # Should return preview dicts, not SyncResults
    for target, target_results in results.items():
        assert 'preview' in target_results or isinstance(target_results, dict), f'Dry run should produce preview output for {target}'
    print('PASS: SyncOrchestrator dry_run produces preview output')

# Test 6: SyncOrchestrator get_status
with tempfile.TemporaryDirectory() as td:
    project_dir = Path(td)
    orch = SyncOrchestrator(project_dir=project_dir, scope='all')
    status = orch.get_status()
    assert 'version' in status, f'Status should include version: {status}'
    print('PASS: SyncOrchestrator.get_status() returns state')

print('ALL TESTS PASSED')
" (Level 1: Sanity)
  </verify>
  <done>
    SyncOrchestrator coordinates SourceReader -> AdapterRegistry -> StateManager with scope/dry-run support.
    DiffFormatter generates unified diff for text and structural diff for configs.
    Orchestrator translates 'mcp_servers' key to 'mcp' for adapter compatibility.
    State updates persist after non-dry-run syncs. All 6 tests pass.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- sync_lock acquires and releases exclusive lock
- sync_lock raises BlockingIOError on concurrent acquisition
- should_debounce returns False when never synced, True after recent sync
- DiffFormatter generates text and structural diffs
- SyncOrchestrator instantiates with scope/dry_run params
- SyncOrchestrator.sync_all() returns per-target results
- SyncOrchestrator.get_status() returns state dict

Level 2 (Proxy):
- Deferred to Plan 04-02/04-03 where commands/hooks invoke orchestrator end-to-end

Level 3 (Deferred):
- Full integration with Claude Code plugin system (requires installed plugin)
- Lock contention under real concurrent hook invocations
</verification>

<success_criteria>
1. src/orchestrator.py exists with SyncOrchestrator class that coordinates the full sync pipeline
2. src/lock.py exists with sync_lock context manager and should_debounce function
3. src/diff_formatter.py exists with DiffFormatter class for dry-run preview output
4. All 11 verification tests pass (5 for lock/debounce, 6 for orchestrator/diff)
5. No new external dependencies introduced (Python stdlib only)
</success_criteria>

<output>
After completion, create `.planning/phases/04-plugin-interface/04-01-SUMMARY.md`
</output>
